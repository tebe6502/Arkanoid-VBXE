; ------------------------------------------------------------
; Mad Pascal Compiler version 1.7.5 [2025/10/05] for MOS 6502 CPU
; ------------------------------------------------------------

STACKWIDTH	= 16
CODEORIGIN	= $2000

TRUE		= 1
FALSE		= 0
EOL		= $9B
__BUFFER	= $0400
@BUF		= __BUFFER

; ------------------------------------------------------------

	org $80

zpage

.if .def(@vbxe_detect)
fxptr	.ds 2						; VBXE pointer
.fi

.if .def(@AllocMem)||.def(MAIN.SYSTEM.GETMEM)||.def(MAIN.SYSTEM.FREEMEM)
psptr	.ds 2						; PROGRAMSTACK Pointer
.fi

bp	.ds 2
bp2	.ds 2
bp3	= bp+1

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4

TMP
ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

STACKORIGIN	.ds STACKWIDTH*4
zpend

; ------------------------------------------------------------

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

	.ifdef MAIN.@DEFINES.BASICOFF
	org CODEORIGIN
	icl 'atari\basicoff.asm'
	ini CODEORIGIN
	.fi

	.ifdef MAIN.@DEFINES.S_VBXE
	opt h-
	ins 'atari\s_vbxe\sdxld2.obx'
	opt h+
	.fi

	org CODEORIGIN

.local	MAIN.@RESOURCE
.endl

.local	RESOURCE
	icl 'atari\resource.asm'
	?EXTDETECT = 0
	?VBXDETECT = 0

	RCDATA 'walls.dat' adr.ALL_WALLS 0 0 0 0 0 0 0 0
	RCDATA 'sqrtable.dat' adr.SQRTABLE 0 0 0 0 0 0 0 0
	RCDATA 'sintable.dat' adr.SINTABLE 0 0 0 0 0 0 0 0
	RCDATA 'atan_tab2.dat' adr.ATAN_TAB 0 0 0 0 0 0 0 0
	XBMP 'arkanoid_digit.bmp' VBXE_DIGIT 0 1 0 0 0 0 0 0
	XBMP 'flux2.bmp' FLUX2_OFS 0 1 0 0 0 0 0 0
	XBMP 'title.bmp' PRESENTS_OFS 0 1 0 0 0 0 0 0
	XBMP 'playscreen.bmp' PLAYSCREEN_OFS 0 1 0 0 0 0 0 0
	XBMP 'btm.bmp' VBXE_DATA 0 1 0 0 0 0 0 0
.endl

; ------------------------------------------------------------

	org CODEORIGIN

	STATICDATA

; ------------------------------------------------------------

RTLIB
	icl 'rtl6502_a8.asm'

.print 'ZPAGE: ',zpage,'..',zpend-1

.print 'RTBUF: ',@buf,'..',@buf+255

.print 'RTLIB: ',RTLIB,'..',*-1

; ------------------------------------------------------------

START
	tsx
	stx MAIN.@halt+1

	.ifdef MAIN.@DEFINES.ROMOFF
	icl 'atari\romoff.asm'
	.fi

VLEN	= VARDATASIZE-VARINITSIZE
VADR	= DATAORIGIN+VARINITSIZE

	ift (VADR > $BFFF) && .not(.def MAIN.@DEFINES.ROMOFF)
	ert 'Invalid memory address range ',VADR
	eif

	ift (VLEN > 0) && (VLEN <= 256)
	ldx #256-VLEN
	lda #$00
	sta:rne VADR+VLEN-256,x+
	eli VLEN>256
	m@init
	eif

.ifdef psptr
	mwa #PROGRAMSTACK psptr
.fi

	ldx #$00					; X = 0
	stx bp						; BP = 0

	stx audctl					; reset POKEY
	stx audctl+$10
	lda #3
	sta skctl
	sta skctl+$10

	dex						; X = 255

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	jmp l_0022

; ------------------------------------------------------------

.local	SYSTEM						; UNIT

.local	FILLBYTE					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER | INLINE
.local	@03018000001810000300000

	.MACRO m@INLINE

; -------------------  ASM Block 00000029  -------------------

	jsr @fill

	.ENDM

; ------------------------------------------------------------

A	= :EDX
COUNT	= :ECX
VALUE	= :EAX

@exit
.endl
.endl							; overload

.local	PAUSE						; PROCEDURE | ASSEMBLER | OVERLOAD
.local	@00

; -------------------  ASM Block 00000039  -------------------

	bit VCOUNT
	bmi *-3
	bit VCOUNT
	bpl *-3

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	RANDOMIZE					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000041  -------------------


  mva $d20a RndSeed
  mva #$00  RndSeed+1


@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------
; ------------------------------------------------------------
@UnitInit

; -------------------  ASM Block 00000056  -------------------

	.ifdef @CmdLine

	ldx #$0F
	mva:rpl $340,x IOCB@COPY,x-
	rts

IOCB@COPY	:16 brk
	eif


	rts

; ------------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $04
__PORTB_BANKS	= $0101
MGTIA	= $00
MVBXE	= $80
VBXE_XDLADR	= $00
VBXE_BCBTMP	= $E0
VBXE_BCBADR	= $0100
VBXE_MAPADR	= $1000
VBXE_CHBASE	= $1000
VBXE_OVRADR	= $5000
VBXE_WINDOW	= $B000
IDLI	= $00
IVBL	= $01
IVBLD	= $01
IVBLI	= $02
ITIM1	= $03
ITIM2	= $04
ITIM4	= $05
CH_DELCHR	= $FE
CH_ENTER	= $9B
CH_ESC	= $1B
CH_CURS_UP	= $1C
CH_CURS_DOWN	= $1D
CH_CURS_LEFT	= $1E
CH_CURS_RIGHT	= $1F
CH_TAB	= $7F
CH_EOL	= $9B
CH_CLR	= $7D
CH_BELL	= $FD
CH_DEL	= $7E
CH_DELLINE	= $9C
CH_INSLINE	= $9D
PAL_PMCOLOR0	= $00
PAL_PMCOLOR1	= $01
PAL_PMCOLOR2	= $02
PAL_PMCOLOR3	= $03
PAL_COLOR0	= $04
PAL_COLOR1	= $05
PAL_COLOR2	= $06
PAL_COLOR3	= $07
PAL_COLBAK	= $08
COLOR_BLACK	= $00
COLOR_WHITE	= $0E
COLOR_RED	= $32
COLOR_CYAN	= $96
COLOR_VIOLET	= $68
COLOR_GREEN	= $C4
COLOR_BLUE	= $74
COLOR_YELLOW	= $EE
COLOR_ORANGE	= $28
COLOR_BROWN	= $E4
COLOR_LIGHTRED	= $3C
COLOR_GRAY1	= $04
COLOR_GRAY2	= $06
COLOR_GRAY3	= $0A
COLOR_LIGHTGREEN	= $CC
COLOR_LIGHTBLUE	= $7C
FMOPENREAD	= $04
FMOPENWRITE	= $08
FMOPENAPPEND	= $09
FMOPENREADWRITE	= $0C
DATESEPARATOR	= DATAORIGIN+$0000
RND	= $D20A
adr.PALETTE	= $02C0
.var PALETTE	= adr.PALETTE .word
adr.HPALETTE	= $D012
.var HPALETTE	= adr.HPALETTE .word
FILEMODE	= DATAORIGIN+$0001
GRAPHMODE	= DATAORIGIN+$0002
IORESULT	= DATAORIGIN+$0003
EOLN	= DATAORIGIN+$0004
SCREENWIDTH	= DATAORIGIN+$0005
SCREENHEIGHT	= DATAORIGIN+$0007
adr.MEM	= $00
.var MEM	= adr.MEM .word
RNDSEED	= DATAORIGIN+$0009

.endl							; UNIT SYSTEM

; ------------------------------------------------------------

.local	ATARI						; UNIT

; ------------------------------------------------------------

DL_BLANK1	= $00
DL_BLANK2	= $10
DL_BLANK3	= $20
DL_BLANK4	= $30
DL_BLANK5	= $40
DL_BLANK6	= $50
DL_BLANK7	= $60
DL_BLANK8	= $70
DL_DLI	= $80
DL_LMS	= $40
DL_VSCROLL	= $20
DL_HSCROLL	= $10
DL_JMP	= $01
DL_JVB	= $41
DL_MODE_2	= $02
DL_MODE_3	= $03
DL_MODE_4	= $04
DL_MODE_5	= $05
DL_MODE_E	= $0E
DL_MODE_F	= $0F
IRQENS	= $10
RTCLOK	= $12
RTCLOK1	= $12
RTCLOK2	= $13
RTCLOK3	= $14
ATRACT	= $4D
LMARGIN	= $52
RMARGIN	= $53
ROWCRS	= $54
COLCRS	= $55
DINDEX	= $57
SAVMSC	= $58
PALNTS	= $62
RAMTOP	= $6A
VDSLST	= $0200
SDLSTL	= $0230
TXTROW	= $0290
TXTCOL	= $0291
TINDEX	= $0293
TXTMSC	= $0294
SDMCTL	= $022F
GPRIOR	= $026F
CRSINH	= $02F0
CHACT	= $02F3
CHBAS	= $02F4
CH	= $02FC
FILDAT	= $02FD
PCOLR0	= $02C0
PCOLR1	= $02C1
PCOLR2	= $02C2
PCOLR3	= $02C3
COLOR0	= $02C4
COLOR1	= $02C5
COLOR2	= $02C6
COLOR3	= $02C7
COLOR4	= $02C8
COLBAKS	= $02C8
HPOSP0	= $D000
HPOSP1	= $D001
HPOSP2	= $D002
HPOSP3	= $D003
HPOSM0	= $D004
HPOSM1	= $D005
HPOSM2	= $D006
HPOSM3	= $D007
SIZEP0	= $D008
SIZEP1	= $D009
SIZEP2	= $D00A
SIZEP3	= $D00B
SIZEM	= $D00C
GRAFP0	= $D00D
GRAFP1	= $D00E
GRAFP2	= $D00F
GRAFP3	= $D010
GRAFM	= $D011
P0PF	= $D004
PAL	= $D014
TRIG3	= $D013
COLPM0	= $D012
COLPM1	= $D013
COLPM2	= $D014
COLPM3	= $D015
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBAK	= $D01A
COLBK	= $D01A
PRIOR	= $D01B
GRACTL	= $D01D
PMCNTL	= $D01D
HITCLR	= $D01E
CONSOL	= $D01F
AUDF1	= $D200
AUDC1	= $D201
AUDF2	= $D202
AUDC2	= $D203
AUDF3	= $D204
AUDC3	= $D205
AUDF4	= $D206
AUDC4	= $D207
AUDCTL	= $D208
KBCODE	= $D209
IRQEN	= $D20E
SKSTAT	= $D20F
PORTA	= $D300
PORTB	= $D301
PACTL	= $D302
DMACTL	= $D400
CHACTL	= $D401
DLISTL	= $D402
HSCROL	= $D404
VSCROL	= $D405
PMBASE	= $D407
CHBASE	= $D409
WSYNC	= $D40A
VCOUNT	= $D40B
PENH	= $D40C
PENV	= $D40D
NMIEN	= $D40E
NMIVEC	= $FFFA
RESETVEC	= $FFFC
IRQVEC	= $FFFE

.endl							; UNIT ATARI

; ------------------------------------------------------------

.local	CRT						; UNIT

; ------------------------------------------------------------

TEXTATTR	= DATAORIGIN+$000B
CONSOL	= $D01F
CN_START_SELECT_OPTION	= $00
CN_SELECT_OPTION	= $01
CN_START_OPTION	= $02
CN_OPTION	= $03
CN_START_SELECT	= $04
CN_SELECT	= $05
CN_START	= $06
CN_NONE	= $07
BLACK	= $00
WHITE	= $0F
RED	= $26
CYAN	= $AC
PURPLE	= $48
GREEN	= $B6
BLUE	= $86
YELLOW	= $DC
ORANGE	= $18
BROWN	= $F4
LIGHT_RED	= $2A
DARK_GREY	= $04
GREY	= $08
LIGHT_GREEN	= $BC
LIGHT_BLUE	= $9A
LIGHT_GREY	= $0C
BW40	= $00
CO40	= $01
BW80	= $02
CO80	= $03
MONO	= $07
C40	= $01
C80	= $03
BLINK	= $80

.endl							; UNIT CRT

; ------------------------------------------------------------

.local	TYPES						; UNIT

; ------------------------------------------------------------

.endl							; UNIT TYPES

; ------------------------------------------------------------

.local	GRAPH						; UNIT

; ------------------------------------------------------------

CURRENTDRIVER	= $80
DETECT	= $00
CGA	= $01
MCGA	= $02
EGA	= $03
EGA64	= $04
EGAMONO	= $05
LOWRES	= $06
HERCMONO	= $07
VGA	= $09
VESA	= $0A
D1BIT	= $0B
D2BIT	= $0C
D4BIT	= $0D
D6BIT	= $0E
D8BIT	= $0F
D12BIT	= $10
M640X400	= $18
M640X480	= $18
GROK	= $01
GRNOINITGRAPH	= $FF
GRNOTDETECTED	= $FE
GRFILENOTFOUND	= $FD
GRINVALIDDRIVER	= $FC
GRNOLOADMEM	= $FB
GRNOSCANMEM	= $FA
GRNOFLOODMEM	= $F9
GRFONTNOTFOUND	= $F8
GRNOFONTMEM	= $F7
GRINVALIDMODE	= $F6
GRERROR	= $F5
GRIOERROR	= $F4
GRINVALIDFONT	= $F3
GRINVALIDFONTNUM	= $F2
GRINVALIDVERSION	= $EE
CGAC0	= $00
CGAC1	= $01
CGAC2	= $02
CGAC3	= $03
CGAHI	= $04
MCGAC0	= $00
MCGAC1	= $01
MCGAC2	= $02
MCGAC3	= $03
MCGAMED	= $04
MCGAHI	= $05
EGALO	= $00
EGAHI	= $01
EGA64LO	= $00
EGA64HI	= $01
EGAMONOHI	= $03
VGALO	= $0A
VGAMED	= $1F
VGAHI	= $18
GRAPHRESULT	= DATAORIGIN+$000C
GETCOLOR	= DATAORIGIN+$000D
VIDEORAM	= DATAORIGIN+$000E
adr.LASTARCCOORDS	= DATAORIGIN+$0010	; [12] RECORD
.var LASTARCCOORDS	= adr.LASTARCCOORDS .word
LASTARCCOORDS.X	= DATAORIGIN+$0010
LASTARCCOORDS.Y	= DATAORIGIN+$0012
LASTARCCOORDS.XSTART	= DATAORIGIN+$0014
LASTARCCOORDS.YSTART	= DATAORIGIN+$0016
LASTARCCOORDS.XEND	= DATAORIGIN+$0018
LASTARCCOORDS.YEND	= DATAORIGIN+$001A
WIN_LEFT	= DATAORIGIN+$001C
WIN_RIGHT	= DATAORIGIN+$001E
WIN_TOP	= DATAORIGIN+$0020
WIN_BOTTOM	= DATAORIGIN+$0022
SCANLINE_WIDTH	= DATAORIGIN+$0024
CURRENTX	= DATAORIGIN+$0025
CURRENTY	= DATAORIGIN+$0027

.endl							; UNIT GRAPH

; ------------------------------------------------------------

.local	VBXE						; UNIT

.local	SETTOPBORDER					; PROCEDURE | ASSEMBLER | REGISTER
	sta A

; -------------------  ASM Block 00000096  -------------------

	fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000

	lda a
	sub #1

	ldy #s@xdl.RPTL_
	sta MAIN.SYSTEM.VBXE_WINDOW,y

	fxs FX_MEMS #$00

; ------------------------------------------------------------

A	= :EDX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SETXDLHEIGHT					; PROCEDURE | ASSEMBLER | REGISTER
	sta A

; -------------------  ASM Block 00000097  -------------------

	fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000

	lda a
	sub #1

	ldy #s@xdl.RPTL
	sta MAIN.SYSTEM.VBXE_WINDOW,y

	fxs FX_MEMS #$00

; ------------------------------------------------------------

A	= :EDX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TVBXEMEMORYSTREAM.CLEAR				; PROCEDURE
	sta TVBXEMEMORYSTREAM
	sty TVBXEMEMORYSTREAM+1
	sta POSITION
	sty POSITION+1
	add #4
	scc
	iny
	sta SIZE
	sty SIZE+1

; optimize OK (vbxe_memorystream.inc), line = 241

	mwy POSITION :bp2
	ldy #$00
	lda (:bp2),y
	sta ADR
	iny
	lda (:bp2),y
	sta ADR+1
	iny
	lda (:bp2),y
	sta ADR+2
	iny
	lda (:bp2),y
	sta ADR+3

; optimize OK (vbxe_memorystream.inc), line = 242

	mwy SIZE :bp2
	ldy #$00
	lda (:bp2),y
	sta SIZ
	iny
	lda (:bp2),y
	sta SIZ+1
	iny
	lda (:bp2),y
	sta SIZ+2
	iny
	lda (:bp2),y
	sta SIZ+3

; -------------------  ASM Block 00000110  -------------------

	txa:pha

	mva adr _adr
	mva adr+1 _adr+1
	mva adr+2 _adr+2

	fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000

loop	cpw _adr+1 siz+1
	bcs skp

	ldy #20
	mva:rpl bltClr,y MAIN.SYSTEM.VBXE_WINDOW+MAIN.SYSTEM.VBXE_BCBTMP,y-

	fxs FX_BL_ADR0 #MAIN.SYSTEM.VBXE_BCBTMP	; program blittera od adresu MAIN.SYSTEM.VBXE_BCBTMP
	fxs FX_BL_ADR1 #$00			; zaraz za programem VBXE Display List
	fxsa FX_BL_ADR2

	fxs FX_BLITTER_START #$01	; !!! start gdy 1 !!!

wait	fxla FX_BLITTER_BUSY
	bne wait

	lda #$00
	sta _adr
	inw _adr+1

	jmp loop

skp	fxs FX_MEMS #$00		; disable VBXE bank

	jmp stop

bltClr	.long 0x00	; source address
	.word 0x00	; source step y
	.byte 0x00	; source step x
_adr	.long 0x00	; destination address
	.word 0x0100	; destination step y
	.byte 0x01	; destination step x
_siz	.word 0xff	; width
	.byte 0x00	; height
	dta 0x00	; and mask (and mask equal to 0, memory will be filled with xor mask)
	dta 0x00	; xor mask
	dta 0x00	; collision and mask
	dta 0x00	; zoom
	dta 0x00	; pattern feature
	dta 0x00	; control

stop	pla:tax

; optimize OK (vbxe_memorystream.inc), line = 294

	mwy POSITION :bp2
	ldy #$00
	tya
	sta (:bp2),y
	iny
	sta (:bp2),y
	iny
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (vbxe_memorystream.inc), line = 295

	mwy SIZE :bp2
	ldy #$00
	sta (:bp2),y
	iny
	sta (:bp2),y
	iny
	lda #$08
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; ------------------------------------------------------------

TVBXEMEMORYSTREAM	= DATAORIGIN+$0065
POSITION	= DATAORIGIN+$0067
SIZE	= DATAORIGIN+$0069
ADR	= DATAORIGIN+$006B
SIZ	= DATAORIGIN+$006F

@VarData	= TVBXEMEMORYSTREAM
@VarDataSize	= 14

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	COLORMAPOFF					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000119  -------------------

	@setxdl #e@xdl.mapoff

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SETHORIZONTALRES				; PROCEDURE | OVERLOAD
.local	@0201810000180000

; optimize OK (VBXE), line = 643

	lda A
	sta SYSTEM.GRAPHMODE

; optimize OK (VBXE), line = 645

	lda #$C0
	sta SYSTEM.SCREENHEIGHT
	lda #$00
	sta SYSTEM.SCREENHEIGHT+1

; optimize OK (VBXE), line = 647

	lda A
	sta @CASETMP_0005
	cmp #$0A
	jne l_0168
@

; optimize OK (VBXE), line = 648

	lda #$A0
	sta SYSTEM.SCREENWIDTH
	lda #$00
	sta SYSTEM.SCREENWIDTH+1
	lda #$01
	sta A
	jmp a_0005
l_0168
	cmp #$1F
	jne l_0177

; optimize OK (VBXE), line = 649

	lda #$40
	sta SYSTEM.SCREENWIDTH
	lda #$01
	sta SYSTEM.SCREENWIDTH+1
	lda #$02
	sta A
	jmp a_0005
l_0177
	cmp #$18
	jne l_0186

; optimize OK (VBXE), line = 650

	lda #$80
	sta SYSTEM.SCREENWIDTH
	lda #$02
	sta SYSTEM.SCREENWIDTH+1
	lda #$03
	sta A
	jmp a_0005
l_0186

; optimize OK (VBXE), line = 654

	lda #$50
	sta SYSTEM.SCREENWIDTH
	lda #$00
	sta SYSTEM.SCREENWIDTH+1

; optimize OK (VBXE), line = 655

	lda #$18
	sta SYSTEM.SCREENHEIGHT
	lda #$00
	sta SYSTEM.SCREENHEIGHT+1

; optimize OK (VBXE), line = 656

	lda #$02
	sta A
a_0005

; -------------------  ASM Block 00000120  -------------------

	txa:pha

	lda MAIN.SYSTEM.ScreenWidth
	ldx MAIN.SYSTEM.ScreenWidth+1

	ldy MAIN.SYSTEM.ScreenHeight

	@SCREENSIZE

	@setxdl a

	fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000

	ldy #s@xdl.ovstep

	lda s
	sta MAIN.SYSTEM.VBXE_WINDOW,y

	lda s+1
	sta MAIN.SYSTEM.VBXE_WINDOW+1,y

	fxs FX_MEMS #$00

	pla:tax

; ------------------------------------------------------------

A	= DATAORIGIN+$0073
S	= DATAORIGIN+$0074
@CASETMP_0005	= DATAORIGIN+$0076

@VarData	= A
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	SETHORIZONTALRES				; PROCEDURE | OVERLOAD
.local	@010180000
	sta A

; optimize OK (VBXE), line = 698

	sta SETHORIZONTALRES.@0201810000180000.A
	lda #$40
	sta SETHORIZONTALRES.@0201810000180000.S
	lda #$01
	sta SETHORIZONTALRES.@0201810000180000.S+1
	jsr SETHORIZONTALRES.@0201810000180000

; ------------------------------------------------------------

A	= DATAORIGIN+$0077

@VarData	= A
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	BLITTERBUSY					; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000121  -------------------

	ldy #FX_BLITTER_BUSY
	lda (fxptr),y
	sta Result

@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$0078

	rts						; ret
.endl

.local	RUNBCB						; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000122  -------------------

	fxs	FX_BL_ADR0	a
	lda	a+1
	and	#$0f
	fxsa	FX_BL_ADR1
	fxs	FX_BL_ADR2	#$00

	fxs	FX_BLITTER_START #$01		; !!! start gdy 1 !!!

;wait	fxla	FX_BLITTER_BUSY
;	bne	wait

; ------------------------------------------------------------

A	= DATAORIGIN+$0079
A.SRC_ADR	= DATAORIGIN+$0000
A.SRC_ADR.BYTE0	= DATAORIGIN+$0000
A.SRC_ADR.BYTE1	= DATAORIGIN+$0001
A.SRC_ADR.BYTE2	= DATAORIGIN+$0002
A.SRC_STEP_Y	= DATAORIGIN+$0003
A.SRC_STEP_X	= DATAORIGIN+$0005
A.DST_ADR	= DATAORIGIN+$0006
A.DST_ADR.BYTE0	= DATAORIGIN+$0006
A.DST_ADR.BYTE1	= DATAORIGIN+$0007
A.DST_ADR.BYTE2	= DATAORIGIN+$0008
A.DST_STEP_Y	= DATAORIGIN+$0009
A.DST_STEP_X	= DATAORIGIN+$000B
A.BLT_WIDTH	= DATAORIGIN+$000C
A.BLT_HEIGHT	= DATAORIGIN+$000E
A.BLT_AND_MASK	= DATAORIGIN+$000F
A.BLT_XOR_MASK	= DATAORIGIN+$0010
A.BLT_COLLISION_MASK	= DATAORIGIN+$0011
A.BLT_ZOOM	= DATAORIGIN+$0012
A.PATTERN_FEATURE	= DATAORIGIN+$0013
A.BLT_CONTROL	= DATAORIGIN+$0014

@VarData	= A
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SETOVERLAYADDRESS				; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000125  -------------------

	fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000

	lda a
	sta MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW+6
	lda a+1
	sta MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW+7
	lda a+2
	sta MAIN.SYSTEM.VBXE_XDLADR+MAIN.SYSTEM.VBXE_WINDOW+8

	fxs FX_MEMS #$00

; ------------------------------------------------------------

A	= DATAORIGIN+$007D

@VarData	= A
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	VBXECONTROL					; PROCEDURE | ASSEMBLER
	sta A

; -------------------  ASM Block 00000126  -------------------

	fxs FX_VIDEO_CONTROL a

; ------------------------------------------------------------

A	= DATAORIGIN+$0081

@VarData	= A
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------
; ------------------------------------------------------------
@UnitInit

; -------------------  ASM Block 00000134  -------------------

	txa:pha

	jsr @vbxe_detect
	bcc ok

	ldx #MAIN.GRAPH.grNoInitGraph
	bne status

ok	jsr @vbxe_init

	ldx #MAIN.GRAPH.grOK
status	stx MAIN.GRAPH.GraphResult

	pla:tax

	rts

; ------------------------------------------------------------

VC_XDL	= $01
VC_XCOLOR	= $02
VC_NO_TRANS	= $04
VC_TRANS15	= $08
TCBLACK	= $00
TCRED	= $01
TCGREEN	= $02
TCYELLOW	= $03
TCBLUE	= $04
TCMAGENTA	= $05
TCCYAN	= $06
TCWHITE	= $07
TCBRIGHTBLACK	= $08
TCBRIGHTRED	= $09
TCBRIGHTGREEN	= $0A
TCBRIGHTYELLOW	= $0B
TCBRIGHTBLUE	= $0C
TCBRIGHTMAGENTA	= $0D
TCBRIGHTCYAN	= $0E
TCBRIGHTWHITE	= $0F
TBBLACK	= $80
TBRED	= $90
TBGREEN	= $A0
TBYELLOW	= $B0
TBBLUE	= $C0
TBMAGENTA	= $D0
TBCYAN	= $E0
TBWHITE	= $F0
adr.VRAM	= DATAORIGIN+$0035	; [8] OBJECT
.var VRAM	= adr.VRAM .word
VRAM.POSITION	= DATAORIGIN+$0035
VRAM.SIZE	= DATAORIGIN+$0039
SCROLLBACK_FILL	= $63
COLORMAPCONTROL = @VBXE_CMAP.CONFIG
adr.SCROLLBACK_BUFFER	= $0400
.var SCROLLBACK_BUFFER	= adr.SCROLLBACK_BUFFER .word
FILDAT	= $02FD
ROWCRS	= $54
COLCRS	= $55
CRSADR	= $68

.endl							; UNIT VBXE

; ------------------------------------------------------------

.local	JOYSTICK					; UNIT

; ------------------------------------------------------------

JOY_NONE	= $0F
JOY_UP	= $0E
JOY_DOWN	= $0D
JOY_LEFT	= $0B
JOY_LEFT_UP	= $0A
JOY_LEFT_DOWN	= $09
JOY_RIGHT	= $07
JOY_RIGHT_UP	= $06
JOY_RIGHT_DOWN	= $05
JOY_1	= $0278
JOY_2	= $0279
adr.STICK	= $0278
.var STICK	= adr.STICK .word
STICK0	= $0278
STICK1	= $0279
adr.STRIG	= $0284
.var STRIG	= adr.STRIG .word
STRIG0	= $0284
STRIG1	= $0285
adr.PADDL	= $0270
.var PADDL	= adr.PADDL .word
PADDL0	= $0270
PADDL1	= $0271
PADDL2	= $0272
PADDL3	= $0273
PADDL4	= $0274
PADDL5	= $0275
PADDL6	= $0276
PADDL7	= $0277
adr.PTRIG	= $027C
.var PTRIG	= adr.PTRIG .word
PTRIG0	= $027C
PTRIG1	= $027D
PTRIG2	= $027E
PTRIG3	= $027F
PTRIG4	= $0280
PTRIG5	= $0281
PTRIG6	= $0282
PTRIG7	= $0283
TRIG0	= $D010
TRIG1	= $D011
POT0	= $D200
ALLPOT	= $D208
POTGO	= $D20B

.endl							; UNIT JOYSTICK

; ------------------------------------------------------------

.local	MISC						; UNIT

.local	DETECTANTIC					; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000137  -------------------


// ANTIC PAL Test for Atari 8-bits
// (C) 2019 Guillermo Fuenzalida

antic_loop1
	lda vcount
	cmp #100
	bcc antic_loop1		// wait till scanline 200
	sta scanline
antic_loop2
	lda vcount
	cmp #10
	bmi antic_loop2_fin
	cmp scanline
	bmi antic_loop2
	sta scanline
	bpl antic_loop2

antic_loop2_fin
	ldy #$00
	lda #0
scanline equ *-1
	cmp #135
	bmi ntsc
	iny
ntsc
	sty Result


@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$0082

	rts						; ret
.endl

; ------------------------------------------------------------

adr.BANKS	= $0101
.var BANKS	= adr.BANKS .word
DETECTOS	= $FFF7

.endl							; UNIT MISC

; ------------------------------------------------------------

.local	XSFX						; UNIT

.local	SFX_CHANNEL_OFF					; PROCEDURE | ASSEMBLER | KEEP

; -------------------  ASM Block 00000147  -------------------

	txa
	asl @
	tay
	lda #$ff
	sta adr.SFX_CNT,x
	lda #$00
	sta adr.SFX_NO,x
	sta adr.SFX_TIME,x
	sta adr.SFX_REPEAT,x
	sta adr.SFX_RTS,x
	sta VPOKEY,y
	sta VPOKEY+1,y

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SFX_PROCEED					; PROCEDURE | ASSEMBLER | KEEP

; -------------------  ASM Block 00000148  -------------------


; ================================================ LEVEL 2
; === SFX ENGINE ====
;xSFX_ENGINE - jump here 1 per frame at least
;
;xSFX_ENGINE+3  in:  A=sfx, X=channel, C=1 (force)
;                    A=sfx, C=0 (find free channel)
;               out: C=1 no free channel
;                    C=0 ok
;
;xSFX_ENGINE+6  in:  X=channel - will immediately terminate SFX on the specified channel
; ===
;
; Command:
;
;1. TIME,AUDF,AUDC          ; graj TIME ilość ramek, zapisz rejestry AUDF, AUDC
;2. REPF,TIME,COUNT,AUDC    ; powtórz COUNT razy: graj TIME ilosc ramek, zainicjuj AUDC, wpisuj AUDF COUNT razy
;3. REPC,TIME,COUNT,AUDF    ; powtórz COUNT razy: graj TIME ilosc ramek, zainicjuj AUDF, wpisuj AUDC COUNT razy
;4. LOOP                    ; powtórz ten sam dźwięk od komendy na pozycji loop
;5. RTS                     ; koniec opisu dźwięku
;6. JSR nnnnn               ; wywołaj SFX nr. nn i po jego zakończeniu wróć kontynuuj odtwarzanie obecnego
;7. JMP nnnnn               ; skocz do SFX nr.
;
; Code:
;
; TIME = $01..$0f
; REPF = $c0
; REPC = $80
; LOOP = $00,NUM
; RTS  = $00,$ff
; JSR  = $a0,SFX
; JMP  = $e0,SFX


xSFX_ENGINE     jmp xSFX_PROCEED         ; xSFX_ENGINE
;xSFX_START      jmp SFX_INSERT           ; xSFX_ENGINE+3
;xSFX_STOP       jmp SFX_CHANNEL_OFF      ; xSFX_ENGINE+6


SFX_ENDRTS	jsr GET_BYTE

		tay
                dey
                cmp #$ff
                beq SFX_RTSEND
                jmp SFX_RELOAD

SFX_RTSEND      lda adr.SFX_RTS,x
                bne SFX_DORTS
                jsr SFX_CHANNEL_OFF
                jmp SFX_NXTCH

SFX_DORTS       pha
                lda #$00
                sta adr.SFX_RTS,x
                lda adr.SFX_RCNT,x
                sta adr.SFX_CNT,x
                jmp SFX_DORTSF

SFX_REP         dec adr.SFX_REPEAT,x
                lda adr.SFX_RTIME,x
                sta adr.SFX_TIME,x
                lda #$00
                lda adr.SFX_FLAG,x
                asl @
                bcs SFX_DF
                bcc SFX_DC

xSFX_PROCEED    ldx #3
SFX_CONTCH      lda adr.SFX_NO,x
                bne SFX_PROCED
SFX_NXTCH       dex
                bpl SFX_CONTCH
                rts

SFX_PROCED      ldy adr.SFX_TIME,x
                bne SFX_CONTTONE
SFX_CONTCHJ     tay
                lda adr.SFX_ADR_TAB-1,y
		beq SFX_NXTCH

                sta SFXZP+1

                lda adr.SFX_ADR_TAB-2,y
                sta SFXZP

                ldy adr.SFX_CNT,x
                lda adr.SFX_REPEAT,x
                bne SFX_REP
SFX_RELOAD
		jsr GET_BYTE

                beq SFX_ENDRTS
SFX_TOKEN       asl @
                bcc SFX_TIM
                asl @
                ror adr.SFX_FLAG,x
                asl @
                bcs SFX_JUMP

		jsr GET_BYTE

                sta adr.SFX_RTIME,x

		jsr GET_BYTE

                sta adr.SFX_REPEAT,x
                lda adr.SFX_FLAG,x
                asl @

		jsr GET_BYTE

                bcs SFX_C0C
                sta adr.SFX_AUDF,x
                bcc SFX_REP
SFX_C0C         sta adr.SFX_AUDC,x
                bcs SFX_REP

SFX_TIM         lsr @
                sta adr.SFX_TIME,x
SFX_DF
		jsr GET_BYTE

                sta adr.SFX_AUDF,x
                bcs SFX_N3
SFX_DC
		jsr GET_BYTE

                sta adr.SFX_AUDC,x
SFX_N3          tya
                sta adr.SFX_CNT,x
SFX_CONTTONE    txa
                asl @
                tay
                lda adr.SFX_AUDF,x
                sta VPOKEY,y
                lda adr.SFX_AUDC,x
                sta VPOKEY+1,y
                dec adr.SFX_TIME,x
                jmp SFX_NXTCH

SFX_JUMP        lsr @
                lsr @
                pha
                lda adr.SFX_FLAG,x
                bmi SFX_JMP
                lda adr.SFX_NO,x
                sta adr.SFX_RTS,x
                tya
                sta adr.SFX_RCNT,x
SFX_JMP         lda #$ff
                sta adr.SFX_CNT,x
SFX_DORTSF      pla
                sta adr.SFX_NO,x
                jmp SFX_CONTCHJ


GET_BYTE	iny
		lda SFXZP: $1000,y
		rts

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TSFX.INIT					; PROCEDURE | ASSEMBLER | OVERLOAD
.local	@010180000
	sta TSFX
	sty TSFX+1

; -------------------  ASM Block 00000149  -------------------

		txa:pha

		lda sfx

                ldx #$03
SFX_FIND        ldy adr.SFX_NO,x
                beq SFX_SETNO
                dex
                bpl SFX_FIND
                sec
                bcs quit

SFX_SETNO       asl @
                sta adr.SFX_NO,x
                clc

quit		pla:tax

; ------------------------------------------------------------

TSFX	= DATAORIGIN+$00EC
SFX	= DATAORIGIN+$00EE

@VarData	= TSFX
@VarDataSize	= 3

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	TSFX.PLAY					; PROCEDURE | ASSEMBLER
	sta TSFX
	sty TSFX+1

; -------------------  ASM Block 00000151  -------------------

	txa:pha

	asl ntsc		; =0 PAL, =4 NTSC
	bcc skp

	lda #%00000100
	sta ntsc

	bne quit
skp
	jsr SFX_PROCEED

quit	pla:tax

; ------------------------------------------------------------

TSFX	= DATAORIGIN+$00EF

@VarData	= TSFX
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TSFX.CLEAR					; PROCEDURE | ASSEMBLER
	sta TSFX
	sty TSFX+1

; -------------------  ASM Block 00000152  -------------------

	ldy #$3f
	lda #0
	sta:rpl adr.SFX_ADR_TAB,y-

; ------------------------------------------------------------

TSFX	= DATAORIGIN+$00F1

@VarData	= TSFX
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TSFX.ADD					; PROCEDURE | ASSEMBLER | OVERLOAD
.local	@010188000
	sta TSFX
	sty TSFX+1

; -------------------  ASM Block 00000153  -------------------

	ldy #2
loop	lda adr.SFX_ADR_TAB-1,y
	beq empty

	iny
	iny
	cpy #66
	bne loop

	sec
	jmp @exit

empty	lda asfx
	sta adr.SFX_ADR_TAB-2,y
	lda asfx+1
	sta adr.SFX_ADR_TAB-1,y

	clc

; ------------------------------------------------------------

TSFX	= DATAORIGIN+$00F3
ASFX	= DATAORIGIN+$00F5

@VarData	= TSFX
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

; ------------------------------------------------------------
; ------------------------------------------------------------
@UnitInit

; optimize FAIL ('MISC.DETECTANTIC', XSFX), line = 417

	jsr MISC.DETECTANTIC
	lda MISC.DETECTANTIC.RESULT
	jeq l_01C4

; optimize OK (XSFX), line = 418

	lda #$00
	jmp l_01D2
l_01C4

; optimize OK (XSFX), line = 420

	lda #$04
l_01D2
	sta NTSC

	rts

; ------------------------------------------------------------

VPOKEY	= $D200
adr.SFX_CNT	= [DATAORIGIN+$0083] .array [4]
.var SFX_CNT	= adr.SFX_CNT .word
adr.SFX_NO	= [DATAORIGIN+$0087] .array [4]
.var SFX_NO	= adr.SFX_NO .word
adr.SFX_TIME	= [DATAORIGIN+$008B] .array [4]
.var SFX_TIME	= adr.SFX_TIME .word
adr.SFX_AUDC	= [DATAORIGIN+$008F] .array [4]
.var SFX_AUDC	= adr.SFX_AUDC .word
adr.SFX_AUDF	= [DATAORIGIN+$0093] .array [4]
.var SFX_AUDF	= adr.SFX_AUDF .word
adr.SFX_FLAG	= [DATAORIGIN+$0097] .array [4]
.var SFX_FLAG	= adr.SFX_FLAG .word
adr.SFX_REPEAT	= [DATAORIGIN+$009B] .array [4]
.var SFX_REPEAT	= adr.SFX_REPEAT .word
adr.SFX_RTIME	= [DATAORIGIN+$009F] .array [4]
.var SFX_RTIME	= adr.SFX_RTIME .word
adr.SFX_RTS	= [DATAORIGIN+$00A3] .array [4]
.var SFX_RTS	= adr.SFX_RTS .word
adr.SFX_RCNT	= [DATAORIGIN+$00A7] .array [4]
.var SFX_RCNT	= adr.SFX_RCNT .word
adr.SFX_ADR_TAB	= [DATAORIGIN+$00AB] .array [32] .word
.var SFX_ADR_TAB	= adr.SFX_ADR_TAB .word
NTSC	= DATAORIGIN+$00EB

.endl							; UNIT XSFX

.local	NMI						; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000156  -------------------


 sta nmist

 sta regA
 stx regX
 sty regY

	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.PLAY


 lda regA: #$00
 ldx regX: #$00
 ldy regY: #$00


	rti						; ret
.endl

.local	START_LEVEL					; PROCEDURE

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	RAND						; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000157  -------------------

	ldy range+1
	bpl @+

	lda #0
	sub range
	sta range
	lda #0
	sbc range+1
	sta range+1
@
	lda random
	adc seed_l: #$00
	sta Result
	sta seed_l
	lda random
	adc seed_h: #$00
	sta seed_h
	and #%00111000
	lsr @
	lsr @
	lsr @
	sta Result+1

loop	cpw Result range
	bcc @+

	lsr Result+1
	ror Result

	jmp loop
@
	tya
	bpl @exit

	lda #0
	sub Result
	sta Result
	lda #0
	sbc Result+1
	sta Result+1

@exit

; ------------------------------------------------------------

RANGE	= DATAORIGIN+$01DA
RESULT	= DATAORIGIN+$01DC

@VarData	= RANGE
@VarDataSize	= 2

	rts						; ret
.endl

.local	MOD90						; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000158  -------------------

    ldy a+1
    bpl @+

    lda #0
    sub a
    sta a
    lda #0
    sbc a+1
    tay
@
    LDA adr.Mod90Table,Y	; tablica: (X*256) mod 90
    CLC
    ADC a			; dodaj młodszy bajt
    sta Result
    lda #0
    adc #0
    sta Result+1

    cpw Result #90
    BCC done
    SBW Result #90

    cpw Result #90
    BCC done
    SBW Result #90

    cpw Result #90
    BCC done
    SBW Result #90

done

    lda a+1
    bpl @exit

    lda #0
    sub Result
    sta Result
    lda #0
    sbc Result+1
    sta Result+1

@exit

; ------------------------------------------------------------

A	= DATAORIGIN+$01DE
RESULT	= DATAORIGIN+$01E0

@VarData	= A
@VarDataSize	= 2

	rts						; ret
.endl

.local	MOD360						; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000159  -------------------

    ldy a+1
    bpl @+

    lda #0
    sub a
    sta a
    lda #0
    sbc a+1
    tay
@
    LDA adr.Mod360Table,Y	; tablica: (X*256) mod 360
    CLC
    ADC a			; dodaj młodszy bajt
    sta Result
    lda adr.Mod360Table+256,Y
    adc #0
    sta Result+1

    cpw Result #360
    BCC done
    SBW Result #360

    cpw Result #360
    BCC done
    SBW Result #360

    cpw Result #360
    BCC done
    SBW Result #360

done

    lda a+1
    bpl @exit

    lda #0
    sub Result
    sta Result
    lda #0
    sbc Result+1
    sta Result+1

@exit

; ------------------------------------------------------------

A	= DATAORIGIN+$01E2
RESULT	= DATAORIGIN+$01E4

@VarData	= A
@VarDataSize	= 2

	rts						; ret
.endl

.local	SINDEG						; FUNCTION

; optimize OK (arkanoid_vbxe.pas), line = 763

	lda A
	sta MOD360.A
	lda A+1
	sta MOD360.A+1
	jsr MOD360
	lda MOD360.RESULT
	sta A
	lda MOD360.RESULT+1
	sta A+1

; optimize OK (arkanoid_vbxe.pas), line = 765

	jpl l_01F8

; optimize OK (arkanoid_vbxe.pas), line = 766

	lda A
	add #$68
	sta A
	lda A+1
	adc #$01
	sta A+1
l_01F8

; optimize OK (arkanoid_vbxe.pas), line = 768

	lda A
	cmp #$5B
	lda A+1
	sbc #$00
	svc
	eor #$80
	jpl l_0215

; optimize OK (arkanoid_vbxe.pas), line = 769

	ldy A
	lda adr.SINTABLE,y
	sta RESULT
	lda adr.SINTABLE+90,y
	jmp l_0226
l_0215

; optimize OK (arkanoid_vbxe.pas), line = 770

	lda A
	cmp #$B5
	lda A+1
	sbc #$00
	svc
	eor #$80
	jpl l_0237

; optimize OK (arkanoid_vbxe.pas), line = 771

	lda #$B4
	sub A
	tay
	lda adr.SINTABLE,y
	sta RESULT
	lda adr.SINTABLE+90,y
	jmp l_024C
l_0237

; optimize OK (arkanoid_vbxe.pas), line = 772

	lda A
	cmp #$0F
	lda A+1
	sbc #$01
	svc
	eor #$80
	jpl l_025D

; optimize OK (arkanoid_vbxe.pas), line = 773

	ldy A
	lda #$00
	sub adr.SINTABLE-$B4,y
	sta RESULT
	lda #$00
	sbc adr.SINTABLE+90-$B4,y
	jmp l_0275
l_025D

; optimize OK (arkanoid_vbxe.pas), line = 775

	lda #$68
	sub A
	tay
	lda #$00
	sub adr.SINTABLE,y
	sta RESULT
	lda #$00
	sbc adr.SINTABLE+90,y
l_0226
l_024C
l_0275
	sta RESULT+1
@exit

; ------------------------------------------------------------

A	= DATAORIGIN+$01E6
RESULT	= DATAORIGIN+$01E8

@VarData	= A
@VarDataSize	= 2

	rts						; ret
.endl

.local	FASTSQRT					; FUNCTION

; optimize OK (arkanoid_vbxe.pas), line = 784

	lda I
	sta :STACKORIGIN+9
	lda I+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda I+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda I+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lsr :STACKORIGIN+STACKWIDTH*3+9
	ror :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta I
	lda :STACKORIGIN+STACKWIDTH+9
	sta I+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	add #$C0
	sta I+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc #$1F
	sta I+3

; optimize OK (arkanoid_vbxe.pas), line = 786

	lda I
	sta RESULT
	lda I+1
	sta RESULT+1
	lda I+2
	sta RESULT+2
	lda I+3
	sta RESULT+3
@exit

; ------------------------------------------------------------

X	= DATAORIGIN+$01EA
RESULT	= DATAORIGIN+$01EE
I	= DATAORIGIN+$01EA

@VarData	= X
@VarDataSize	= 4

	rts						; ret
.endl

.local	ATAN2						; FUNCTION | REGISTER

; optimize OK (arkanoid_vbxe.pas), line = 943

	lda X+1
	jpl l_02AC

; optimize OK (arkanoid_vbxe.pas), line = 944

	lda #$00
	sub X
	sta SX
	lda #$00
	sbc X+1
	jmp l_02BE
l_02AC

; optimize OK (arkanoid_vbxe.pas), line = 946

	lda X
	sta SX
	lda X+1
l_02BE
	sta SX+1

; optimize OK (arkanoid_vbxe.pas), line = 948

	lda Y+1
	jpl l_02D4

; optimize OK (arkanoid_vbxe.pas), line = 949

	lda #$00
	sub Y
	sta SY
	lda #$00
	sbc Y+1
	jmp l_02E6
l_02D4

; optimize OK (arkanoid_vbxe.pas), line = 951

	lda Y
	sta SY
	lda Y+1
l_02E6
	sta SY+1

; --- WhileProlog
	jmp l_02ED
l_02EE

; optimize OK (arkanoid_vbxe.pas), line = 956

	lsr SX+1
	ror SX

; optimize OK (arkanoid_vbxe.pas), line = 957

	lsr SY+1
	ror SY
l_02ED

; optimize OK (arkanoid_vbxe.pas), line = 954

	lda SX+1
	jne l_02EE
	lda SX
	jmi l_02EE
	lda SY+1
	cmp #$00
	bne @+
	lda SY
	cmp #$80
@
	jcs l_02EE

; optimize OK (arkanoid_vbxe.pas), line = 960

	lda X+1
	jpl l_0327

; optimize OK (arkanoid_vbxe.pas), line = 961

	lda #$00
	sub SX
	sta X
	lda #$00
	sbc SX+1
	jmp l_0339
l_0327

; optimize OK (arkanoid_vbxe.pas), line = 963

	lda SX
	sta X
	lda SX+1
l_0339
	sta X+1

; optimize OK (arkanoid_vbxe.pas), line = 966

	lda Y+1
	jpl l_034F

; optimize OK (arkanoid_vbxe.pas), line = 967

	lda #$00
	sub SY
	sta Y
	lda #$00
	sbc SY+1
	jmp l_0361
l_034F

; optimize OK (arkanoid_vbxe.pas), line = 969

	lda SY
	sta Y
	lda SY+1
l_0361
	sta Y+1

; -------------------  ASM Block 00000160  -------------------

	txa:pha

octant	= :TMP			// temporary zeropage variable

	lda #$00
	sta octant

atan2		clc
		lda x
		bpl @+

		eor #$ff
		sec
@
		tax
		rol octant

		clc
		lda y
		bpl @+

		sec
		eor #$ff
@
		tay
		rol octant

		lda adr.log2_tab,x
		sbc adr.log2_tab,y
		scc
		eor #$ff
		tax

		lda octant
		rol @
		and #%111
		tay

		lda adr.atan_tab,x
		eor adr.octant_adjust,y

		sta Result

	pla:tax

@exit

; ------------------------------------------------------------

Y	= :EDX
X	= :ECX
RESULT	= :STACKORIGIN-4
adr.OCTANT_ADJUST	= CODEORIGIN+$028A
.var OCTANT_ADJUST	= adr.OCTANT_ADJUST .word
SX	= :STACKORIGIN-2
SY	= :STACKORIGIN-4

	rts						; ret
.endl

.local	MOUSECOORDS					; PROCEDURE

; optimize OK (service.pas), line = 21

	lda ATARI.PORTA
	and #$0F
	sta A

; optimize OK (service.pas), line = 23

	sta @CASETMP_0007
	cmp #$0B
	jne l_037F
@

; optimize OK (service.pas), line = 24

	mvy X+1 :bp+1
	ldy X
	lda (:bp),y
	cmp #$0B
	jcc l_0391

; optimize OK (service.pas), line = 25

	mwy X :bp2
	ldy #$00
	lda (:bp2),y
	sub #$04
	sta (:bp2),y

; optimize OK (service.pas), line = 27

	mvy X+1 :bp+1
	ldy X
	lda (:bp),y
	cmp #$0A
	jcs l_03A5
	ldy #$00
	lda #$0A
	sta (:bp2),y
l_03A5
l_0391
	jmp a_0007
l_037F
	cmp #$07
	jne l_03B5

; optimize OK (service.pas), line = 30

	mwy X :bp2
	ldy #$00
	lda #$D8
	sub VAUS.WIDTH
	sta :STACKORIGIN+10
	lda (:bp2),y
	cmp :STACKORIGIN+10
	jcs l_03CD

; optimize OK (service.pas), line = 31

	mwy X :bp2
	ldy #$00
	lda (:bp2),y
	add #$04
	sta (:bp2),y

; optimize OK (service.pas), line = 33

	add VAUS.WIDTH
	cmp #$D9
	jcc l_03E7
	lda #$D8
	sbc VAUS.WIDTH
	sta (:bp2),y
l_03E7
l_03CD
l_03B5
a_0007

; ------------------------------------------------------------

X	= DATAORIGIN+$01F2
A	= DATAORIGIN+$01F4
@CASETMP_0007	= DATAORIGIN+$01F5

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MOUSECLICK					; FUNCTION

; optimize OK (service.pas), line = 45

?volatile:
	lda JOYSTICK.TRIG0
	eor #$01
	sta RESULT
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$01F6

	rts						; ret
.endl

.local	BLITZERO					; PROCEDURE | REGISTER

; -------------------  ASM Block 00000161  -------------------

   fxs FX_MEMS #$80
 
; optimize OK (service.pas), line = 60

	lda SRC+2
	sta BLT_ZERO.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 61

	lda SRC+1
	sta BLT_ZERO.SRC_ADR.BYTE1

; optimize OK (service.pas), line = 62

	lda SRC
	sta BLT_ZERO.SRC_ADR.BYTE0

; optimize OK (service.pas), line = 64

	lda HLP+1
	sta BLT_ZERO.DST_ADR.BYTE1

; optimize OK (service.pas), line = 65

	lda HLP
	sta BLT_ZERO.DST_ADR.BYTE0

; optimize OK (service.pas), line = 67

	lda W
	sta BLT_ZERO.SRC_STEP_Y
	lda W+1
	sta BLT_ZERO.SRC_STEP_Y+1

; optimize OK (service.pas), line = 69

	ldy H
	dey
	sty BLT_ZERO.BLT_HEIGHT

; optimize OK (service.pas), line = 71

	lda W
	sub #$01
	sta BLT_ZERO.BLT_WIDTH
	lda W+1
	sbc #$00
	sta BLT_ZERO.BLT_WIDTH+1

; -------------------  ASM Block 00000162  -------------------

   fxs FX_MEMS #$00
 
; optimize OK (service.pas), line = 77

	lda BLT_ZERO
	sta VBXE.RUNBCB.A
	lda BLT_ZERO+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; --- WhileProlog
l_044C

; optimize FAIL ('VBXE.BLITTERBUSY', service.pas), line = 78

	jsr VBXE.BLITTERBUSY
	lda VBXE.BLITTERBUSY.RESULT
	jne l_044C

; ------------------------------------------------------------

SRC	= :EDX
W	= :ECX
H	= :EAX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BLITTEMP					; PROCEDURE | OVERLOAD | REGISTER
.local	@0201810000181000

; optimize OK (service.pas), line = 86

	lda DWIDTH
	sta BLT.DST_STEP_Y
	lda DWIDTH+1
	sta BLT.DST_STEP_Y+1

; optimize OK (service.pas), line = 87

	lda SWIDTH
	sta BLT.SRC_STEP_Y
	lda SWIDTH+1
	sta BLT.SRC_STEP_Y+1

; ------------------------------------------------------------

SWIDTH	= :EDX
DWIDTH	= :ECX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	BLITTEMP					; PROCEDURE | OVERLOAD | REGISTER
.local	@040180000018100001820000182000

; optimize OK (service.pas), line = 95

	lda SRC+2
	sta BLT.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 96

	lda SRC+1
	sta BLT.SRC_ADR.BYTE1

; optimize OK (service.pas), line = 97

	lda SRC
	sta BLT.SRC_ADR.BYTE0

; optimize OK (service.pas), line = 99

	lda DST+2
	sta BLT.DST_ADR.BYTE2

; optimize OK (service.pas), line = 100

	lda DST+1
	sta BLT.DST_ADR.BYTE1

; optimize OK (service.pas), line = 101

	lda DST
	sta BLT.DST_ADR.BYTE0

; optimize OK (service.pas), line = 103

	ldy H
	dey
	sty BLT.BLT_HEIGHT

; optimize OK (service.pas), line = 105

	lda W
	sub #$01
	sta BLT.BLT_WIDTH
	lda W+1
	sbc #$00
	sta BLT.BLT_WIDTH+1

; optimize OK (service.pas), line = 107

	lda BLT
	sta VBXE.RUNBCB.A
	lda BLT+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; --- WhileProlog
l_04A3

; optimize FAIL ('VBXE.BLITTERBUSY', service.pas), line = 108

	jsr VBXE.BLITTERBUSY
	lda VBXE.BLITTERBUSY.RESULT
	jne l_04A3

; ------------------------------------------------------------

SRC	= :EDX
DST	= :ECX
W	= :EAX
H	= DATAORIGIN+$01F7

@VarData	= H
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	BLITTEMP2TEMP					; PROCEDURE | REGISTER

; optimize OK (service.pas), line = 116

	lda #$02
	sta BLT.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 117

	sta BLT.DST_ADR.BYTE2

; optimize OK (service.pas), line = 119

	lda HLP+1
	sta BLT.SRC_ADR.BYTE1

; optimize OK (service.pas), line = 120

	sta BLT.DST_ADR.BYTE1

; optimize OK (service.pas), line = 121

	lda HLP
	sta BLT.SRC_ADR.BYTE0

; optimize OK (service.pas), line = 122

	sta BLT.DST_ADR.BYTE0

; optimize OK (service.pas), line = 124

	ldy H
	dey
	sty BLT.BLT_HEIGHT

; optimize OK (service.pas), line = 126

	lda W
	sub #$01
	sta BLT.BLT_WIDTH
	lda #$00
	sbc #$00
	sta BLT.BLT_WIDTH+1

; optimize OK (service.pas), line = 128

	lda BLT
	sta VBXE.RUNBCB.A
	lda BLT+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; --- WhileProlog
l_04E9

; optimize FAIL ('VBXE.BLITTERBUSY', service.pas), line = 129

	jsr VBXE.BLITTERBUSY
	lda VBXE.BLITTERBUSY.RESULT
	jne l_04E9

; optimize OK (service.pas), line = 131

	lda #$03
	sta BLT.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 132

	sta BLT.DST_ADR.BYTE2

; optimize OK (service.pas), line = 134

	lda BLT
	sta VBXE.RUNBCB.A
	lda BLT+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; --- WhileProlog
l_04FB

; optimize FAIL ('VBXE.BLITTERBUSY', service.pas), line = 135

	jsr VBXE.BLITTERBUSY
	lda VBXE.BLITTERBUSY.RESULT
	jne l_04FB

; ------------------------------------------------------------

W	= :EDX
H	= :ECX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BLITCLR						; PROCEDURE | REGISTER

; optimize OK (service.pas), line = 143

	lda #$40
	sta BLT.DST_STEP_Y
	lda #$01
	sta BLT.DST_STEP_Y+1

; optimize OK (service.pas), line = 144

	lda #$40
	sta BLT.SRC_STEP_Y
	lda #$01
	sta BLT.SRC_STEP_Y+1

; optimize OK (service.pas), line = 146

	lda #$04
	sta BLT.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 148

	lda HLP+1
	sta BLT.SRC_ADR.BYTE1

; optimize OK (service.pas), line = 149

	sta BLT.DST_ADR.BYTE1

; optimize OK (service.pas), line = 150

	lda HLP
	sta BLT.SRC_ADR.BYTE0

; optimize OK (service.pas), line = 151

	sta BLT.DST_ADR.BYTE0

; optimize OK (service.pas), line = 153

	lda #$02
	sta BLT.DST_ADR.BYTE2

; optimize OK (service.pas), line = 155

	ldy H
	dey
	sty BLT.BLT_HEIGHT

; optimize OK (service.pas), line = 157

	lda W
	sub #$01
	sta BLT.BLT_WIDTH
	lda W+1
	sbc #$00
	sta BLT.BLT_WIDTH+1

; optimize OK (service.pas), line = 159

	lda BLT
	sta VBXE.RUNBCB.A
	lda BLT+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; --- WhileProlog
l_0548

; optimize FAIL ('VBXE.BLITTERBUSY', service.pas), line = 160

	jsr VBXE.BLITTERBUSY
	lda VBXE.BLITTERBUSY.RESULT
	jne l_0548

; optimize OK (service.pas), line = 162

	lda #$03
	sta BLT.DST_ADR.BYTE2

; optimize OK (service.pas), line = 164

	lda BLT
	sta VBXE.RUNBCB.A
	lda BLT+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; --- WhileProlog
l_0556

; optimize FAIL ('VBXE.BLITTERBUSY', service.pas), line = 165

	jsr VBXE.BLITTERBUSY
	lda VBXE.BLITTERBUSY.RESULT
	jne l_0556

; ------------------------------------------------------------

W	= :EDX
H	= :ECX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BLITSCR						; PROCEDURE | REGISTER

; optimize OK (service.pas), line = 173

	lda DWIDTH
	sta BLT.DST_STEP_Y
	lda DWIDTH+1
	sta BLT.DST_STEP_Y+1

; optimize OK (service.pas), line = 174

	lda SWIDTH
	sta BLT.SRC_STEP_Y
	lda #$00
	sta BLT.SRC_STEP_Y+1

; optimize OK (service.pas), line = 176

	lda #$02
	sta BLT.SRC_ADR.BYTE1

; optimize OK (service.pas), line = 178

	lda #$00
	sta BLT.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 179

	sta BLT.SRC_ADR.BYTE0

; optimize OK (service.pas), line = 181

	lda #$02
	sta BLT.DST_ADR.BYTE2

; optimize OK (service.pas), line = 182

	lda HLP+1
	sta BLT.DST_ADR.BYTE1

; optimize OK (service.pas), line = 183

	lda HLP
	sta BLT.DST_ADR.BYTE0

; optimize OK (service.pas), line = 185

	ldy H
	dey
	sty BLT.BLT_HEIGHT

; optimize OK (service.pas), line = 187

	lda W
	sub #$01
	sta BLT.BLT_WIDTH
	lda W+1
	sbc #$00
	sta BLT.BLT_WIDTH+1

; optimize OK (service.pas), line = 189

	lda BLT
	sta VBXE.RUNBCB.A
	lda BLT+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; --- WhileProlog
l_05A0

; optimize FAIL ('VBXE.BLITTERBUSY', service.pas), line = 190

	jsr VBXE.BLITTERBUSY
	lda VBXE.BLITTERBUSY.RESULT
	jne l_05A0

; optimize OK (service.pas), line = 192

	lda #$03
	sta BLT.DST_ADR.BYTE2

; optimize OK (service.pas), line = 194

	lda BLT
	sta VBXE.RUNBCB.A
	lda BLT+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; --- WhileProlog
l_05AE

; optimize FAIL ('VBXE.BLITTERBUSY', service.pas), line = 195

	jsr VBXE.BLITTERBUSY
	lda VBXE.BLITTERBUSY.RESULT
	jne l_05AE

; ------------------------------------------------------------

SWIDTH	= :EDX
DWIDTH	= :ECX
W	= :EAX
H	= DATAORIGIN+$01F8

@VarData	= H
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BLITBOX						; PROCEDURE | REGISTER

; -------------------  ASM Block 00000163  -------------------

   fxs FX_MEMS #$80
 
; optimize OK (service.pas), line = 243

	lda HLP+1
	sta BLT_BOX.SRC_ADR.BYTE1

; optimize OK (service.pas), line = 244

	sta BLT_BOX.DST_ADR.BYTE1

; optimize OK (service.pas), line = 246

	lda HLP
	sta BLT_BOX.SRC_ADR.BYTE0

; optimize OK (service.pas), line = 247

	sta BLT_BOX.DST_ADR.BYTE0

; optimize OK (service.pas), line = 249

	lda W
	sub #$01
	sta BLT_BOX.BLT_WIDTH
	lda W+1
	sbc #$00
	sta BLT_BOX.BLT_WIDTH+1

; optimize OK (service.pas), line = 250

	ldy H
	dey
	sty BLT_BOX.BLT_HEIGHT

; -------------------  ASM Block 00000164  -------------------

   fxs FX_MEMS #$00
 
; optimize OK (service.pas), line = 256

	lda BLT_BOX
	sta VBXE.RUNBCB.A
	lda BLT_BOX+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; --- WhileProlog
l_05EB

; optimize FAIL ('VBXE.BLITTERBUSY', service.pas), line = 257

	jsr VBXE.BLITTERBUSY
	lda VBXE.BLITTERBUSY.RESULT
	jne l_05EB

; ------------------------------------------------------------

W	= :EDX
H	= :ECX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	NOSOUND						; PROCEDURE

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MYDELAY						; PROCEDURE

; ------------------------------------------------------------

A	= DATAORIGIN+$01F9

@VarData	= A
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MAX						; FUNCTION

; optimize OK (service.pas), line = 325

	lda B
	cmp A
	lda B+1
	sbc A+1
	svc
	eor #$80
	jpl l_060D
	lda A
	sta RESULT
	lda A+1
	jmp l_061C
l_060D

; optimize OK (service.pas), line = 326

	lda B
	sta RESULT
	lda B+1
l_061C
	sta RESULT+1
@exit

; ------------------------------------------------------------

A	= DATAORIGIN+$01FB
B	= DATAORIGIN+$01FD
RESULT	= DATAORIGIN+$01FF

@VarData	= A
@VarDataSize	= 4

	rts						; ret
.endl

.local	MIN						; FUNCTION

; optimize OK (service.pas), line = 332

	lda A
	cmp B
	lda A+1
	sbc B+1
	svc
	eor #$80
	jpl l_0637
	lda A
	sta RESULT
	lda A+1
	jmp l_0646
l_0637

; optimize OK (service.pas), line = 333

	lda B
	sta RESULT
	lda B+1
l_0646
	sta RESULT+1
@exit

; ------------------------------------------------------------

A	= DATAORIGIN+$0201
B	= DATAORIGIN+$0203
RESULT	= DATAORIGIN+$0205

@VarData	= A
@VarDataSize	= 4

	rts						; ret
.endl

.local	FATAL_ERROR					; PROCEDURE
	sta ERR_TYPE

; optimize OK (service.pas), line = 342

	sta STATUS

; -------------------  ASM Block 00000165  -------------------

      sta $100
      
      kk: lda $d20a
      sta $d01a
      jmp kk
    
    
; ------------------------------------------------------------

ERR_TYPE	= DATAORIGIN+$0207

@VarData	= ERR_TYPE
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	INITROWARRAY					; PROCEDURE

; optimize OK (service.pas), line = 390

	lda #$00
	sta HLP
	sta HLP+1

; optimize OK (service.pas), line = 392

	tay

l_0666
; --- ForToDoCondition
	cpy #$10
	jcs l_0674

; optimize OK (service.pas), line = 394

	lda HLP
	sta adr.MUL90_16,y
	lda HLP+1
	sta adr.MUL90_16+16,y

; optimize OK (service.pas), line = 396

	lda HLP
	add #$5A
	sta HLP
	scc
	inc HLP+1

; --- ForToDoEpilog
	iny
	jne l_0666
l_0674
	sty Y

; optimize OK (service.pas), line = 401

	lda #$00
	sta HLP
	sta HLP+1

; optimize OK (service.pas), line = 403

	sta Y

l_068F
; --- ForToDoCondition
	lda #$0A
	sta @BYTE.MOD.B
	lda Y
	sta @BYTE.MOD.A
	jsr @BYTE.MOD
	lda @BYTE.MOD.RESULT
	ldy Y
	sta adr.MOD10TABLE,y

; optimize OK (service.pas), line = 406

	lda #$00
	sta @WORD.MOD.A
	lda Y
	sta @WORD.MOD.A+1
	lda #$5A
	sta @WORD.MOD.B
	lda #$00
	sta @WORD.MOD.B+1
	jsr @WORD.MOD
	lda @WORD.MOD.RESULT
	ldy Y
	sta adr.MOD90TABLE,y

; optimize OK (service.pas), line = 407

	lda #$00
	sta @WORD.MOD.A
	lda Y
	sta @WORD.MOD.A+1
	lda #$68
	sta @WORD.MOD.B
	lda #$01
	sta @WORD.MOD.B+1
	jsr @WORD.MOD
	ldy Y
	lda @WORD.MOD.RESULT
	sta adr.MOD360TABLE,y
	lda @WORD.MOD.RESULT+1
	sta adr.MOD360TABLE+256,y

; optimize OK (service.pas), line = 409

	ldy Y
	cpy #$C8
	jcc l_06DE

; optimize OK (service.pas), line = 410

	lda #$00
	sta adr.ROW,y
	lda #$FA
	sta adr.ROW+256,y
	jmp l_06EF
l_06DE

; optimize OK (service.pas), line = 412

	ldy Y
	lda HLP
	sta adr.ROW,y
	lda HLP+1
	sta adr.ROW+256,y

; optimize OK (service.pas), line = 414

	lda HLP
	add #$40
	sta HLP
	lda HLP+1
	adc #$01
	sta HLP+1
l_06EF

; --- ForToDoEpilog
	inc Y
	jne l_068F
l_069D

; ------------------------------------------------------------

Y	= DATAORIGIN+$0208

@VarData	= Y
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	INITSVGA					; PROCEDURE

; optimize OK (service.pas), line = 430

	lda GRAPH.GRAPHRESULT
	cmp #$01
	jeq l_0713

; optimize FAIL ('@print', service.pas), line = 431

	@printSTRING #CODEORIGIN+$0000
	@printEOL
	lda #$00
	jmp @halt
l_0713

; optimize OK (service.pas), line = 435

	lda #$1F
	jsr VBXE.SETHORIZONTALRES.@010180000

; optimize FAIL ('VBXE.COLORMAPOFF', service.pas), line = 436

	jsr VBXE.COLORMAPOFF

; optimize OK (service.pas), line = 438

	lda #$07
	jsr VBXE.VBXECONTROL

; optimize OK (service.pas), line = 440

	lda #$14
	jsr VBXE.SETTOPBORDER

; optimize OK (service.pas), line = 441

	lda #$C8
	jsr VBXE.SETXDLHEIGHT

; optimize OK (service.pas), line = 443

	lda #$00
	sta VBXE.SETOVERLAYADDRESS.A
	sta VBXE.SETOVERLAYADDRESS.A+1
	lda #$03
	sta VBXE.SETOVERLAYADDRESS.A+2
	lda #$00
	sta VBXE.SETOVERLAYADDRESS.A+3
	jsr VBXE.SETOVERLAYADDRESS

; optimize OK (service.pas), line = 445

	lda #$00
	sta VBXE_RAM.POSITION
	sta VBXE_RAM.POSITION+1
	lda #$03
	sta VBXE_RAM.POSITION+2
	lda #$00
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 446

	sta VBXE_RAM.SIZE
	lda #$FA
	sta VBXE_RAM.SIZE+1
	lda #$03
	sta VBXE_RAM.SIZE+2
	lda #$00
	sta VBXE_RAM.SIZE+3

; optimize FAIL ('VBXE.TVBXEMEMORYSTREAM.CLEAR', service.pas), line = 447

	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.CLEAR

; optimize OK (service.pas), line = 449

	lda #$00
	sta ATARI.DMACTL

; -------------------  ASM Block 00000166  -------------------

	  fxs FX_MEMS #$80
	
; optimize OK (service.pas), line = 455

	lda BLT
	sta :bp2
	lda BLT+1
	sta :bp2+1
	lda #$00
	ldy #$14
	sta:rpl (:bp2),y-

; optimize OK (service.pas), line = 456

	lda BLT_LETTER
	sta :bp2
	lda BLT_LETTER+1
	sta :bp2+1
	lda #$00
	ldy #$14
	sta:rpl (:bp2),y-

; optimize OK (service.pas), line = 457

	lda BLT_BOX
	sta :bp2
	lda BLT_BOX+1
	sta :bp2+1
	lda #$00
	ldy #$14
	sta:rpl (:bp2),y-

; optimize OK (service.pas), line = 458

	lda BLT_ZERO
	sta :bp2
	lda BLT_ZERO+1
	sta :bp2+1
	lda #$00
	ldy #$14
	sta:rpl (:bp2),y-

; optimize OK (service.pas), line = 461

	lda #$01
	sta BLT.SRC_STEP_X

; optimize OK (service.pas), line = 462

	sta BLT.DST_STEP_X

; optimize OK (service.pas), line = 466

	lda #$FF
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 470

	lda #$03
	sta BLT_LETTER.DST_ADR.BYTE2

; optimize OK (service.pas), line = 472

	lda #$01
	sta BLT_LETTER.SRC_STEP_X

; optimize OK (service.pas), line = 473

	sta BLT_LETTER.DST_STEP_X

; optimize OK (service.pas), line = 475

	sta BLT_LETTER.BLT_CONTROL

; optimize OK (service.pas), line = 477

	lda #$40
	sta BLT_LETTER.DST_STEP_Y
	lda #$01
	sta BLT_LETTER.DST_STEP_Y+1

; optimize OK (service.pas), line = 478

	lda #$80
	sta BLT_LETTER.SRC_STEP_Y
	lda #$00
	sta BLT_LETTER.SRC_STEP_Y+1

; optimize OK (service.pas), line = 480

	lda #$07
	sta BLT_LETTER.BLT_HEIGHT

; optimize OK (service.pas), line = 482

	lda #$0F
	sta BLT_LETTER.BLT_WIDTH
	lda #$00
	sta BLT_LETTER.BLT_WIDTH+1

; optimize OK (service.pas), line = 484

	lda #$FF
	sta BLT_LETTER.BLT_AND_MASK

; optimize OK (service.pas), line = 488

	lda #$02
	sta BLT_BOX.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 490

	lda #$03
	sta BLT_BOX.DST_ADR.BYTE2

; optimize OK (service.pas), line = 492

	lda #$40
	sta BLT_BOX.DST_STEP_Y
	lda #$01
	sta BLT_BOX.DST_STEP_Y+1

; optimize OK (service.pas), line = 493

	lda #$40
	sta BLT_BOX.SRC_STEP_Y
	lda #$01
	sta BLT_BOX.SRC_STEP_Y+1

; optimize OK (service.pas), line = 495

	sta BLT_BOX.SRC_STEP_X

; optimize OK (service.pas), line = 496

	sta BLT_BOX.DST_STEP_X

; optimize OK (service.pas), line = 500

	lda #$FF
	sta BLT_BOX.BLT_AND_MASK

; optimize OK (service.pas), line = 504

	lda #$03
	sta BLT_ZERO.DST_ADR.BYTE2

; optimize OK (service.pas), line = 506

	lda #$40
	sta BLT_ZERO.DST_STEP_Y
	lda #$01
	sta BLT_ZERO.DST_STEP_Y+1

; optimize OK (service.pas), line = 508

	sta BLT_ZERO.SRC_STEP_X

; optimize OK (service.pas), line = 509

	sta BLT_ZERO.DST_STEP_X

; optimize OK (service.pas), line = 511

	sta BLT_ZERO.BLT_CONTROL

; optimize OK (service.pas), line = 513

	lda #$FF
	sta BLT_ZERO.BLT_AND_MASK

; -------------------  ASM Block 00000167  -------------------

	  fxs FX_MEMS #$00
	
; optimize FAIL ('SYSTEM.PAUSE.@00', service.pas), line = 520

	jsr SYSTEM.PAUSE.@00

; -------------------  ASM Block 00000168  -------------------

  sei
  lda #0
  sta nmien
  sta irqen
  
  lda #$fe
  sta portb
  
  mwa #NMI $fffa
 
  mva #$40 nmien
 
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SHINE_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 552

	lda SHINEREC.XB
	sta XB

; optimize OK (service.pas), line = 553

	lda SHINEREC.YB
	sta YB

; optimize OK (service.pas), line = 555

	asl @
	asl @
	asl @
	asl @
	add XB
	sta I

; -------------------  ASM Block 00000169  -------------------

	fxs FX_MEMS #$80
    
; optimize OK (service.pas), line = 562

	ldy I
	lda adr.WALL,y
	cmp #$09
	jcc l_07DE

; optimize OK (service.pas), line = 564

	lda SHINEREC.FRAME
	lsr @
	sta FRAME

; optimize OK (service.pas), line = 565

	lda adr.WALL,y
	cmp #$0A
	jeq l_07FE
	lda FRAME
	add #$05
	sta FRAME
l_07FE

; optimize OK (service.pas), line = 567

	lda XB
	asl @
	asl @
	asl @
	asl @
	add #$09
	sta XF

; optimize OK (service.pas), line = 568

	lda YB
	asl @
	asl @
	asl @
	add #$16
	sta YF

; optimize OK (service.pas), line = 569

	lda FRAME
	sta :STACKORIGIN+9
	lda #$00
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	sta FR+1
	lda :STACKORIGIN+9
	sta FR

; optimize OK (service.pas), line = 572

	lda #$10
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$00
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 574

	lda YF
	add Y
	tay
	lda XF
	add adr.ROW,y
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda #$00
	adc adr.ROW+256,y
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$03
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$9D
	add FR
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda #$91
	adc FR+1
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$00
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda #$00
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$10
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$08
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000
l_07DE

; -------------------  ASM Block 00000170  -------------------

	  fxs FX_MEMS #$00
       
; optimize FAIL (0, service.pas), line = 593

	inc SHINEREC.FRAME

; optimize OK (service.pas), line = 594

	lda SHINEREC.FRAME
	cmp #$0A
	jne l_0861
	lda #$00
	sta SHINEREC.ACTIVE
l_0861

; ------------------------------------------------------------

XB	= DATAORIGIN+$0209
YB	= DATAORIGIN+$020A
FRAME	= DATAORIGIN+$020B
XF	= DATAORIGIN+$020C
YF	= DATAORIGIN+$020D
FR	= DATAORIGIN+$020E
Y	= DATAORIGIN+$0210
I	= DATAORIGIN+$0211

@VarData	= XB
@VarDataSize	= 9

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	UNSHINE_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 604

	lda #$09
	sta SHINEREC.FRAME

; optimize FAIL ('SHINE_BLOCK', service.pas), line = 605

	jsr SHINE_BLOCK

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SHINE						; PROCEDURE

; optimize OK (service.pas), line = 613

	lda SHINEREC.ACTIVE
	jeq l_0881
	jsr UNSHINE_BLOCK
l_0881

; optimize OK (service.pas), line = 615

	lda XB
	sta SHINEREC.XB

; optimize OK (service.pas), line = 616

	lda YB
	sta SHINEREC.YB

; optimize OK (service.pas), line = 617

	lda #$00
	sta SHINEREC.FRAME

; optimize OK (service.pas), line = 618

	lda #$01
	sta SHINEREC.ACTIVE

; optimize OK (service.pas), line = 619

	lda YB
	asl @
	asl @
	asl @
	asl @
	add XB
	tay
	lda adr.WALL,y
	sta SHINEREC.BLOCK

; ------------------------------------------------------------

XB	= DATAORIGIN+$0212
YB	= DATAORIGIN+$0213

@VarData	= XB
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CHECKSHINE					; PROCEDURE

; optimize OK (service.pas), line = 626

	lda SHINEREC.ACTIVE
	cmp #$01
	jne l_08C2
	jsr SHINE_BLOCK
l_08C2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	RANDOM_LETTER_DROP				; FUNCTION

; --- RepeatUntilProlog
l_08CB

; optimize OK (service.pas), line = 635

	lda #$64
	sta RAND.RANGE
	lda #$00
	sta RAND.RANGE+1
	jsr RAND
	lda RAND.RESULT
	sta RN
	lda RAND.RESULT+1
	sta RN+1

; optimize OK (service.pas), line = 636

	lda #$00
	sta SUM
	sta SUM+1

; optimize OK (service.pas), line = 637

	sta LETTER
	sta LETTER+1

; --- RepeatUntilProlog
l_08D9

; optimize FAIL (0, service.pas), line = 642

	inc LETTER
	sne
	inc LETTER+1

; optimize OK (service.pas), line = 643

	ldy LETTER
	lda adr.LETTER_DIS,y
	add SUM
	sta SUM
	lda SUM+1
	adc #$00
	sta SUM+1

; optimize OK (service.pas), line = 646

	lda RN+1
	cmp SUM+1
	bne @+
	lda RN
	cmp SUM
@
	jcs l_08D9

; optimize OK (service.pas), line = 650

	lda LETTER
	sub #$01
	sta :STACKORIGIN+9
	lda LETTER+1
	sbc #$00
	cmp LETT.LAST+1
	bne @+
	lda :STACKORIGIN+9
	cmp LETT.LAST
@
	jeq l_08CB

; optimize OK (service.pas), line = 652

	lda LETTER
	sub #$01
	sta RESULT
	lda LETTER+1
	sbc #$00
	sta RESULT+1
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$0214
RN	= DATAORIGIN+$0216
SUM	= DATAORIGIN+$0218
LETTER	= DATAORIGIN+$021A

@VarData	= RN
@VarDataSize	= 6

	rts						; ret
.endl

.local	PUT_LETTER					; PROCEDURE

; optimize OK (service.pas), line = 660

	lda #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda LETT.TYP+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda LETT.TYP
	asl @
	rol :STACKORIGIN+STACKWIDTH+10
	rol :STACKORIGIN+STACKWIDTH*2+10
	asl @
	rol :STACKORIGIN+STACKWIDTH+10
	rol :STACKORIGIN+STACKWIDTH*2+10
	sta :STACKORIGIN+10
	lda :STACKORIGIN+STACKWIDTH*2+10
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+STACKWIDTH+10
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$9E
	add :STACKORIGIN+10
	sta :STACKORIGIN+STACKWIDTH+9
	lda #$00
	adc :STACKORIGIN+STACKWIDTH*2+10
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda #$00
	adc :STACKORIGIN+STACKWIDTH*3+10
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda LETT.FRAME
	sta :STACKORIGIN+10
	lda #$00
	asl :STACKORIGIN+10
	rol @
	asl :STACKORIGIN+10
	rol @
	asl :STACKORIGIN+10
	rol @
	asl :STACKORIGIN+10
	rol @
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$CC
	add :STACKORIGIN+10
	sta SRC
	lda :STACKORIGIN+STACKWIDTH+9
	adc :STACKORIGIN+STACKWIDTH+10
	sta SRC+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc :STACKORIGIN+STACKWIDTH*2+10
	sta SRC+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc :STACKORIGIN+STACKWIDTH*3+10
	sta SRC+3

; -------------------  ASM Block 00000171  -------------------

       fxs FX_MEMS #$80
     
; optimize OK (service.pas), line = 666

	lda SRC+2
	sta BLT_LETTER.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 667

	lda SRC+1
	sta BLT_LETTER.SRC_ADR.BYTE1

; optimize OK (service.pas), line = 668

	lda SRC
	sta BLT_LETTER.SRC_ADR.BYTE0

; optimize OK (service.pas), line = 670

	ldy LETT.Y
	lda LETT.X
	add adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 672

	sta BLT_LETTER.DST_ADR.BYTE1

; optimize OK (service.pas), line = 673

	lda HLP
	sta BLT_LETTER.DST_ADR.BYTE0

; -------------------  ASM Block 00000172  -------------------

       fxs FX_MEMS #$00
     
; optimize OK (service.pas), line = 679

	lda BLT_LETTER
	sta VBXE.RUNBCB.A
	lda BLT_LETTER+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; ------------------------------------------------------------

SRC	= DATAORIGIN+$021C

@VarData	= SRC
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_LETTER					; PROCEDURE

; optimize OK (service.pas), line = 687

	ldy LETT.Y
	cpy #$C8
	jcs l_096D

; optimize OK (service.pas), line = 689

	lda LETT.X
	adc adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 691

	lda #$10
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda #$08
	sta BLITBOX.H
	jsr BLITBOX
l_096D

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DISABLE_LETTER					; PROCEDURE

; optimize FAIL ('REMOVE_LETTER', service.pas), line = 700

	jsr REMOVE_LETTER

; optimize OK (service.pas), line = 701

	lda #$00
	sta LETT.ACTIVE

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	START_LETTER					; PROCEDURE

; optimize OK (service.pas), line = 707

	lda LETT.ACTIVE
	jeq l_099A
	jsr DISABLE_LETTER
l_099A

; optimize OK (service.pas), line = 709

	lda XL
	sta LETT.X

; optimize OK (service.pas), line = 710

	lda YL
	sta LETT.Y

; optimize OK (service.pas), line = 711

	lda LETTER
	sta LETT.TYP
	lda LETTER+1
	sta LETT.TYP+1

; optimize OK (service.pas), line = 712

	lda #$00
	sta LETT.FRAME

; optimize OK (service.pas), line = 713

	sta LETT.SUBFRAME

; optimize OK (service.pas), line = 714

	lda #$01
	sta LETT.ACTIVE

; ------------------------------------------------------------

XL	= DATAORIGIN+$0220
YL	= DATAORIGIN+$0221
LETTER	= DATAORIGIN+$0222

@VarData	= XL
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CHECK_LETTER					; PROCEDURE

; optimize OK (service.pas), line = 720

	lda LETT.ACTIVE
	jeq l_09CB

; optimize FAIL ('REMOVE_LETTER', service.pas), line = 722

	jsr REMOVE_LETTER

; optimize FAIL (0, service.pas), line = 723

	inc LETT.Y

; optimize OK (service.pas), line = 724

	lda LETT.Y
	cmp #$C8
	jcc l_09E3
; optimize FAIL ('DISABLE_LETTER', service.pas), line = 725
	jmp l_09EE
l_09E3

; optimize FAIL ('PUT_LETTER', service.pas), line = 727

	jsr PUT_LETTER

; optimize FAIL (0, service.pas), line = 728

	inc LETT.SUBFRAME

; optimize OK (service.pas), line = 729

	lda LETT.SUBFRAME
	cmp #$05
	jne l_0A05

; optimize OK (service.pas), line = 731

	lda #$00
	sta LETT.SUBFRAME

; optimize FAIL (0, service.pas), line = 732

	inc LETT.FRAME
l_0A05

; optimize OK (service.pas), line = 735

	lda LETT.FRAME
	cmp #$08
	jne l_0A22
	lda #$00
	sta LETT.FRAME
l_0A22

; optimize OK (service.pas), line = 737

	lda LETT.X
	add #$10
	sta :STACKORIGIN+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	cmp :STACKORIGIN+STACKWIDTH+10
	bne @+
	lda VAUS.X
	cmp :STACKORIGIN+10
@
	jcs l_0A7B
@
	lda VAUS.X
	add VAUS.WIDTH
	sta :STACKORIGIN+10
	lda #$00
	adc #$00
	cmp #$00
	bne @+
	lda :STACKORIGIN+10
	cmp LETT.X
@
	jcc l_0A7B
	jeq l_0A7B
@
	lda LETT.Y
	add #$08
	sta :STACKORIGIN+11
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+11
	lda #$00
	cmp :STACKORIGIN+STACKWIDTH+11
	bne @+
	lda VAUS.Y
	cmp :STACKORIGIN+11
@
	jcs l_0A7B
@
	lda VAUS.Y
	add VAUS.HEIGHT
	sta :STACKORIGIN+10
	lda #$00
	adc #$00
	cmp #$00
	bne @+
	lda :STACKORIGIN+10
	cmp LETT.Y
@
	jcc l_0A7B
	jeq l_0A7B
@

; optimize OK (service.pas), line = 744

	ldy LETT.TYP
	iny
	sty VAUS.LETTER

; optimize OK (service.pas), line = 745

	lda CUR_PLAYER
	asl @
	asl @
	tay
	lda adr.SCORE.PLAYER,y
	add #$E8
	sta adr.SCORE.PLAYER,y
	lda adr.SCORE.PLAYER+1,y
	adc #$03
	sta adr.SCORE.PLAYER+1,y
	lda adr.SCORE.PLAYER+2,y
	adc #$00
	sta adr.SCORE.PLAYER+2,y
	lda adr.SCORE.PLAYER+3,y
	adc #$00
	sta adr.SCORE.PLAYER+3,y
l_09EE

; optimize FAIL ('DISABLE_LETTER', service.pas), line = 746

	jsr DISABLE_LETTER
l_0A7B

; optimize OK (service.pas), line = 750

	lda #$00
	sta LETT.INCOMING
	sta LETT.INCOMING+1
	jmp l_0A99
l_09CB

; optimize OK (service.pas), line = 752

	lda LETT.INCOMING
	cmp #$E9
	lda LETT.INCOMING+1
	sbc #$03
	svc
	eor #$80
	jmi l_0AAA

; optimize OK (service.pas), line = 753

	lda LETT.NEXTX
	sta START_LETTER.XL
	lda LETT.NEXTY
	sta START_LETTER.YL
	lda LETT.NEXTTYPE
	sta START_LETTER.LETTER
	lda LETT.NEXTTYPE+1
	sta START_LETTER.LETTER+1
	jsr START_LETTER
l_0A99
l_0AAA

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLACE_BALL					; PROCEDURE

; optimize OK (service.pas), line = 763

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sub #$03
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	sub #$03
	tay
	lda :STACKORIGIN+9
	add adr.ROW,y
	sta HLP
	lda :STACKORIGIN+STACKWIDTH+9
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 765

	lda #$B4
	sta BLITZERO.SRC
	lda #$BE
	sta BLITZERO.SRC+1
	lda #$00
	sta BLITZERO.SRC+2
	sta BLITZERO.SRC+3
	lda #$05
	sta BLITZERO.W
	lda #$00
	sta BLITZERO.W+1
	lda #$05
	sta BLITZERO.H
	jsr BLITZERO

; ------------------------------------------------------------

BALL	= DATAORIGIN+$0224
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019

@VarData	= BALL
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_BALL					; PROCEDURE

; optimize OK (service.pas), line = 775

	mwy BALL :bp2
	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	sub #$03
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	sub #$03
	tay
	lda :STACKORIGIN+9
	add adr.ROW,y
	sta HLP
	lda :STACKORIGIN+STACKWIDTH+9
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 777

	lda #$05
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda #$05
	sta BLITBOX.H
	jsr BLITBOX

; ------------------------------------------------------------

BALL	= DATAORIGIN+$0228
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019

@VarData	= BALL
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	WAIT_VBL					; PROCEDURE

; optimize FAIL ('SYSTEM.PAUSE.@00', service.pas), line = 798

	jsr SYSTEM.PAUSE.@00

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SET_BALL					; PROCEDURE

; optimize OK (service.pas), line = 809

	mwy BALL :bp2
	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	cmp #$FF
	jeq l_0B0Cs
	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	cmp #$FF
	jeq l_0B0Cs
	lda:sne #$01
l_0B0Cs	lda #$00
	sta B0

; optimize OK (service.pas), line = 810

	mwy BALL :bp2
	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	ldy #BALL.X-DATAORIGIN
	cmp (:bp2),y
	bne @+
	jmp *+6
@\	jmp l_0B24s
	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	ldy #BALL.Y-DATAORIGIN
	cmp (:bp2),y
	bne @+
	jmp *+6
@\	jmp l_0B24s
	lda:seq #$00
l_0B24s	lda #$01
	sta B1

; optimize OK (service.pas), line = 812

	lda B0
	and B1
	jeq l_0B36

; optimize OK (service.pas), line = 813

	lda BALL
	sta REMOVE_BALL.BALL
	lda BALL+1
	sta REMOVE_BALL.BALL+1
	jsr REMOVE_BALL
l_0B36

; optimize OK (service.pas), line = 815

	lda BALL
	sta PLACE_BALL.BALL
	lda BALL+1
	sta PLACE_BALL.BALL+1
	jsr PLACE_BALL

; optimize OK (service.pas), line = 817

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.OLDX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 818

	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.OLDY-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; ------------------------------------------------------------

BALL	= DATAORIGIN+$022C
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019
B0	= DATAORIGIN+$0230
B1	= DATAORIGIN+$0231

@VarData	= BALL
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SET_BALL_SPEED					; PROCEDURE

; optimize OK (service.pas), line = 830

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda (:bp2),y
	sta SX
	iny
	lda (:bp2),y
	sta SX+1

; optimize OK (service.pas), line = 831

	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta SY
	iny
	lda (:bp2),y
	sta SY+1

; optimize OK (service.pas), line = 833

	lda SX+1
	jpl l_0B68

; optimize OK (service.pas), line = 834

	lda #$00
	sub SX
	sta A
	lda #$00
	sbc SX+1
	jmp l_0B7A
l_0B68

; optimize OK (service.pas), line = 836

	lda SX
	sta A
	lda SX+1
l_0B7A
	sta A+1

; optimize OK (service.pas), line = 838

	lda SY+1
	jpl l_0B90

; optimize OK (service.pas), line = 839

	lda #$00
	sub SY
	sta B
	lda #$00
	sbc SY+1
	jmp l_0BA2
l_0B90

; optimize OK (service.pas), line = 841

	lda SY
	sta B
	lda SY+1
l_0BA2
	sta B+1

; optimize OK (service.pas), line = 843

	lda A+1
	and #$03
	sta A+1

; optimize OK (service.pas), line = 844

	lda B+1
	and #$03
	sta B+1

; optimize OK (service.pas), line = 846

	lda A+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda A
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	sta :bp2
	lda #$A0
	add :STACKORIGIN+STACKWIDTH+9
	sta :bp2+1
	lda B+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda B
	asl @
	rol :STACKORIGIN+STACKWIDTH+10
	asl @
	rol :STACKORIGIN+STACKWIDTH+10
	sta :TMP
	lda #$A0
	add :STACKORIGIN+STACKWIDTH+10
	sta :TMP+1
	ldy #$00
	lda (:bp2),y
	add (:TMP),y
	sta I
	iny
	lda (:bp2),y
	adc (:TMP),y
	sta I+1
	iny
	lda (:bp2),y
	adc (:TMP),y
	sta I+2
	iny
	lda (:bp2),y
	adc (:TMP),y
	sta I+3

; optimize OK (service.pas), line = 848

	lda I
	sta :FPMAN0
	lda I+1
	sta :FPMAN1
	lda I+2
	sta :FPMAN2
	lda I+3
	sta :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta FASTSQRT.X
	lda :FPMAN1
	sta FASTSQRT.X+1
	lda :FPMAN2
	sta FASTSQRT.X+2
	lda :FPMAN3
	sta FASTSQRT.X+3
	jsr FASTSQRT
	inx
	lda FASTSQRT.RESULT
	sta :FPMAN0
	lda FASTSQRT.RESULT+1
	sta :FPMAN1
	lda FASTSQRT.RESULT+2
	sta :FPMAN2
	lda FASTSQRT.RESULT+3
	sta :FPMAN3
	jsr @F2I
	lda :FPMAN0
	sta LEN
	lda :FPMAN1
	sta LEN+1
	dex

; optimize OK (service.pas), line = 850

	lda LEN+1
	ora LEN
	jeq @exit
l_0BDB

; optimize OK (service.pas), line = 854

	lda SPEED
	sta :ecx
	lda SPEED+1
	sta :ecx+1
	lda A
	sta :eax
	lda A+1
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda LEN
	sta @CARDINAL.DIV.B
	lda LEN+1
	sta @CARDINAL.DIV.B+1
	lda #$00
	sta @CARDINAL.DIV.B+2
	sta @CARDINAL.DIV.B+3
	jsr @CARDINAL.DIV
	lda :eax
	sta X
	lda :eax+1
	sta X+1

; optimize OK (service.pas), line = 856

	ora X
	jeq @exit
l_0BFE

; optimize OK (service.pas), line = 858

	lda SPEED
	sta :ecx
	lda SPEED+1
	sta :ecx+1
	lda B
	sta :eax
	lda B+1
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda LEN
	sta @CARDINAL.DIV.B
	lda LEN+1
	sta @CARDINAL.DIV.B+1
	lda #$00
	sta @CARDINAL.DIV.B+2
	sta @CARDINAL.DIV.B+3
	jsr @CARDINAL.DIV
	lda :eax
	sta Y
	lda :eax+1
	sta Y+1

; optimize OK (service.pas), line = 860

	ora Y
	jeq @exit
l_0C21

; optimize OK (service.pas), line = 862

	lda X
	cmp #$00
	lda X+1
	sbc #$04
	svc
	eor #$80
	jmi l_0C35
	lda #$FF
	sta X
	lda #$03
	sta X+1
l_0C35

; optimize OK (service.pas), line = 863

	lda Y
	cmp #$00
	lda Y+1
	sbc #$04
	svc
	eor #$80
	jmi l_0C4D
	lda #$FF
	sta Y
	lda #$03
	sta Y+1
l_0C4D

; optimize OK (service.pas), line = 865

	lda SX+1
	jpl l_0C65
	lda #$00
	sub X
	sta X
	lda #$00
	sbc X+1
	sta X+1
l_0C65

; optimize OK (service.pas), line = 866

	lda SY+1
	jpl l_0C81
	lda #$00
	sub Y
	sta Y
	lda #$00
	sbc Y+1
	sta Y+1
l_0C81

; optimize OK (service.pas), line = 868

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda X
	sta (:bp2),y
	iny
	lda X+1
	sta (:bp2),y

; optimize OK (service.pas), line = 869

	ldy #BALL.SPEEDY-DATAORIGIN
	lda Y
	sta (:bp2),y
	iny
	lda Y+1
	sta (:bp2),y

; ------------------------------------------------------------

BALL	= DATAORIGIN+$0232
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019
SPEED	= DATAORIGIN+$0236
SX	= DATAORIGIN+$0238
SY	= DATAORIGIN+$023A
X	= DATAORIGIN+$023C
Y	= DATAORIGIN+$023E
A	= DATAORIGIN+$0240
B	= DATAORIGIN+$0242
LEN	= DATAORIGIN+$0244
I	= DATAORIGIN+$0246

@VarData	= BALL
@VarDataSize	= 22

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SET_BALL_DIRECTION				; PROCEDURE

; optimize OK (service.pas), line = 915

	lda ANGLE
	add #$5A
	sta SINDEG.A
	lda ANGLE+1
	adc #$00
	sta SINDEG.A+1
	jsr SINDEG
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda SINDEG.RESULT
	sta (:bp2),y
	iny
	lda SINDEG.RESULT+1
	sta (:bp2),y

; optimize OK (service.pas), line = 916

	lda ANGLE
	sta SINDEG.A
	lda ANGLE+1
	sta SINDEG.A+1
	jsr SINDEG
	inx
	mva SINDEG.RESULT :STACKORIGIN,x
	mva SINDEG.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	lda #$00
	sub :STACKORIGIN,x
	sta :STACKORIGIN,x
	lda #$00
	sbc :STACKORIGIN+STACKWIDTH,x
	sta :STACKORIGIN+STACKWIDTH,x
	lda #$00
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH*2,x
	lda #$00
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH*3,x
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda :STACKORIGIN,x
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH,x
	sta (:bp2),y
	dex

; ------------------------------------------------------------

BALL	= DATAORIGIN+$024A
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019
ANGLE	= DATAORIGIN+$024E

@VarData	= BALL
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	GET_BALL_DIRECTION				; FUNCTION

; optimize OK (service.pas), line = 959

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda (:bp2),y
	sta ATAN2.X
	iny
	lda (:bp2),y
	sta ATAN2.X+1
	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta ATAN2.Y
	iny
	lda #$00
	sbc (:bp2),y
	sta ATAN2.Y+1
	jsr ATAN2
	ldy ATAN2.RESULT
	lda adr.SCALE360,y
	sta RESULT
	lda adr.SCALE360+256,y
	sta RESULT+1
@exit

; ------------------------------------------------------------

BALL	= DATAORIGIN+$0250
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019
RESULT	= DATAORIGIN+$0254

@VarData	= BALL
@VarDataSize	= 2

	rts						; ret
.endl

.local	START_BALL					; PROCEDURE

; optimize OK (service.pas), line = 969

	mwy BALL :bp2
	ldy #BALL.ONVAUS-DATAORIGIN
	lda VAUS.X
	add (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	adc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.X-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 975

	ldy #BALL.Y-DATAORIGIN
	lda VAUS.Y
	sub #$03
	sta (:bp2),y
	iny
	lda #$00
	sbc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 980

	ldy #BALL.FINEX-DATAORIGIN
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 981

	ldy #BALL.FINEY-DATAORIGIN
	sta (:bp2),y

; optimize OK (service.pas), line = 983

	ldy #BALL.INPLAY-DATAORIGIN
	lda #$01
	sta (:bp2),y

; optimize OK (service.pas), line = 985

	ldy #BALL.SBD-DATAORIGIN
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (service.pas), line = 986

	ldy #BALL.BRWHIT-DATAORIGIN
	sta (:bp2),y

; ------------------------------------------------------------

BALL	= DATAORIGIN+$0256
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019

@VarData	= BALL
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BALL_SPEED					; FUNCTION

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta :bp2
	lda :STACKORIGIN+STACKWIDTH,x
	sta :bp2+1
	ldy #$19
	mva:rpl (:bp2),y adr.BALL,y-
	dex
@main

; optimize OK (service.pas), line = 998

	lda BALL.SPEEDX+1
	jpl l_0D03

; optimize OK (service.pas), line = 999

	lda #$00
	sub BALL.SPEEDX
	sta A
	lda #$00
	sbc BALL.SPEEDX+1
	jmp l_0D15
l_0D03

; optimize OK (service.pas), line = 1001

	lda BALL.SPEEDX
	sta A
	lda BALL.SPEEDX+1
l_0D15
	sta A+1

; optimize OK (service.pas), line = 1003

	lda BALL.SPEEDY+1
	jpl l_0D2B

; optimize OK (service.pas), line = 1004

	lda #$00
	sub BALL.SPEEDY
	sta B
	lda #$00
	sbc BALL.SPEEDY+1
	jmp l_0D3D
l_0D2B

; optimize OK (service.pas), line = 1006

	lda BALL.SPEEDY
	sta B
	lda BALL.SPEEDY+1
l_0D3D
	sta B+1

; optimize OK (service.pas), line = 1008

	lda A
	sta :STACKORIGIN+9
	lda A+1
	and #$03
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	sta :STACKORIGIN+STACKWIDTH+9
	lda #$00
	add :STACKORIGIN+9
	sta :bp2
	lda #$A0
	adc :STACKORIGIN+STACKWIDTH+9
	sta :bp2+1
	lda B
	sta :STACKORIGIN+10
	lda B+1
	and #$03
	asl :STACKORIGIN+10
	rol @
	asl :STACKORIGIN+10
	rol @
	add #$A0
	sta :TMP+1
	lda :STACKORIGIN+10
	sta :TMP
	ldy #$00
	lda (:bp2),y
	add (:TMP),y
	sta I
	iny
	lda (:bp2),y
	adc (:TMP),y
	sta I+1
	iny
	lda (:bp2),y
	adc (:TMP),y
	sta I+2
	iny
	lda (:bp2),y
	adc (:TMP),y
	sta I+3

; optimize OK (service.pas), line = 1010

	lda I
	sta :FPMAN0
	lda I+1
	sta :FPMAN1
	lda I+2
	sta :FPMAN2
	lda I+3
	sta :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta FASTSQRT.X
	lda :FPMAN1
	sta FASTSQRT.X+1
	lda :FPMAN2
	sta FASTSQRT.X+2
	lda :FPMAN3
	sta FASTSQRT.X+3
	jsr FASTSQRT
	inx
	lda FASTSQRT.RESULT
	sta :FPMAN0
	lda FASTSQRT.RESULT+1
	sta :FPMAN1
	lda FASTSQRT.RESULT+2
	sta :FPMAN2
	lda FASTSQRT.RESULT+3
	sta :FPMAN3
	jsr @F2I
	lda :FPMAN0
	sta RESULT
	lda :FPMAN1
	sta RESULT+1
	dex
@exit

; ------------------------------------------------------------

adr.BALL	= DATAORIGIN+$025A	; [26] RECORD
.var BALL	= adr.BALL .word
BALL.X	= DATAORIGIN+$025A
BALL.Y	= DATAORIGIN+$025C
BALL.FINEX	= DATAORIGIN+$025E
BALL.FINEY	= DATAORIGIN+$025F
BALL.OLDX	= DATAORIGIN+$0260
BALL.OLDY	= DATAORIGIN+$0262
BALL.SPEED	= DATAORIGIN+$0264
BALL.FINESPEED	= DATAORIGIN+$0266
BALL.SPEEDX	= DATAORIGIN+$0268
BALL.SPEEDY	= DATAORIGIN+$026A
BALL.SBD	= DATAORIGIN+$026C
BALL.BRWHIT	= DATAORIGIN+$026E
BALL.INPLAY	= DATAORIGIN+$026F
BALL.LAUNCH	= DATAORIGIN+$0270
BALL.ONVAUS	= DATAORIGIN+$0271
BALL.STM	= DATAORIGIN+$0273
RESULT	= DATAORIGIN+$0274
I	= DATAORIGIN+$0276
A	= DATAORIGIN+$027A
B	= DATAORIGIN+$027C

@VarData	= BALL.X
@VarDataSize	= 34

	rts						; ret
.endl

.local	MOVE_BALL					; PROCEDURE

; optimize OK (service.pas), line = 1026

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.FINEX-DATAORIGIN
	lda (:bp2),y
	ldy #BALL.SPEEDX-DATAORIGIN
	add (:bp2),y
	sta X
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	adc (:bp2),y
	sta X+1

; optimize OK (service.pas), line = 1027

	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.FINEY-DATAORIGIN
	lda (:bp2),y
	ldy #BALL.SPEEDY-DATAORIGIN
	add (:bp2),y
	sta Y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	adc (:bp2),y
	sta Y+1

; optimize OK (service.pas), line = 1029

	ldy #BALL.X-DATAORIGIN
	lda X+1
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1030

	ldy #BALL.Y-DATAORIGIN
	lda Y+1
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1032

	ldy #BALL.FINEX-DATAORIGIN
	lda X
	sta (:bp2),y

; optimize OK (service.pas), line = 1033

	ldy #BALL.FINEY-DATAORIGIN
	lda Y
	sta (:bp2),y

; optimize OK (service.pas), line = 1038

	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	cmp #$D9
	jcc l_0DBC

; optimize OK (service.pas), line = 1040

	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 1041

	ldy #BALL.X-DATAORIGIN
	lda #$B0
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$01
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 1042

	ldy #BALL.FINEX-DATAORIGIN
	lda #$FF
	eor (:bp2),y
	sta (:bp2),y
l_0DBC

; optimize OK (service.pas), line = 1048

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	cmp #$0A
	jcs l_0DEF

; optimize OK (service.pas), line = 1050

	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 1051

	ldy #BALL.X-DATAORIGIN
	lda #$14
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 1052

	ldy #BALL.FINEX-DATAORIGIN
	lda #$FF
	eor (:bp2),y
	sta (:bp2),y
l_0DEF

; optimize OK (service.pas), line = 1058

	mwy BALL :bp2
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	cmp #$0C
	jcs l_0E22

; optimize OK (service.pas), line = 1060

	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 1061

	ldy #BALL.Y-DATAORIGIN
	lda #$18
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 1062

	ldy #BALL.FINEY-DATAORIGIN
	lda #$FF
	eor (:bp2),y
	sta (:bp2),y
l_0E22

; optimize OK (service.pas), line = 1071

	mwy BALL :bp2
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	iny
	add #$03
	ldy #1
	cmp #$B8
	seq
	bcs @+
	dey
@
	tya
	sta B0

; optimize OK (service.pas), line = 1072

	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #1
	lda :STACKORIGIN+STACKWIDTH+9
	bmi @+
	ora :STACKORIGIN+9
	sne
@
	dey
@
	tya
	sta B1

; optimize OK (service.pas), line = 1073

	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9

	lda #$B8
	cmp :STACKORIGIN+9
	lda #$00
	rol @
	sta B2

; optimize OK (service.pas), line = 1076

	lda B0
	and B1
	and B2
	jeq l_0E81

; optimize OK (service.pas), line = 1080

	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda VAUS.X
	sub #$03
	cmp :STACKORIGIN+9
	jcs l_0EB0
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+10
	iny
	lda VAUS.X
	add VAUS.WIDTH
	add #$03
	sta :STACKORIGIN+11
	lda :STACKORIGIN+10
	cmp :STACKORIGIN+11
	jcs l_0EB0

; optimize OK (service.pas), line = 1083

	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 1085

	lda VAUS.LETTER
	cmp #$06
	jne l_0ED4
	ldy #BALL.LAUNCH-DATAORIGIN
	lda (:bp2),y
	jne l_0ED4

; optimize OK (service.pas), line = 1087

	ldy #BALL.STM-DATAORIGIN
	sta (:bp2),y

; optimize OK (service.pas), line = 1088

	ldy #BALL.LAUNCH-DATAORIGIN
	lda #$01
	sta (:bp2),y

; optimize OK (service.pas), line = 1089

	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sub VAUS.X
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.ONVAUS-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y
l_0ED4

; optimize OK (service.pas), line = 1093

	lda #$06
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000

; optimize OK (service.pas), line = 1097

	mwy BALL :bp2
	ldy #BALL.BRWHIT-DATAORIGIN
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1098

	ldy #BALL.SBD-DATAORIGIN
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (service.pas), line = 1101

	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda VAUS.X
	add #$0A
	sta :STACKORIGIN+10
	lda :STACKORIGIN+9
	cmp :STACKORIGIN+10
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jpl l_0F0B

; optimize OK (service.pas), line = 1104

	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 1108

	lda BALL
	sta GET_BALL_DIRECTION.BALL
	lda BALL+1
	sta GET_BALL_DIRECTION.BALL+1
	jsr GET_BALL_DIRECTION
	inx
	mva GET_BALL_DIRECTION.RESULT :STACKORIGIN,x
	mva GET_BALL_DIRECTION.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	lda #$1E
	sta RAND.RANGE
	lda #$00
	sta RAND.RANGE+1
	jsr RAND
	lda :STACKORIGIN,x
	add RAND.RESULT
	sta ANGLE
	lda :STACKORIGIN+STACKWIDTH,x
	adc RAND.RESULT+1
	sta ANGLE+1
	dex

; optimize OK (service.pas), line = 1116

	lda #$A0
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda ANGLE
	sta MIN.B
	lda ANGLE+1
	sta MIN.B+1
	jsr MIN
	lda #$78
	sta MAX.A
	lda #$00
	sta MAX.A+1
	lda MIN.RESULT
	sta MAX.B
	lda MIN.RESULT+1
	sta MAX.B+1
	jsr MAX
	lda BALL
	sta SET_BALL_DIRECTION.BALL
	lda BALL+1
	sta SET_BALL_DIRECTION.BALL+1
	lda MAX.RESULT
	sta SET_BALL_DIRECTION.ANGLE
	lda MAX.RESULT+1
	sta SET_BALL_DIRECTION.ANGLE+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 1121

	mwy BALL :bp2
	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED
	iny
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED+1
	lda BALL
	sta SET_BALL_SPEED.BALL
	lda BALL+1
	sta SET_BALL_SPEED.BALL+1
	jsr SET_BALL_SPEED
l_0F0B

; optimize OK (service.pas), line = 1127

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda VAUS.X
	add VAUS.WIDTH
	sub #$0A
	cmp :STACKORIGIN+9
	jcs l_0F4C

; optimize OK (service.pas), line = 1129

	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 1130

	lda BALL
	sta GET_BALL_DIRECTION.BALL
	lda BALL+1
	sta GET_BALL_DIRECTION.BALL+1
	jsr GET_BALL_DIRECTION
	inx
	mva GET_BALL_DIRECTION.RESULT :STACKORIGIN,x
	mva GET_BALL_DIRECTION.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	lda #$1E
	sta RAND.RANGE
	lda #$00
	sta RAND.RANGE+1
	jsr RAND
	lda :STACKORIGIN,x
	sub RAND.RESULT
	sta ANGLE
	lda :STACKORIGIN+STACKWIDTH,x
	sbc RAND.RESULT+1
	sta ANGLE+1
	dex

; optimize OK (service.pas), line = 1131

	lda #$14
	sta MAX.A
	lda #$00
	sta MAX.A+1
	lda ANGLE
	sta MAX.B
	lda ANGLE+1
	sta MAX.B+1
	jsr MAX
	lda #$3C
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda MAX.RESULT
	sta MIN.B
	lda MAX.RESULT+1
	sta MIN.B+1
	jsr MIN
	lda BALL
	sta SET_BALL_DIRECTION.BALL
	lda BALL+1
	sta SET_BALL_DIRECTION.BALL+1
	lda MIN.RESULT
	sta SET_BALL_DIRECTION.ANGLE
	lda MIN.RESULT+1
	sta SET_BALL_DIRECTION.ANGLE+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 1132

	mwy BALL :bp2
	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED
	iny
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED+1
	lda BALL
	sta SET_BALL_SPEED.BALL
	lda BALL+1
	sta SET_BALL_SPEED.BALL+1
	jsr SET_BALL_SPEED
l_0F4C
l_0EB0
l_0E81

; optimize OK (service.pas), line = 1143

	mwy BALL :bp2
	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	ldy #1
	cmp #$B9
	bcs @+
	dey
@
	sty :STACKORIGIN+9
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+10
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+10

	lda :STACKORIGIN+10
	cmp #$C9
	lda #$00
	rol @
	and :STACKORIGIN+9
	sta :STACKORIGIN+9
	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+10
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #1
	lda :STACKORIGIN+STACKWIDTH+10
	bmi @+
	ora :STACKORIGIN+10
	sne
@
	dey
@
	tya
	and :STACKORIGIN+9
	jeq l_0F9B

; optimize OK (service.pas), line = 1145

	ldy #BALL.INPLAY-DATAORIGIN
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1146

	lda BALL
	sta REMOVE_BALL.BALL
	lda BALL+1
	sta REMOVE_BALL.BALL+1
	jsr REMOVE_BALL
l_0F9B

; ------------------------------------------------------------

BALL	= DATAORIGIN+$027E
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019
B0	= DATAORIGIN+$0282
B1	= DATAORIGIN+$0283
B2	= DATAORIGIN+$0284
X	= DATAORIGIN+$0285
Y	= DATAORIGIN+$0287
ANGLE	= DATAORIGIN+$0289

@VarData	= BALL
@VarDataSize	= 11

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MODIFY_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 1154

	lda VAUS.WIDTH
	sta VAUS.OLDLEN

; optimize OK (service.pas), line = 1155

	lda PLAYVAUS.WIDTH
	sta VAUS.WIDTH

; optimize OK (service.pas), line = 1156

	lda PLAYVAUS.HEIGHT
	sta VAUS.HEIGHT

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SET_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 1162

	lda #$5F
	sta VAUS.X

; optimize OK (service.pas), line = 1163

	lda #$B8
	sta VAUS.Y

; optimize OK (service.pas), line = 1170

	lda #$FF
	sta VAUS.OLDX

; optimize OK (service.pas), line = 1171

	sta VAUS.OLDY

; optimize OK (service.pas), line = 1172

	lda #$00
	sta VAUS.IFLASH

; optimize OK (service.pas), line = 1176

	sta VAUS.FLASH

; optimize OK (service.pas), line = 1180

	lda PLAYVAUS.WIDTH
	sta VAUS.WIDTH

; optimize OK (service.pas), line = 1181

	lda PLAYVAUS.HEIGHT
	sta VAUS.HEIGHT

; optimize OK (service.pas), line = 1182

	lda VAUS.WIDTH
	sta VAUS.OLDLEN

; optimize OK (service.pas), line = 1183

	lda #$FF
	sta VAUS.LETTER

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 1210

	ldy VAUS.OLDY
	lda VAUS.OLDX
	add adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 1212

	lda VAUS.OLDLEN
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda VAUS.HEIGHT
	sta BLITBOX.H
	jsr BLITBOX

; optimize OK (service.pas), line = 1214

	lda VAUS.WIDTH
	sta VAUS.OLDLEN

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLACE_VAUS					; PROCEDURE

; optimize FAIL (0, service.pas), line = 1226

	inc VAUS.IFLASH

; optimize OK (service.pas), line = 1228

	lda VAUS.IFLASH
	cmp #$0B
	jcc l_1024

; optimize FAIL (0, service.pas), line = 1230

	inc VAUS.FLASH

; optimize OK (service.pas), line = 1231

	lda #$00
	sta VAUS.IFLASH
l_1024

; optimize OK (service.pas), line = 1234

	lda VAUS.FLASH
	cmp #$0B
	jcc l_1041
	lda #$00
	sta VAUS.FLASH
l_1041

; optimize OK (service.pas), line = 1244

	ldy VAUS.Y
	lda VAUS.X
	add adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 1246

	lda PLAYVAUS.OFS
	sta BLITZERO.SRC
	lda PLAYVAUS.OFS+1
	sta BLITZERO.SRC+1
	lda PLAYVAUS.OFS+2
	sta BLITZERO.SRC+2
	lda PLAYVAUS.OFS+3
	sta BLITZERO.SRC+3
	lda VAUS.WIDTH
	sta BLITZERO.W
	lda #$00
	sta BLITZERO.W+1
	lda VAUS.HEIGHT
	sta BLITZERO.H
	jsr BLITZERO

; -------------------  ASM Block 00000173  -------------------

   fxs FX_MEMS #$80
  
; optimize OK (service.pas), line = 1252

	ldy VAUS.Y
	lda VAUS.X
	add adr.ROW+$02,y
	sta HLP
	lda #$00
	adc adr.ROW+256+$02,y
	sta HLP+1

; optimize OK (service.pas), line = 1254

	lda HLP
	sta VIDEO
	lda HLP+1
	sta VIDEO+1
	lda #$03
	sta VIDEO+2
	lda #$00
	sta VIDEO+3

; optimize OK (service.pas), line = 1256

	lda VAUS.HEIGHT
	sub #$04
	sta Y

; optimize OK (service.pas), line = 1258

	lda #$40
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 1260

	lda #$00
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1261

	ldy VAUS.FLASH
	lda adr.FLASH,y
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1263

	lda VIDEO
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda VIDEO+1
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda VIDEO+2
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda VIDEO+3
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda VIDEO
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda VIDEO+1
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda VIDEO+2
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda VIDEO+3
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda Y
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 1265

	ldy VAUS.WIDTH
	dey
	sty I

; optimize OK (service.pas), line = 1267

	lda VIDEO
	add I
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda VIDEO+1
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda VIDEO+2
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda VIDEO+3
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda VIDEO
	add I
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda VIDEO+1
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda VIDEO+2
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda VIDEO+3
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda Y
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 1269

	lda #$FF
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1270

	lda #$00
	sta BLT.BLT_XOR_MASK

; -------------------  ASM Block 00000174  -------------------

   fxs FX_MEMS #$00
  
; ------------------------------------------------------------

I	= DATAORIGIN+$028B
Y	= DATAORIGIN+$028C
VIDEO	= DATAORIGIN+$028D

@VarData	= I
@VarDataSize	= 6

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MOVE_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 1309

	ldy #1
	lda VAUS.OLDX
	cmp #$FF
	bne @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda VAUS.OLDX
	cmp VAUS.X
	bne @+
	dey
@
	tya
	and :STACKORIGIN+9
	sta :STACKORIGIN+9
	ldy #1
	lda VAUS.WIDTH
	cmp VAUS.OLDLEN
	bne @+
	dey
@
	tya
	ora :STACKORIGIN+9
	jeq l_10F1
	jsr REMOVE_VAUS
l_10F1

; optimize OK (service.pas), line = 1311

	lda VAUS.X
	sta VAUS.OLDX

; optimize OK (service.pas), line = 1312

	lda VAUS.Y
	sta VAUS.OLDY

; optimize OK (service.pas), line = 1320

	lda X
	sta VAUS.X

; optimize OK (service.pas), line = 1321

	lda Y
	sta VAUS.Y

; optimize FAIL ('PLACE_VAUS', service.pas), line = 1323

	jsr PLACE_VAUS

; ------------------------------------------------------------

X	= DATAORIGIN+$0291
Y	= DATAORIGIN+$0292

@VarData	= X
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 1339

	lda XA
	asl @
	asl @
	asl @
	asl @
	add #$09
	sta XS

; optimize OK (service.pas), line = 1340

	lda YA
	asl @
	asl @
	asl @
	add #$16
	sta YS

; optimize OK (service.pas), line = 1342

	tay
	lda adr.ROW,y
	add XS
	sta HLP
	lda adr.ROW+256,y
	adc #$00
	sta HLP+1

; -------------------  ASM Block 00000175  -------------------

	fxs FX_MEMS #$80
    
; optimize OK (service.pas), line = 1349

	lda #$80
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1350

	lda #$00
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1352

	lda #$40
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$10
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$00
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 1353

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$10
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$08
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 1397

	lda #$7F
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1398

	lda #$00
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1400

	lda #$03
	sta BLT.BLT_CONTROL

; optimize OK (service.pas), line = 1402

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$04
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$10
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$08
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 1406

	lda #$FF
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1407

	lda #$00
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1409

	sta BLT.BLT_CONTROL

; optimize OK (service.pas), line = 1415

	lda #$10
	sta BLITSCR.SWIDTH
	lda #$40
	sta BLITSCR.DWIDTH
	lda #$01
	sta BLITSCR.DWIDTH+1
	lda #$10
	sta BLITSCR.W
	lda #$00
	sta BLITSCR.W+1
	lda #$08
	sta BLITSCR.H
	jsr BLITSCR

; optimize OK (service.pas), line = 1425

	lda XS
	add #$08
	sta XS

; optimize OK (service.pas), line = 1426

	ldy YS
	lda adr.ROW+$04,y
	add XS
	sta HLP
	lda adr.ROW+256+$04,y
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 1429

	lda #$7F
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1430

	lda #$80
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1432

	lda #$40
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 1434

	lda XS
	add #$11
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	cmp #$00
	bne @+
	lda :STACKORIGIN+9
	cmp #$D9
@
	jcc l_11AC

; optimize OK (service.pas), line = 1435

	lda #$08
	jmp l_11BA
l_11AC

; optimize OK (service.pas), line = 1437

	lda #$11
l_11BA
	sta I

; optimize OK (service.pas), line = 1442

	sta BLITTEMP2TEMP.W
	lda #$09
	sta BLITTEMP2TEMP.H
	jsr BLITTEMP2TEMP

; optimize OK (service.pas), line = 1492

	lda #$FF
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1493

	lda #$00
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1495

	sta BLT.BLT_CONTROL

; -------------------  ASM Block 00000176  -------------------

	fxs FX_MEMS #$00
    
; ------------------------------------------------------------

XA	= DATAORIGIN+$0293
YA	= DATAORIGIN+$0294
I	= DATAORIGIN+$0295
XS	= DATAORIGIN+$0296
YS	= DATAORIGIN+$0297

@VarData	= XA
@VarDataSize	= 5

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLACE_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 1518

	lda XA
	asl @
	asl @
	asl @
	asl @
	add #$09
	sta XS

; optimize OK (service.pas), line = 1519

	lda YA
	asl @
	asl @
	asl @
	add #$16
	sta YS

; optimize OK (service.pas), line = 1521

	tay
	lda adr.ROW,y
	add XS
	sta HLP
	lda adr.ROW+256,y
	adc #$00
	sta HLP+1

; -------------------  ASM Block 00000177  -------------------

	  fxs FX_MEMS #$80
    
; optimize OK (service.pas), line = 1528

	lda #$40
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 1529

	lda #$80
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1530

	lda #$00
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1534

	lda #$10
	sta BLITTEMP2TEMP.W
	lda #$08
	sta BLITTEMP2TEMP.H
	jsr BLITTEMP2TEMP

; optimize OK (service.pas), line = 1537

	lda #$80
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1538

	lda BLOCK
	sub #$01
	and #$0F
	tay
	lda adr.COLORBLOCK,y
	and #$7F
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1542

	lda #$0F
	sta BLITTEMP2TEMP.W
	lda #$07
	sta BLITTEMP2TEMP.H
	jsr BLITTEMP2TEMP

; optimize OK (service.pas), line = 1544

	lda #$FF
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1545

	lda #$00
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1593

	ldy YS
	lda adr.ROW+$04,y
	add XS
	sta :STACKORIGIN+9
	lda adr.ROW+256+$04,y
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add #$08
	sta HLP
	lda :STACKORIGIN+STACKWIDTH+9
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 1601

	lda #$40
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 1603

	lda #$7F
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1604

	lda #$00
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1606

	lda XS
	add #$19
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	cmp #$00
	bne @+
	lda :STACKORIGIN+9
	cmp #$D9
@
	jcc l_126A

; optimize OK (service.pas), line = 1607

	lda #$08
	jmp l_1278
l_126A

; optimize OK (service.pas), line = 1609

	lda #$11
l_1278
	sta I

; optimize OK (service.pas), line = 1614

	sta BLITTEMP2TEMP.W
	lda #$09
	sta BLITTEMP2TEMP.H
	jsr BLITTEMP2TEMP

; optimize OK (service.pas), line = 1616

	lda #$FF
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 1617

	lda #$00
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 1653

	ldy YS
	lda adr.ROW,y
	add XS
	sta HLP
	lda adr.ROW+256,y
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 1655

	lda #$40
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$10
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$00
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 1656

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$10
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$07
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 1659

	lda BLOCK
	cmp #$09
	jcc l_12B6

; optimize OK (service.pas), line = 1661

	lda #$00
	sta CL2

; optimize OK (service.pas), line = 1662

	lda BLOCK
	and #$0F
	cmp #$09
	jne l_12D1

; optimize OK (service.pas), line = 1664

	lda #$CA
	sta CL2

; optimize OK (service.pas), line = 1665

	lda YA
	asl @
	asl @
	asl @
	asl @
	add XA
	tay
	lda #$19
	sta adr.WALL,y
	jmp l_12F0
l_12D1

; optimize OK (service.pas), line = 1671

	lda BLOCK
	cmp #$0A
	jne l_1302
	lda #$C9
	sta CL2
l_12F0
l_1302

; optimize OK (service.pas), line = 1675

	lda #$00
	sta I

; optimize OK (service.pas), line = 1678

	lda #$06
	sta Y

l_1316
; --- ForToDoCondition
	lda CL2
	and #$7F
	sta :STACKORIGIN+9
	ldy I
	lda adr.SCR,y
	and #$80
	ora :STACKORIGIN+9
	sta CL2

; optimize OK (service.pas), line = 1695

	sta adr.SCR,y

; optimize OK (service.pas), line = 1697

	lda I
	add #$10
	sta I

; --- ForToDoEpilog
	dec Y
	jpl l_1316
l_1324

; optimize OK (service.pas), line = 1703

	lda #$0E
	sta X

l_1353
; --- ForToDoCondition
	lda CL2
	and #$7F
	sta :STACKORIGIN+10
	ldy X
	lda adr.SCR,y
	and #$80
	ora :STACKORIGIN+10
	sta adr.SCR,y

; --- ForToDoEpilog
	dec X
	jpl l_1353
l_1361
l_12B6

; optimize OK (service.pas), line = 1721

	lda #$10
	sta BLITSCR.SWIDTH
	lda #$40
	sta BLITSCR.DWIDTH
	lda #$01
	sta BLITSCR.DWIDTH+1
	lda #$0F
	sta BLITSCR.W
	lda #$00
	sta BLITSCR.W+1
	lda #$07
	sta BLITSCR.H
	jsr BLITSCR

; -------------------  ASM Block 00000178  -------------------

	fxs FX_MEMS #$00
    
; ------------------------------------------------------------

XA	= DATAORIGIN+$0298
YA	= DATAORIGIN+$0299
BLOCK	= DATAORIGIN+$029A
XS	= DATAORIGIN+$029B
YS	= DATAORIGIN+$029C
X	= DATAORIGIN+$029D
Y	= DATAORIGIN+$029E
I	= DATAORIGIN+$029F
CL2	= DATAORIGIN+$02A0

@VarData	= XA
@VarDataSize	= 9

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PUT_WALL					; PROCEDURE

; optimize OK (service.pas), line = 1737

	lda #$00
	sta Y

l_1394
; --- ForToDoCondition
	lda Y
	cmp #$0F
	jcs l_13A2

; optimize OK (service.pas), line = 1739

	asl @
	asl @
	asl @
	asl @
	sta I

; optimize OK (service.pas), line = 1741

	lda #$00
	sta X

l_13B5
; --- ForToDoCondition
	lda X
	cmp #$0D
	jcs l_13C3

; optimize OK (service.pas), line = 1742

	adc I
	tay
	lda adr.WALL,y
	jeq l_13DE
	lda X
	add I
	tay
	lda adr.WALL,y
	sta PLACE_BLOCK.BLOCK
	lda X
	sta PLACE_BLOCK.XA
	lda Y
	sta PLACE_BLOCK.YA
	jsr PLACE_BLOCK
l_13DE

; --- ForToDoEpilog
	inc X
	jne l_13B5
l_13C3

; --- ForToDoEpilog
	inc Y
	jne l_1394
l_13A2

; ------------------------------------------------------------

X	= DATAORIGIN+$02A1
Y	= DATAORIGIN+$02A2
I	= DATAORIGIN+$02A3

@VarData	= X
@VarDataSize	= 3

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SET_WALL					; PROCEDURE

; optimize OK (service.pas), line = 1768

	lda #$00
	sta REMAIN_BLK

; optimize OK (service.pas), line = 1769

	ldy CUR_PLAYER
	lda adr.SCORE.WALL_N,y
	sta WL

; optimize OK (service.pas), line = 1772

	lda #$00
	sta Y

l_1418
; --- ForToDoCondition
	lda Y
	cmp #$0F
	jcs l_1426

; optimize OK (service.pas), line = 1773

	lda #$00
	sta X

l_142F
; --- ForToDoCondition
	lda X
	cmp #$0D
	jcs l_143D

; optimize OK (service.pas), line = 1776

	lda Y
	asl @
	asl @
	asl @
	asl @
	add X
	tay
	lda adr.WALL,y
	jeq l_1475
	lda Y
	asl @
	asl @
	asl @
	asl @
	add X
	tay
	lda adr.WALL,y
	cmp #$0A
	jeq l_1475
	inc REMAIN_BLK
l_1475

; --- ForToDoEpilog
	inc X
	jne l_142F
l_143D

; --- ForToDoEpilog
	inc Y
	jne l_1418
l_1426

; optimize OK (service.pas), line = 1778

	lda WL
	sub #$01
	and #$03
	sta WL

; optimize OK (service.pas), line = 1780

	sta @CASETMP_0008
	cmp #$00
	jne l_149F
@

; optimize OK (service.pas), line = 1781

	:7 mva adr.PATTERN0+# adr.PATTERN+#
	jmp a_0008
l_149F
	cmp #$01
	jne l_14A8

; optimize OK (service.pas), line = 1782

	:7 mva adr.PATTERN1+# adr.PATTERN+#
	jmp a_0008
l_14A8
	cmp #$02
	jne l_14B1

; optimize OK (service.pas), line = 1783

	:7 mva adr.PATTERN2+# adr.PATTERN+#
	jmp a_0008
l_14B1
	cmp #$03
	jne l_14BA

; optimize OK (service.pas), line = 1784

	:7 mva adr.PATTERN3+# adr.PATTERN+#
l_14BA
a_0008

; ------------------------------------------------------------

X	= DATAORIGIN+$02A4
Y	= DATAORIGIN+$02A5
WL	= DATAORIGIN+$02A6
@CASETMP_0008	= DATAORIGIN+$02A7

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SPLIT_LINE					; FUNCTION

; optimize OK (service.pas), line = 1813

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	add #$10
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1814

	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	add #$18
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1815

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	add #$10
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1816

	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	add #$18
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1818

	lda #$00
	sta COLLISION

; optimize OK (service.pas), line = 1820

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	lsr @
	lsr @
	lsr @
	lsr @
	sta XP1

; optimize OK (service.pas), line = 1821

	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	lsr @
	lsr @
	lsr @
	sta YP1

; optimize OK (service.pas), line = 1822

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	lsr @
	lsr @
	lsr @
	lsr @
	sta XP2

; optimize OK (service.pas), line = 1823

	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	lsr @
	lsr @
	lsr @
	sta YP2

; optimize OK (service.pas), line = 1825

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	sta XK

; optimize OK (service.pas), line = 1826

	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	sta YK

; optimize OK (service.pas), line = 1827

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	sta XJ

; optimize OK (service.pas), line = 1828

	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	sta YJ

; optimize OK (service.pas), line = 1830

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	sta XH

; optimize OK (service.pas), line = 1831

	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	sta YH

; optimize OK (service.pas), line = 1832

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	sta XN

; optimize OK (service.pas), line = 1833

	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	sta YN

; optimize OK (service.pas), line = 1843

	ldy #1
	lda XP1
	cmp XP2
	bne @+
	dey
@
	tya
	sta TX

; optimize OK (service.pas), line = 1844

	ldy #1
	lda YP1
	cmp YP2
	bne @+
	dey
@
	tya
	sta TY

; optimize OK (service.pas), line = 1847

	lda TX
	ora TY
	jeq l_1548

; optimize OK (service.pas), line = 1850

	lda TY
	jeq l_1555

; optimize OK (service.pas), line = 1852

	lda COLLISION
	ora #$01
	sta COLLISION

; --- WhileProlog
	jmp l_1562
l_1563

; optimize OK (service.pas), line = 1856

	lda XH
	add XN
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta X

; optimize OK (service.pas), line = 1857

	lda YH
	add YN
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta Y

; optimize OK (service.pas), line = 1859

	lsr @
	lsr @
	lsr @
	sta YP

; optimize OK (service.pas), line = 1861

	cmp YP1
	jne l_15A1

; optimize OK (service.pas), line = 1863

	lda X
	sta XH

; optimize OK (service.pas), line = 1864

	lda Y
	sta YH
l_15A1

; optimize OK (service.pas), line = 1867

	lda YP
	cmp YP2
	jne l_15C4

; optimize OK (service.pas), line = 1869

	lda X
	sta XN

; optimize OK (service.pas), line = 1870

	lda Y
	sta YN
l_15C4
l_1562

; optimize OK (service.pas), line = 1854

	lda YN
	and #$07
	jeq l_1563w
	lda YN
	and #$07
	cmp #$07
	jne l_1563
l_1563w
l_1555

; optimize OK (service.pas), line = 1876

	lda TX
	jeq l_1601

; optimize OK (service.pas), line = 1878

	lda COLLISION
	ora #$02
	sta COLLISION

; --- WhileProlog
	jmp l_160E
l_160F

; optimize OK (service.pas), line = 1882

	lda XK
	add XJ
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta X

; optimize OK (service.pas), line = 1883

	lda YK
	add YJ
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta Y

; optimize OK (service.pas), line = 1885

	lda X
	lsr @
	lsr @
	lsr @
	lsr @
	sta XP

; optimize OK (service.pas), line = 1887

	cmp XP1
	jne l_164D

; optimize OK (service.pas), line = 1889

	lda X
	sta XK

; optimize OK (service.pas), line = 1890

	lda Y
	sta YK
l_164D

; optimize OK (service.pas), line = 1893

	lda XP
	cmp XP2
	jne l_1670

; optimize OK (service.pas), line = 1895

	lda X
	sta XJ

; optimize OK (service.pas), line = 1896

	lda Y
	sta YJ
l_1670
l_160E

; optimize OK (service.pas), line = 1880

	lda XJ
	and #$0F
	jeq l_160Fw
	lda XJ
	and #$0F
	cmp #$0F
	jne l_160F
l_160Fw
l_1601

; optimize OK (service.pas), line = 1907

	lda COLLISION
	cmp #$01
	jne l_16B3
; optimize OK (service.pas), line = 1909
; optimize OK (service.pas), line = 1910
	jmp l_16C9
l_16B3

; optimize OK (service.pas), line = 1912

	lda COLLISION
	cmp #$02
	jne l_16DB

; optimize OK (service.pas), line = 1914

	mwy X2 :bp2
	ldy #$00
	lda XJ
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1915

	mwy Y2 :bp2
	ldy #$00
	lda YJ
	jmp l_16F1
l_16DB

; optimize OK (service.pas), line = 1917

	lda COLLISION
	cmp #$03
	jne l_1703

; optimize OK (service.pas), line = 1919

	mwy X1 :bp2
	ldy #$00
	lda XJ
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1920

	mwy Y1 :bp2
	ldy #$00
	lda YJ
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y
l_16C9

; optimize OK (service.pas), line = 1921

	mwy X2 :bp2
	ldy #$00
	lda XN
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1922

	mwy Y2 :bp2
	ldy #$00
	lda YN
l_16F1
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y
l_1703
	jmp l_1727
l_1548

; optimize OK (service.pas), line = 1927

	lda #$00
	sta RESULT
	jmp @exit
l_1727

; optimize OK (service.pas), line = 1931

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	sub #$10
	sta (:bp2),y
	iny
	lda (:bp2),y
	sbc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1932

	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	sub #$18
	sta (:bp2),y
	iny
	lda (:bp2),y
	sbc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1933

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	sub #$10
	sta (:bp2),y
	iny
	lda (:bp2),y
	sbc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1934

	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	sub #$18
	sta (:bp2),y
	iny
	lda (:bp2),y
	sbc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1938

	mwy X1 :bp2
	ldy #$01
	lda (:bp2),y
	jpl l_1740
	dey
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y
l_1740

; optimize OK (service.pas), line = 1939

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	cmp #$D0
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jmi l_1758
	dey
	lda #$CF
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y
l_1758

; optimize OK (service.pas), line = 1942

	mwy X2 :bp2
	ldy #$01
	lda (:bp2),y
	jpl l_1770
	dey
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y
l_1770

; optimize OK (service.pas), line = 1943

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	iny
	cmp #$D0
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jmi l_1788
	dey
	lda #$CF
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y
l_1788

; optimize OK (service.pas), line = 1950

	lda COLLISION
	sta RESULT
@exit

; ------------------------------------------------------------

X1	= DATAORIGIN+$02A8
Y1	= DATAORIGIN+$02AA
X2	= DATAORIGIN+$02AC
Y2	= DATAORIGIN+$02AE
RESULT	= DATAORIGIN+$02B0
X	= DATAORIGIN+$02B1
Y	= DATAORIGIN+$02B2
XK	= DATAORIGIN+$02B3
YK	= DATAORIGIN+$02B4
XJ	= DATAORIGIN+$02B5
YJ	= DATAORIGIN+$02B6
XH	= DATAORIGIN+$02B7
YH	= DATAORIGIN+$02B8
XN	= DATAORIGIN+$02B9
YN	= DATAORIGIN+$02BA
XP1	= DATAORIGIN+$02BB
YP1	= DATAORIGIN+$02BC
XP2	= DATAORIGIN+$02BD
YP2	= DATAORIGIN+$02BE
XP	= DATAORIGIN+$02BF
YP	= DATAORIGIN+$02C0
COLLISION	= DATAORIGIN+$02C1
TX	= DATAORIGIN+$02C2
TY	= DATAORIGIN+$02C3

@VarData	= X1
@VarDataSize	= 27

	rts						; ret
.endl

.local	SHOOT_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 1962

	lda #$0C
	cmp XB
	jcc l_17B7
	lda #$0E
	cmp YB
	jcc l_17B7

; optimize OK (service.pas), line = 1965

	lda YB
	asl @
	asl @
	asl @
	asl @
	add XB
	sta I

; optimize OK (service.pas), line = 1967

	tay
	lda adr.WALL,y
	jeq l_17DD

; optimize OK (service.pas), line = 1969

	cmp #$0A
	jcs l_17F3

; optimize OK (service.pas), line = 1971

	lda XB
	sta REMOVE_BLOCK.XA
	lda YB
	sta REMOVE_BLOCK.YA
	jsr REMOVE_BLOCK

; optimize FAIL (0, service.pas), line = 1972

	dec REMAIN_BLK

; optimize OK (service.pas), line = 1976

	lda CUR_PLAYER
	asl @
	asl @
	sta :STACKORIGIN+9
	ldy I
	lda adr.WALL,y
	asl @
	tay
	lda adr.SCORE_WALL,y
	sta :STACKORIGIN+10
	lda adr.SCORE_WALL+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy :STACKORIGIN+9
	lda adr.SCORE.PLAYER,y
	add :STACKORIGIN+10
	sta adr.SCORE.PLAYER,y
	lda adr.SCORE.PLAYER+1,y
	adc :STACKORIGIN+STACKWIDTH+10
	sta adr.SCORE.PLAYER+1,y
	lda adr.SCORE.PLAYER+2,y
	adc #$00
	sta adr.SCORE.PLAYER+2,y
	lda adr.SCORE.PLAYER+3,y
	adc #$00
	sta adr.SCORE.PLAYER+3,y

; optimize OK (service.pas), line = 1978

	lda #$2C
	sta RAND.RANGE
	lda #$01
	sta RAND.RANGE+1
	jsr RAND
	lda LETT.INCOMING
	add RAND.RESULT
	sta LETT.INCOMING
	lda LETT.INCOMING+1
	adc RAND.RESULT+1
	sta LETT.INCOMING+1

; optimize OK (service.pas), line = 1980

	lda XB
	asl @
	asl @
	asl @
	asl @
	add #$09
	sta LETT.NEXTX

; optimize OK (service.pas), line = 1981

	lda YB
	add #$01
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	asl :STACKORIGIN+9
	rol :STACKORIGIN+STACKWIDTH+9
	asl :STACKORIGIN+9
	asl :STACKORIGIN+9
	lda :STACKORIGIN+9
	add #$16
	sta LETT.NEXTY

; optimize FAIL ('RANDOM_LETTER_DROP', service.pas), line = 1982

	jsr RANDOM_LETTER_DROP
	lda RANDOM_LETTER_DROP.RESULT
	sta LETT.NEXTTYPE
	lda RANDOM_LETTER_DROP.RESULT+1
	sta LETT.NEXTTYPE+1

; optimize OK (service.pas), line = 1984

	ldy I
	lda #$00
	sta adr.WALL,y

; optimize OK (service.pas), line = 1986

	lda #$07
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000

; optimize OK (service.pas), line = 1988

	mwy BALL :bp2
	ldy #BALL.SBD-DATAORIGIN
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (service.pas), line = 1989

	ldy #BALL.BRWHIT-DATAORIGIN
	sta (:bp2),y
	jmp l_184A
l_17F3

; optimize OK (service.pas), line = 1995

	ldy I
	lda adr.WALL,y
	and #$0F
	cmp #$09
	jne l_1863

; optimize OK (service.pas), line = 1997

	mwy BALL :bp2
	ldy #BALL.BRWHIT-DATAORIGIN
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1998

	ldy I
	lda adr.WALL,y
	sub #$10
	sta adr.WALL,y

; optimize OK (service.pas), line = 2001

	lda #$08
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000

; optimize OK (service.pas), line = 2003

	lda XB
	sta SHINE.XB
	lda YB
	sta SHINE.YB
	jsr SHINE
	jmp l_187E
l_1863

; optimize OK (service.pas), line = 2007

	mwy BALL :bp2
	ldy #BALL.BRWHIT-DATAORIGIN
	lda (:bp2),y
	add #$01
	sta (:bp2),y

; optimize OK (service.pas), line = 2008

	lda XB
	sta SHINE.XB
	lda YB
	sta SHINE.YB
	jsr SHINE

; optimize OK (service.pas), line = 2011

	lda #$09
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000
l_187E
l_184A
l_17DD
l_17B7

; ------------------------------------------------------------

XB	= DATAORIGIN+$02C4
YB	= DATAORIGIN+$02C5
BALL	= DATAORIGIN+$02C6
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019
I	= DATAORIGIN+$02CA

@VarData	= XB
@VarDataSize	= 5

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SHOOT_BLOCK_WITH_FIRE				; PROCEDURE

; optimize OK (service.pas), line = 2024

	lda #$0C
	cmp XB
	jcc l_18AE
	lda #$0E
	cmp YB
	jcc l_18AE

; optimize OK (service.pas), line = 2027

	lda YB
	asl @
	asl @
	asl @
	asl @
	add XB
	sta I

; optimize OK (service.pas), line = 2029

	tay
	lda adr.WALL,y
	jeq l_18D4

; optimize OK (service.pas), line = 2031

	cmp #$0A
	jcs l_18EA

; optimize OK (service.pas), line = 2033

	lda XB
	sta REMOVE_BLOCK.XA
	lda YB
	sta REMOVE_BLOCK.YA
	jsr REMOVE_BLOCK

; optimize FAIL (0, service.pas), line = 2034

	dec REMAIN_BLK

; optimize OK (service.pas), line = 2035

	lda CUR_PLAYER
	asl @
	asl @
	sta :STACKORIGIN+9
	ldy I
	lda adr.WALL,y
	asl @
	tay
	lda adr.SCORE_WALL,y
	sta :STACKORIGIN+10
	lda adr.SCORE_WALL+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy :STACKORIGIN+9
	lda adr.SCORE.PLAYER,y
	add :STACKORIGIN+10
	sta adr.SCORE.PLAYER,y
	lda adr.SCORE.PLAYER+1,y
	adc :STACKORIGIN+STACKWIDTH+10
	sta adr.SCORE.PLAYER+1,y
	lda adr.SCORE.PLAYER+2,y
	adc #$00
	sta adr.SCORE.PLAYER+2,y
	lda adr.SCORE.PLAYER+3,y
	adc #$00
	sta adr.SCORE.PLAYER+3,y

; optimize OK (service.pas), line = 2036

	ldy I
	lda #$00
	sta adr.WALL,y
	jmp l_1911
l_18EA

; optimize OK (service.pas), line = 2044

	ldy I
	lda adr.WALL,y
	and #$0F
	cmp #$09
	jne l_192A

; optimize OK (service.pas), line = 2046

	lda adr.WALL,y
	sub #$10
	sta adr.WALL,y

; optimize OK (service.pas), line = 2049

	lda #$08
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000

; optimize OK (service.pas), line = 2051

	lda XB
	sta SHINE.XB
	lda YB
	sta SHINE.YB
	jsr SHINE
	jmp l_1941
l_192A

; optimize OK (service.pas), line = 2055

	lda XB
	sta SHINE.XB
	lda YB
	sta SHINE.YB
	jsr SHINE

; optimize OK (service.pas), line = 2058

	lda #$09
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000
l_1941
l_1911
l_18D4
l_18AE

; ------------------------------------------------------------

XB	= DATAORIGIN+$02CB
YB	= DATAORIGIN+$02CC
I	= DATAORIGIN+$02CD

@VarData	= XB
@VarDataSize	= 3

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BALL_HIT_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 2096

	lda #$FF
	sta EMERGENCY

; optimize OK (service.pas), line = 2098

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sub #$09
	sta NX
	iny
	lda (:bp2),y
	sbc #$00
	sta NX+1

; optimize OK (service.pas), line = 2099

	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	sub #$16
	sta NY
	iny
	lda (:bp2),y
	sbc #$00
	sta NY+1

; optimize OK (service.pas), line = 2102

	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	sub #$09
	sta OX
	iny
	lda (:bp2),y
	sbc #$00
	sta OX+1

; optimize OK (service.pas), line = 2103

	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	sub #$16
	sta OY
	iny
	lda (:bp2),y
	sbc #$00
	sta OY+1

; optimize OK (service.pas), line = 2105

	lda NX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda NX
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta XB

; optimize OK (service.pas), line = 2106

	lda NY+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda NY
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta YB

; optimize OK (service.pas), line = 2109

	asl @
	asl @
	asl @
	asl @
	add XB
	sta I

; optimize OK (service.pas), line = 2114

	cmp #$11
	jcc l_19C6
	lda XB
	jeq l_19C6
	cmp #$0C
	jcs l_19C6

; optimize OK (service.pas), line = 2115

	ldy I
	lda adr.WALL,y
	jne l_19DC

; optimize OK (service.pas), line = 2117

	lda NX
	and #$0F
	lsr @
	sta X

; optimize OK (service.pas), line = 2118

	lda NY
	and #$07
	sta Y

; optimize OK (service.pas), line = 2121

	lda X
	cmp Y
	jeq l_1A19x
	lda #$07
	sub Y
	cmp X
	jne l_1A19
l_1A19x

; optimize OK (service.pas), line = 2124

	lda #$00
	sta AROUND

; optimize OK (service.pas), line = 2126

	sta DEFLECT

; optimize OK (service.pas), line = 2127

	sta TOUCH

; optimize OK (service.pas), line = 2133

	lda X
	cmp #$07
	jne l_1A38
	lda TOUCH
	ora #$01
	sta TOUCH
l_1A38

; optimize OK (service.pas), line = 2134

	lda Y
	cmp #$07
	jne l_1A57
	lda TOUCH
	ora #$02
	sta TOUCH
l_1A57

; optimize OK (service.pas), line = 2145

	ldy I
	dey
	lda adr.WALL,y
	jeq l_1A7D
	lda AROUND
	ora #$80
	sta AROUND
l_1A7D

; optimize OK (service.pas), line = 2146

	ldy I
	iny
	lda adr.WALL,y
	jeq l_1AA3
	lda AROUND
	ora #$08
	sta AROUND
l_1AA3

; optimize OK (service.pas), line = 2147

	lda I
	sub #$10
	tay
	lda adr.WALL,y
	jeq l_1AC9
	lda AROUND
	ora #$02
	sta AROUND
l_1AC9

; optimize OK (service.pas), line = 2148

	lda I
	add #$10
	tay
	lda adr.WALL,y
	jeq l_1AEF
	lda AROUND
	ora #$20
	sta AROUND
l_1AEF

; optimize OK (service.pas), line = 2150

	lda AROUND
	jeq l_1B0E

; optimize OK (service.pas), line = 2152

	lda I
	sub #$11
	tay
	lda adr.WALL,y
	jeq l_1B2C
	lda AROUND
	ora #$01
	sta AROUND
l_1B2C

; optimize OK (service.pas), line = 2153

	lda I
	add #$F1
	tay
	lda adr.WALL,y
	jeq l_1B56
	lda AROUND
	ora #$04
	sta AROUND
l_1B56

; optimize OK (service.pas), line = 2154

	lda I
	add #$0F
	tay
	lda adr.WALL,y
	jeq l_1B80
	lda AROUND
	ora #$40
	sta AROUND
l_1B80

; optimize OK (service.pas), line = 2155

	lda I
	add #$11
	tay
	lda adr.WALL,y
	jeq l_1BAA
	lda AROUND
	ora #$10
	sta AROUND
l_1BAA

; optimize OK (service.pas), line = 2158

	lda TOUCH
	sta @CASETMP_0009
	jne l_1BC2
@

; optimize OK (service.pas), line = 2160

	lda AROUND
	and #$83
	cmp #$82
	jne l_1BD8

; optimize OK (service.pas), line = 2162

	lda #$11
	sta DEFLECT

; optimize OK (service.pas), line = 2164

	ldy YB
	dey
	sty SHOOT_BLOCK.YB
	lda XB
	sta SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK

; optimize OK (service.pas), line = 2165

	ldy XB
	dey
	sty SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_1BD8
	jmp a_0009
l_1BC2
	cmp #$01
	jne l_1C00

; optimize OK (service.pas), line = 2169

	lda AROUND
	and #$0E
	cmp #$0A
	jne l_1C16

; optimize OK (service.pas), line = 2171

	lda #$21
	sta DEFLECT

; optimize OK (service.pas), line = 2173

	ldy YB
	dey
	sty SHOOT_BLOCK.YB
	lda XB
	sta SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK

; optimize OK (service.pas), line = 2174

	ldy XB
	iny
	sty SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_1C16
	jmp a_0009
l_1C00
	cmp #$02
	jne l_1C3E

; optimize OK (service.pas), line = 2178

	lda AROUND
	and #$E0
	cmp #$A0
	jne l_1C54

; optimize OK (service.pas), line = 2180

	lda #$12
	sta DEFLECT

; optimize OK (service.pas), line = 2182

	ldy XB
	dey
	sty SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK

; optimize OK (service.pas), line = 2183

	ldy YB
	iny
	sty SHOOT_BLOCK.YB
	lda XB
	sta SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_1C54
	jmp a_0009
l_1C3E
	cmp #$03
	jne l_1C7C

; optimize OK (service.pas), line = 2187

	lda AROUND
	and #$38
	cmp #$28
	jne l_1C92

; optimize OK (service.pas), line = 2189

	lda #$22
	sta DEFLECT

; optimize OK (service.pas), line = 2191

	ldy XB
	iny
	sty SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK

; optimize OK (service.pas), line = 2192

	ldy YB
	iny
	sty SHOOT_BLOCK.YB
	lda XB
	sta SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_1C92
l_1C7C
a_0009

; optimize OK (service.pas), line = 2199

	lda DEFLECT
	jeq l_1CCB

; optimize OK (service.pas), line = 2201

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 2202

	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y
	jmp @exit
l_1CCB
l_1B0E
l_1A19
l_19DC
l_19C6

; optimize OK (service.pas), line = 2216

	ldy I
	lda adr.WALL,y
	jeq l_1CFB

; optimize OK (service.pas), line = 2219

	lda <OX
	sta SPLIT_LINE.X1
	lda >OX
	sta SPLIT_LINE.X1+1
	lda <OY
	sta SPLIT_LINE.Y1
	lda >OY
	sta SPLIT_LINE.Y1+1
	lda <NX
	sta SPLIT_LINE.X2
	lda >NX
	sta SPLIT_LINE.X2+1
	lda <NY
	sta SPLIT_LINE.Y2
	lda >NY
	sta SPLIT_LINE.Y2+1
	jsr SPLIT_LINE
	lda SPLIT_LINE.RESULT
	sta COLLISION

; optimize OK (service.pas), line = 2225

	jne l_1D16
	lda #$FF
	jsr FATAL_ERROR
l_1D16

; optimize OK (service.pas), line = 2228

	lda COLLISION
	cmp #$03
	jne l_1D2D

; optimize OK (service.pas), line = 2230

	mwy BALL :bp2
	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	iny
	sub OX
	sub #$09
	sta LX

; optimize OK (service.pas), line = 2231

	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	iny
	sub OY
	sub #$16
	sta LY

; optimize OK (service.pas), line = 2233

	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	iny
	sub NX
	sub #$09
	sta MX

; optimize OK (service.pas), line = 2234

	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	iny
	sub NY
	sub #$16
	sta MY

; optimize OK (service.pas), line = 2236

	lda LX
	jpl l_1D78

; optimize OK (service.pas), line = 2237

	lda #$00
	sub LX
	jmp l_1D8B
l_1D78

; optimize OK (service.pas), line = 2239

	lda LX
l_1D8B
	sta A

; optimize OK (service.pas), line = 2241

	lda LY
	jpl l_1DA3

; optimize OK (service.pas), line = 2242

	lda #$00
	sub LY
	jmp l_1DB6
l_1DA3

; optimize OK (service.pas), line = 2244

	lda LY
l_1DB6
	sta B

; optimize OK (service.pas), line = 2246

	lda #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda A
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	sta :bp2
	lda #$A0
	add :STACKORIGIN+STACKWIDTH+9
	sta :bp2+1
	ldy #$00
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	lda #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda B
	asl @
	rol :STACKORIGIN+STACKWIDTH+10
	asl @
	rol :STACKORIGIN+STACKWIDTH+10
	sta :bp2
	lda #$A0
	add :STACKORIGIN+STACKWIDTH+10
	sta :bp2+1
	dey
	lda :STACKORIGIN+9
	add (:bp2),y
	sta F1
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	adc (:bp2),y
	sta F1+1

; optimize OK (service.pas), line = 2248

	lda MX
	jpl l_1DDE

; optimize OK (service.pas), line = 2249

	lda #$00
	sub MX
	jmp l_1DF1
l_1DDE

; optimize OK (service.pas), line = 2251

	lda MX
l_1DF1
	sta A

; optimize OK (service.pas), line = 2253

	lda MY
	jpl l_1E09

; optimize OK (service.pas), line = 2254

	lda #$00
	sub MY
	jmp l_1E1C
l_1E09

; optimize OK (service.pas), line = 2256

	lda MY
l_1E1C
	sta B

; optimize OK (service.pas), line = 2258

	lda #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda A
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	sta :bp2
	lda #$A0
	add :STACKORIGIN+STACKWIDTH+9
	sta :bp2+1
	ldy #$00
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	lda #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda B
	asl @
	rol :STACKORIGIN+STACKWIDTH+10
	asl @
	rol :STACKORIGIN+STACKWIDTH+10
	sta :bp2
	lda #$A0
	add :STACKORIGIN+STACKWIDTH+10
	sta :bp2+1
	dey
	lda :STACKORIGIN+9
	add (:bp2),y
	sta F2
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	adc (:bp2),y
	sta F2+1

; optimize OK (service.pas), line = 2260

	lda F1+1
	cmp F2+1
	bne @+
	lda F1
	cmp F2
@
	jcs l_1E44

; optimize OK (service.pas), line = 2266

	lda OX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda OX
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta XB

; optimize OK (service.pas), line = 2268

	cmp #$0D
	jcc l_1E60
	lda #$0C
	sta XB
l_1E60

; optimize OK (service.pas), line = 2269

	lda OY
	add #$18
	lsr @
	lsr @
	lsr @
	sub #$03
	sta YB

; optimize OK (service.pas), line = 2272

	asl @
	asl @
	asl @
	asl @
	add XB
	tay
	lda adr.WALL,y
	jne l_1E97

; optimize OK (service.pas), line = 2274

	lda NX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda NX
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta XB

; optimize OK (service.pas), line = 2276

	cmp #$0D
	jcc l_1EB3
	lda #$0C
	sta XB
l_1EB3

; optimize OK (service.pas), line = 2277

	lda NY
	add #$18
	lsr @
	lsr @
	lsr @
	sub #$03
	sta YB
	jmp l_1ED4
l_1E97

; optimize OK (service.pas), line = 2281

	lda OX
	sta NX
	lda OX+1
	sta NX+1

; optimize OK (service.pas), line = 2282

	lda OY
	sta NY
	lda OY+1
	sta NY+1
l_1ED4
	jmp l_1EE7
l_1E44

; optimize OK (service.pas), line = 2291

	lda NX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda NX
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta XB

; optimize OK (service.pas), line = 2293

	cmp #$0D
	jcc l_1F02
	lda #$0C
	sta XB
l_1F02

; optimize OK (service.pas), line = 2294

	lda NY
	add #$18
	lsr @
	lsr @
	lsr @
	sub #$03
	sta YB

; optimize OK (service.pas), line = 2296

	asl @
	asl @
	asl @
	asl @
	add XB
	tay
	lda adr.WALL,y
	jne l_1F39

; optimize OK (service.pas), line = 2298

	lda OX
	sta NX
	lda OX+1
	sta NX+1

; optimize OK (service.pas), line = 2299

	lda OY
	sta NY
	lda OY+1
	sta NY+1

; optimize OK (service.pas), line = 2301

	lda NX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda NX
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta XB

; optimize OK (service.pas), line = 2303

	cmp #$0D
	jcc l_1F5F
	lda #$0C
	sta XB
l_1F5F

; optimize OK (service.pas), line = 2304

	lda NY
	add #$18
	lsr @
	lsr @
	lsr @
	sub #$03
	sta YB
l_1F39
l_1EE7
l_1D2D

; optimize OK (service.pas), line = 2310

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda NX
	add #$09
	sta (:bp2),y
	iny
	lda NX+1
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 2311

	ldy #BALL.Y-DATAORIGIN
	lda NY
	add #$16
	sta (:bp2),y
	iny
	lda NY+1
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 2316

	lda NX
	and #$0F
	lsr @
	sta X

; optimize OK (service.pas), line = 2317

	lda NY
	and #$07
	sta Y

; optimize OK (service.pas), line = 2344

	cmp X
	jcs l_1FC9
	lda #$07
	sub Y
	sta :STACKORIGIN+11
	lda X
	cmp :STACKORIGIN+11
	jcs l_1FC9

; optimize OK (service.pas), line = 2346

	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 2347

	lda #$01
	sta EMERGENCY
l_1FC9

; optimize OK (service.pas), line = 2351

	lda #$07
	sub Y
	cmp X
	jcs l_1FFE
	lda X
	cmp Y
	jcs l_1FFE

; optimize OK (service.pas), line = 2353

	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 2354

	lda #$03
	sta EMERGENCY
l_1FFE

; optimize OK (service.pas), line = 2358

	lda X
	cmp Y
	jcs l_2033
	lda #$07
	sub X
	sta :STACKORIGIN+11
	lda Y
	cmp :STACKORIGIN+11
	jcs l_2033

; optimize OK (service.pas), line = 2360

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 2361

	lda #$02
	sta EMERGENCY
l_2033

; optimize OK (service.pas), line = 2365

	lda #$07
	sub X
	cmp Y
	jcs l_2068
	lda Y
	cmp X
	jcs l_2068

; optimize OK (service.pas), line = 2367

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y

; optimize OK (service.pas), line = 2368

	lda #$04
	sta EMERGENCY
l_2068

; optimize OK (service.pas), line = 2372

	lda X
	cmp Y
	beq @+
	jmp *+6
@\	jmp l_2097s
	lda #$07
	sub Y
	cmp X
	beq @+
	jmp *+6
@\	jmp l_2097s
	lda:seq #$00
l_2097s	lda #$01
	sta YES

; optimize OK (service.pas), line = 2374

	jne l_20B5
	lda EMERGENCY
	cmp #$05
	jcs l_20B5
	lda XB
	sta SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_20B5

; optimize OK (service.pas), line = 2379

	lda YES
	jeq l_20CD

; optimize OK (service.pas), line = 2382

	lda #$00
	sta DEFLECT

; optimize OK (service.pas), line = 2383

	sta TOUCH

; optimize OK (service.pas), line = 2384

	sta AROUND

; optimize OK (service.pas), line = 2392

	lda X
	cmp #$05
	jcc l_20EC
	lda TOUCH
	ora #$01
	sta TOUCH
l_20EC

; optimize OK (service.pas), line = 2393

	lda Y
	cmp #$05
	jcc l_210B
	lda TOUCH
	ora #$02
	sta TOUCH
l_210B

; optimize OK (service.pas), line = 2402

	lda #$FF
	sta LX

l_2121
; --- ForToDoCondition
	lda LX
	sub #$02
	svc
	eor #$80
	asl @
	jcc l_212F

; optimize OK (service.pas), line = 2403

	lda #$FF
	sta LY

l_2138
; --- ForToDoCondition
	lda LY
	sub #$02
	svc
	eor #$80
	asl @
	jcc l_2146

; optimize OK (service.pas), line = 2407

	lda XB
	add LX
	sta MX

; optimize OK (service.pas), line = 2411

	lda YB
	add LY
	sta MY

; optimize OK (service.pas), line = 2413

	lda MX
	jmi l_2195x
	sub #$0D
	svc
	eor #$80
	jpl l_2195x
	lda MY
	asl @
	asl @
	asl @
	asl @
	add MX
	tay
	lda adr.WALL,y
	jeq l_2195
l_2195x

; optimize OK (service.pas), line = 2416

	lda LX
	add #$01
	asl @
	asl @
	add LY
	add #$01
	tay
	lda #$0A
	jmp l_21B8
l_2195

; optimize OK (service.pas), line = 2418

	lda LX
	add #$01
	asl @
	asl @
	add LY
	add #$01
	tay
	lda #$14
l_21B8
	sta adr.ADJW,y

; --- ForToDoEpilog
	inc LY
	lda LY
	cmp #$80
	jne l_2138
l_2146

; --- ForToDoEpilog
	inc LX
	lda LX
	cmp #$80
	jne l_2121
l_212F

; -------------------  ASM Block 00000179  -------------------

	lda #10

	cmp adr.ADJW
	ror around
	cmp adr.ADJW+$04
	ror around
	cmp adr.ADJW+$08
	ror around	
	cmp adr.ADJW+$09
	ror around
	cmp adr.ADJW+$0A
	ror around
	cmp adr.ADJW+$06
	ror around
	cmp adr.ADJW+$02
	ror around
	cmp adr.ADJW+$01
	ror around
	
; optimize OK (service.pas), line = 2497

	lda TOUCH
	jne l_21ED

; optimize OK (service.pas), line = 2499

	lda AROUND
	and #$83
	sta A

; optimize OK (service.pas), line = 2501

	sta @CASETMP_000A
	cmp #$00
	jne l_2203
@

; optimize OK (service.pas), line = 2503

	lda #$11
	sta DEFLECT
	jmp a_000A
l_2203
	cmp #$01
	jne l_220E

; optimize OK (service.pas), line = 2504

	lda #$33
	sta DEFLECT
	ldy YB
	dey
	sty SHOOT_BLOCK.YB
	ldy XB
	dey
	sty SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
	jmp a_000A
l_220E
	cmp #$02
	jne l_222A

; optimize OK (service.pas), line = 2505

	lda #$10
	sta DEFLECT
	jmp a_000A
l_222A
	cmp #$03
	jne l_2235

; optimize OK (service.pas), line = 2506

	lda #$12
	sta DEFLECT
	ldy YB
	dey
	sty SHOOT_BLOCK.YB
	ldy XB
	dey
	sty SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
	jmp a_000A
l_2235
	cmp #$80
	jne l_2251

; optimize OK (service.pas), line = 2507

	lda #$01
	sta DEFLECT
	jmp a_000A
l_2251
	cmp #$81
	jne l_225C

; optimize OK (service.pas), line = 2508

	lda #$21
	sta DEFLECT
	ldy YB
	dey
	sty SHOOT_BLOCK.YB
	ldy XB
	dey
	sty SHOOT_BLOCK.XB
	jmp s_2296
l_225C
	cmp #$82
	jne l_2278

; optimize OK (service.pas), line = 2509

	lda #$11
	sta DEFLECT
	ldy XB
	dey
	sty SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
	ldy YB
	dey
	sty SHOOT_BLOCK.YB
	lda XB
	sta SHOOT_BLOCK.XB
s_2296
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_2278
a_000A

; optimize OK (service.pas), line = 2513

	lda A
	cmp #$82
	jeq l_22B1
	lda XB
	sta SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_22B1

; optimize OK (service.pas), line = 2515

	lda #$05
	sta EMERGENCY
l_21ED

; optimize OK (service.pas), line = 2521

	lda TOUCH
	cmp #$01
	jne l_22D5

; optimize OK (service.pas), line = 2523

	lda AROUND
	and #$0E
	sta A

; optimize OK (service.pas), line = 2525

	sta @CASETMP_000B
	cmp #$00
	jne l_22EB
@

; optimize OK (service.pas), line = 2527

	lda #$21
	sta DEFLECT
	jmp a_000B
l_22EB
	cmp #$02
	jne l_22F6

; optimize OK (service.pas), line = 2528

	lda #$20
	sta DEFLECT
	jmp a_000B
l_22F6
	cmp #$04
	jne l_2301

; optimize OK (service.pas), line = 2529

	lda #$33
	jmp s_2332
l_2301
	cmp #$06
	jne l_231D

; optimize OK (service.pas), line = 2530

	lda #$22
s_2332
	sta DEFLECT
	ldy YB
	dey
	sty SHOOT_BLOCK.YB
	ldy XB
	iny
	sty SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
	jmp a_000B
l_231D
	cmp #$08
	jne l_2339

; optimize OK (service.pas), line = 2531

	lda #$01
	sta DEFLECT
	jmp a_000B
l_2339
	cmp #$0A
	jne l_2344

; optimize OK (service.pas), line = 2532

	lda #$21
	sta DEFLECT
	ldy YB
	dey
	sty SHOOT_BLOCK.YB
	lda XB
	sta SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
	ldy XB
	iny
	sty SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	jmp s_237E
l_2344
	cmp #$0C
	jne l_2369

; optimize OK (service.pas), line = 2533

	lda #$11
	sta DEFLECT
	ldy YB
	dey
	sty SHOOT_BLOCK.YB
	ldy XB
	iny
	sty SHOOT_BLOCK.XB
s_237E
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_2369
a_000B

; optimize OK (service.pas), line = 2537

	lda A
	cmp #$0A
	jeq l_2399
	lda XB
	sta SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_2399

; optimize OK (service.pas), line = 2539

	lda #$08
	sta EMERGENCY
l_22D5

; optimize OK (service.pas), line = 2543

	lda TOUCH
	cmp #$02
	jne l_23BD

; optimize OK (service.pas), line = 2545

	lda AROUND
	and #$E0
	sta A

; optimize OK (service.pas), line = 2547

	sta @CASETMP_000C
	cmp #$00
	jne l_23D3
@

; optimize OK (service.pas), line = 2549

	lda #$12
	sta DEFLECT
	jmp a_000C
l_23D3
	cmp #$20
	jne l_23DE

; optimize OK (service.pas), line = 2550

	lda #$10
	sta DEFLECT
	jmp a_000C
l_23DE
	cmp #$40
	jne l_23E9

; optimize OK (service.pas), line = 2551

	lda #$33
	jmp s_241A
l_23E9
	cmp #$60
	jne l_2405

; optimize OK (service.pas), line = 2552

	lda #$11
s_241A
	sta DEFLECT
	ldy YB
	iny
	sty SHOOT_BLOCK.YB
	ldy XB
	dey
	sty SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
	jmp a_000C
l_2405
	cmp #$80
	jne l_2421

; optimize OK (service.pas), line = 2553

	lda #$02
	sta DEFLECT
	jmp a_000C
l_2421
	cmp #$A0
	jne l_242C

; optimize OK (service.pas), line = 2554

	lda #$12
	sta DEFLECT
	ldy XB
	dey
	sty SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
	ldy YB
	iny
	sty SHOOT_BLOCK.YB
	lda XB
	sta SHOOT_BLOCK.XB
	jmp s_2466
l_242C
	cmp #$C0
	jne l_2451

; optimize OK (service.pas), line = 2555

	lda #$22
	sta DEFLECT
	ldy YB
	iny
	sty SHOOT_BLOCK.YB
	ldy XB
	dey
	sty SHOOT_BLOCK.XB
s_2466
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_2451
a_000C

; optimize OK (service.pas), line = 2559

	lda A
	cmp #$A0
	jeq l_2481
	lda XB
	sta SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_2481

; optimize OK (service.pas), line = 2561

	lda #$06
	sta EMERGENCY
l_23BD

; optimize OK (service.pas), line = 2565

	lda TOUCH
	cmp #$03
	jne l_24A5

; optimize OK (service.pas), line = 2567

	lda AROUND
	and #$38
	sta A

; optimize OK (service.pas), line = 2569

	sta @CASETMP_000D
	cmp #$00
	jne l_24BB
@

; optimize OK (service.pas), line = 2571

	lda #$22
	sta DEFLECT
	jmp a_000D
l_24BB
	cmp #$08
	jne l_24C6

; optimize OK (service.pas), line = 2572

	lda #$02
	sta DEFLECT
	jmp a_000D
l_24C6
	cmp #$10
	jne l_24D1

; optimize OK (service.pas), line = 2573

	lda #$33
	jmp s_2502
l_24D1
	cmp #$18
	jne l_24ED

; optimize OK (service.pas), line = 2574

	lda #$12
s_2502
	sta DEFLECT
	ldy YB
	iny
	sty SHOOT_BLOCK.YB
	ldy XB
	iny
	sty SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
	jmp a_000D
l_24ED
	cmp #$20
	jne l_2509

; optimize OK (service.pas), line = 2575

	lda #$20
	sta DEFLECT
	jmp a_000D
l_2509
	cmp #$28
	jne l_2514

; optimize OK (service.pas), line = 2576

	lda #$22
	sta DEFLECT
	ldy XB
	iny
	sty SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
	ldy YB
	iny
	sty SHOOT_BLOCK.YB
	lda XB
	sta SHOOT_BLOCK.XB
	jmp s_254E
l_2514
	cmp #$30
	jne l_2539

; optimize OK (service.pas), line = 2577

	lda #$21
	sta DEFLECT
	ldy YB
	iny
	sty SHOOT_BLOCK.YB
	ldy XB
	iny
	sty SHOOT_BLOCK.XB
s_254E
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_2539
a_000D

; optimize OK (service.pas), line = 2581

	lda A
	cmp #$28
	jeq l_2569
	lda XB
	sta SHOOT_BLOCK.XB
	lda YB
	sta SHOOT_BLOCK.YB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_2569

; optimize OK (service.pas), line = 2583

	lda #$07
	sta EMERGENCY
l_24A5

; optimize OK (service.pas), line = 2589

	lda DEFLECT
	lsr @
	lsr @
	lsr @
	lsr @
	sta MYX

; optimize OK (service.pas), line = 2590

	lda DEFLECT
	and #$0F
	sta MYY

; optimize OK (service.pas), line = 2592

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN+1
	lda (:bp2),y
	jpl l_25A0

; optimize OK (service.pas), line = 2593

	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta SP
	iny
	lda #$00
	sbc (:bp2),y
	jmp l_25B2
l_25A0

; optimize OK (service.pas), line = 2595

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda (:bp2),y
	sta SP
	iny
	lda (:bp2),y
l_25B2
	sta SP+1

; optimize OK (service.pas), line = 2597

	lda MYX
	cmp #$01
	jne l_25C9
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub SP
	sta (:bp2),y
	iny
	lda #$00
	sbc SP+1
	sta (:bp2),y
l_25C9

; optimize OK (service.pas), line = 2598

	lda MYX
	cmp #$02
	jne l_25E6
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda SP
	sta (:bp2),y
	iny
	lda SP+1
	sta (:bp2),y
l_25E6

; optimize OK (service.pas), line = 2599

	lda MYX
	cmp #$03
	jne l_2600
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y
l_2600

; optimize OK (service.pas), line = 2601

	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN+1
	lda (:bp2),y
	jpl l_261C

; optimize OK (service.pas), line = 2602

	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta SP
	iny
	lda #$00
	sbc (:bp2),y
	jmp l_262E
l_261C

; optimize OK (service.pas), line = 2604

	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta SP
	iny
	lda (:bp2),y
l_262E
	sta SP+1

; optimize OK (service.pas), line = 2606

	lda MYY
	cmp #$01
	jne l_2645
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub SP
	sta (:bp2),y
	iny
	lda #$00
	sbc SP+1
	sta (:bp2),y
l_2645

; optimize OK (service.pas), line = 2607

	lda MYY
	cmp #$02
	jne l_2662
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda SP
	sta (:bp2),y
	iny
	lda SP+1
	sta (:bp2),y
l_2662

; optimize OK (service.pas), line = 2608

	lda MYY
	cmp #$03
	jne l_267C
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta (:bp2),y
	iny
	lda #$00
	sbc (:bp2),y
	sta (:bp2),y
l_267C
l_20CD
l_1CFB

; optimize OK (service.pas), line = 2618

	mwy BALL :bp2
	ldy #BALL.BRWHIT-DATAORIGIN
	lda (:bp2),y
	cmp #$65
	jcc l_269D

; optimize OK (service.pas), line = 2621

	lda EMERGENCY
	cmp #$FF
	jne l_26B0
	lda #$04
	jsr FATAL_ERROR
l_26B0

; optimize OK (service.pas), line = 2623

	ldy EMERGENCY
	lda adr.EMERG_DEV,y
	sta MIMAX

; optimize OK (service.pas), line = 2662

	tya
	sta @CASETMP_000E
	cmp #$05
	jne l_26C9
@

; optimize OK (service.pas), line = 2665

	lda AROUND
	and #$02
	jne l_26DF
	lda MIMAX
	and #$0F
	sta MIMAX
l_26DF

; optimize OK (service.pas), line = 2666

	lda AROUND
	jmi l_2706
	lda MIMAX
	and #$F0
	ora #$03
	sta MIMAX
l_2706
	jmp a_000E
l_26C9
	cmp #$06
	jne l_271E

; optimize OK (service.pas), line = 2670

	lda AROUND
	jmi l_2734
	lda MIMAX
	and #$0F
	ora #$10
	sta MIMAX
l_2734

; optimize OK (service.pas), line = 2671

	lda AROUND
	and #$20
	jne l_275B
	lda MIMAX
	and #$F0
	ora #$04
	sta MIMAX
l_275B
	jmp a_000E
l_271E
	cmp #$07
	jne l_2773

; optimize OK (service.pas), line = 2675

	lda AROUND
	and #$20
	jne l_2789
	lda MIMAX
	and #$0F
	ora #$20
	sta MIMAX
l_2789

; optimize OK (service.pas), line = 2676

	lda AROUND
	and #$08
	jne l_27B0
	lda MIMAX
	and #$F0
	ora #$05
	sta MIMAX
l_27B0
	jmp a_000E
l_2773
	cmp #$08
	jne l_27C8

; optimize OK (service.pas), line = 2680

	lda AROUND
	and #$08
	jne l_27DE
	lda MIMAX
	and #$0F
	ora #$30
	sta MIMAX
l_27DE

; optimize OK (service.pas), line = 2681

	lda AROUND
	and #$02
	jne l_2805
	lda MIMAX
	and #$F0
	ora #$06
	sta MIMAX
l_2805
l_27C8
a_000E

; --- RepeatUntilProlog
l_281D

; optimize OK (service.pas), line = 2689

	lda MIMAX
	lsr @
	lsr @
	lsr @
	lsr @
	tay
	lda adr.MUL90_16,y
	sta OX
	lda adr.MUL90_16+16,y
	sta OX+1

; optimize OK (service.pas), line = 2690

	lda MIMAX
	and #$0F
	tay
	lda adr.MUL90_16,y
	sta OY
	lda adr.MUL90_16+16,y
	sta OY+1

; optimize OK (service.pas), line = 2692

	lda OY
	sub OX
	sta RAND.RANGE
	lda OY+1
	sbc OX+1
	sta RAND.RANGE+1
	jsr RAND
	lda RAND.RESULT
	add OX
	sta ANGLE
	lda RAND.RESULT+1
	adc OX+1
	sta ANGLE+1

; optimize OK (service.pas), line = 2694

	lda ANGLE
	sta MOD90.A
	lda ANGLE+1
	sta MOD90.A+1
	jsr MOD90
	inx
	ldy #1
	lda MOD90.RESULT
	cmp #$1F
	lda MOD90.RESULT+1
	sbc #$00
	svc
	eor #$80
	bpl @+
	dey
@
	sty :STACKORIGIN,x
	lda ANGLE
	sta MOD90.A
	lda ANGLE+1
	sta MOD90.A+1
	jsr MOD90
	dex
	ldy #1
	lda MOD90.RESULT
	cmp #$3C
	lda MOD90.RESULT+1
	sbc #$00
	svc
	eor #$80
	bmi @+
	dey
@
	tya
	and :STACKORIGIN+1,x
	jeq l_281D

; optimize OK (service.pas), line = 2698

	lda ANGLE
	sta MOD360.A
	lda ANGLE+1
	sta MOD360.A+1
	jsr MOD360
	lda BALL
	sta SET_BALL_DIRECTION.BALL
	lda BALL+1
	sta SET_BALL_DIRECTION.BALL+1
	lda MOD360.RESULT
	sta SET_BALL_DIRECTION.ANGLE
	lda MOD360.RESULT+1
	sta SET_BALL_DIRECTION.ANGLE+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 2699

	mwy BALL :bp2
	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED
	iny
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED+1
	lda BALL
	sta SET_BALL_SPEED.BALL
	lda BALL+1
	sta SET_BALL_SPEED.BALL+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 2701

	mwy BALL :bp2
	ldy #BALL.BRWHIT-DATAORIGIN
	lda #$00
	sta (:bp2),y
l_269D

; ------------------------------------------------------------

BALL	= DATAORIGIN+$02CE
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019
X	= DATAORIGIN+$02D2
Y	= DATAORIGIN+$02D3
I	= DATAORIGIN+$02D4
XB	= DATAORIGIN+$02D5
YB	= DATAORIGIN+$02D6
SP	= DATAORIGIN+$02D7
ANGLE	= DATAORIGIN+$02D9
OX	= DATAORIGIN+$02DB
OY	= DATAORIGIN+$02DD
NX	= DATAORIGIN+$02DF
NY	= DATAORIGIN+$02E1
LX	= DATAORIGIN+$02E3
LY	= DATAORIGIN+$02E4
MX	= DATAORIGIN+$02E5
MY	= DATAORIGIN+$02E6
MYX	= DATAORIGIN+$02E7
MYY	= DATAORIGIN+$02E8
F1	= DATAORIGIN+$02E9
F2	= DATAORIGIN+$02EB
A	= DATAORIGIN+$02ED
B	= DATAORIGIN+$02EE
EMERGENCY	= DATAORIGIN+$02EF
MIMAX	= DATAORIGIN+$02F0
DEFLECT	= DATAORIGIN+$02F1
AROUND	= DATAORIGIN+$02F2
COLLISION	= DATAORIGIN+$02F3
TOUCH	= DATAORIGIN+$02F4
YES	= DATAORIGIN+$02F5
adr.ADJW	= [DATAORIGIN+$02F6] .array [4] [4]
.var ADJW	= adr.ADJW .word
@CASETMP_0009	= DATAORIGIN+$0306
@CASETMP_000A	= DATAORIGIN+$0307
@CASETMP_000B	= DATAORIGIN+$0308
@CASETMP_000C	= DATAORIGIN+$0309
@CASETMP_000D	= DATAORIGIN+$030A
@CASETMP_000E	= DATAORIGIN+$030B

@VarData	= BALL
@VarDataSize	= 48

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	FILL_PICTURE_WITH_PATTERN			; PROCEDURE

; -------------------  ASM Block 00000180  -------------------

	fxs FX_MEMS #$80
    
; optimize OK (service.pas), line = 2725

	lda PATTERN.WIDTH
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda PATTERN.WIDTH+1
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 2727

	lda #$7F
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 2728

	lda #$80
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 2730

	lda PATTERN.WIDTH
	sub #$01
	ora #$80
	sta BLT.PATTERN_FEATURE

; optimize OK (service.pas), line = 2732

	lda adr.ROW+$0A
	add #$09
	sta HLP
	lda adr.ROW+256+$0A
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 2735

	lda #$00
	sta YB
	sta YB+1

; optimize OK (service.pas), line = 2736

	sta I

; optimize OK (service.pas), line = 2738

	lda #$0A
	sta Y

l_28AB
; --- ForToDoCondition
	lda Y
	cmp #$C7
	jcs l_28B9

; optimize OK (service.pas), line = 2740

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda PATTERN.OFS
	add YB
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda PATTERN.OFS+1
	adc YB+1
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda PATTERN.OFS+2
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda PATTERN.OFS+3
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$CF
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 2742

	lda HLP
	add #$40
	sta HLP
	lda HLP+1
	adc #$01
	sta HLP+1

; optimize OK (service.pas), line = 2744

	lda YB
	add PATTERN.WIDTH
	sta YB
	lda YB+1
	adc PATTERN.WIDTH+1
	sta YB+1

; optimize FAIL (0, service.pas), line = 2746

	inc I

; optimize OK (service.pas), line = 2747

	lda I
	cmp PATTERN.HEIGHT
	jne l_28E3

; optimize OK (service.pas), line = 2748

	lda #$00
	sta YB
	sta YB+1

; optimize OK (service.pas), line = 2749

	sta I
l_28E3

; --- ForToDoEpilog
	inc Y
	jne l_28AB
l_28B9

; optimize OK (service.pas), line = 2754

	lda #$00
	sta BLT.PATTERN_FEATURE

; optimize OK (service.pas), line = 2759

	lda #$40
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 2761

	lda #$FF
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 2762

	lda #$00
	sta BLT.BLT_XOR_MASK

; optimize OK (service.pas), line = 2764

	sta BLITTEMP.@040180000018100001820000182000.SRC
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	sta BLITTEMP.@040180000018100001820000182000.DST
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$04
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$40
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$C8
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 2770

	lda #$D7
	sta I

; optimize OK (service.pas), line = 2772

	lda #$0A
	sta Y

l_2914
; --- ForToDoCondition
	ldy Y
	cpy #$C7
	jcs l_2922

; optimize OK (service.pas), line = 2777

	lda adr.ROW,y
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda adr.ROW+256,y
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$D8
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 2780

	lda Y
	cmp #$10
	jcc l_2941
	lda #$11
	sta I
l_2941

; optimize OK (service.pas), line = 2783

	lda #$09
	sta X

l_2953
; --- ForToDoCondition
	lda X
	cmp I
	scc
	jne l_2961

; optimize OK (service.pas), line = 2794

	cmp #$12
	jcc l_297Fx
	lda Y
	cmp #$10
	jcs l_297F
l_297Fx

; optimize OK (service.pas), line = 2795

	ldy X
	lda adr.SCR,y
	and #$7F
	sta adr.SCR,y
l_297F

; --- ForToDoEpilog
	inc X
	jne l_2953
l_2961

; optimize OK (service.pas), line = 2806

	ldy Y
	lda adr.ROW,y
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda adr.ROW+256,y
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$D8
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; --- ForToDoEpilog
	inc Y
	jne l_2914
l_2922

; -------------------  ASM Block 00000181  -------------------

	fxs FX_MEMS #$00
    
; ------------------------------------------------------------

YB	= DATAORIGIN+$030C
X	= DATAORIGIN+$030E
Y	= DATAORIGIN+$030F
I	= DATAORIGIN+$0310

@VarData	= YB
@VarDataSize	= 5

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	WRITE_ROUND_LEVEL				; PROCEDURE

; ------------------------------------------------------------

X	= DATAORIGIN+$0311
Y	= DATAORIGIN+$0313

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_ROUND_LEVEL				; PROCEDURE

; optimize OK (service.pas), line = 2859

	lda adr.ROW+$81
	add #$48
	sta HLP
	lda adr.ROW+256+$81
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 2861

	lda #$58
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda #$1F
	sta BLITBOX.H
	jsr BLITBOX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	GAME_OVER					; PROCEDURE

; ------------------------------------------------------------

X	= DATAORIGIN+$0315
Y	= DATAORIGIN+$0317
adr.SC	= [DATAORIGIN+$0319] .array [21]
.var SC	= adr.SC .word

@VarData	= X
@VarDataSize	= 25

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DESTROY_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 2907

	:7 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 2908

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 2910

	lda VAUS.X
	sta MOVE_VAUS.X
	lda VAUS.Y
	sta MOVE_VAUS.Y
	jsr MOVE_VAUS

; optimize OK (service.pas), line = 2912

	lda VAUS.X
	sub #$04
	sta A

; optimize OK (service.pas), line = 2913

	lda VAUS.Y
	sub #$05
	sta B

; optimize OK (service.pas), line = 2916

	lda #$0B
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000

; -------------------  ASM Block 00000182  -------------------

	fxs FX_MEMS #$80
    
; optimize OK (service.pas), line = 2922

	lda #$2A
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$00
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$2A
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$00
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 2924

	lda #$00
	sta VM
	sta VM+1

; optimize OK (service.pas), line = 2926

	sta W

l_29F6
; --- ForToDoCondition
	lda W
	cmp #$07
	jcs l_2A04

; optimize OK (service.pas), line = 2929

	lda VM
	sta Z
	lda VM+1
	sta Z+1

; optimize OK (service.pas), line = 2931

	lda #$00
	sta Y

l_2A12
; --- ForToDoCondition
	lda Y
	cmp #$10
	jcs l_2A20

; optimize OK (service.pas), line = 2936

	lda Z
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda #$60
	add Z+1
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$00
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda #$00
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$80
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$2A
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 2938

	lda Y
	add B
	tay
	lda A
	add adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 2940

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$2A
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 2942

	lda #$00
	sta X

l_2A51
; --- ForToDoCondition
	lda X
	cmp #$2A
	jcs l_2A5F

; optimize OK (service.pas), line = 2946

	lda W
	cmp #$06
	jeq l_2A80x
	ldy X
	lda adr.POM,y
	jne l_2A80
l_2A80x
	jmp l_2A8A
l_2A80

; optimize OK (service.pas), line = 2955

	ldy X
	lda adr.POM,y
	sta adr.SCR,y
l_2A8A

; --- ForToDoEpilog
	inc X
	jne l_2A51
l_2A5F

; optimize OK (service.pas), line = 2958

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$03
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$2A
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 2960

	lda Z
	add #$2A
	sta Z
	scc
	inc Z+1

; --- ForToDoEpilog
	inc Y
	jne l_2A12
l_2A20

; optimize OK (service.pas), line = 2963

	lda VM
	add #$A0
	sta VM
	lda VM+1
	adc #$02
	sta VM+1

; optimize FAIL ('SYSTEM.PAUSE.@00', service.pas), line = 2965

	jsr SYSTEM.PAUSE.@00

; optimize FAIL ('SYSTEM.PAUSE.@00', service.pas), line = 2966

	jsr SYSTEM.PAUSE.@00

; --- ForToDoEpilog
	inc W
	jne l_29F6
l_2A04

; -------------------  ASM Block 00000183  -------------------

	fxs FX_MEMS #$00
    
; optimize OK (service.pas), line = 2975

	lda #$96
	sta MYDELAY.A
	lda #$00
	sta MYDELAY.A+1
	jsr MYDELAY

; optimize FAIL ('DISABLE_LETTER', service.pas), line = 2976

	jsr DISABLE_LETTER

; ------------------------------------------------------------

A	= DATAORIGIN+$032E
B	= DATAORIGIN+$032F
W	= DATAORIGIN+$0330
X	= DATAORIGIN+$0331
Y	= DATAORIGIN+$0332
Z	= DATAORIGIN+$0333
VM	= DATAORIGIN+$0335

@VarData	= A
@VarDataSize	= 9

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CREATE_VAUS					; PROCEDURE

; optimize FAIL ('NOSOUND', service.pas), line = 2990

	jsr NOSOUND

; optimize OK (service.pas), line = 2992

	lda #$5A
	sta A

; optimize OK (service.pas), line = 2993

	lda #$B3
	sta B

; -------------------  ASM Block 00000184  -------------------

	fxs FX_MEMS #$80
    
; optimize OK (service.pas), line = 2999

	lda NEWVAUS.WIDTH
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda NEWVAUS.WIDTH+1
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda NEWVAUS.WIDTH
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda NEWVAUS.WIDTH+1
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 3001

	lda #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda NEWVAUS.WIDTH
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	sta MW
	lda :STACKORIGIN+STACKWIDTH+9
	sta MW+1

; optimize OK (service.pas), line = 3003

	lda #$00
	sta J
	sta J+1

; optimize OK (service.pas), line = 3005

	lda #$0B
	sta W

l_2ADE
; --- ForToDoCondition
	lda J
	sta Z
	lda J+1
	sta Z+1

; optimize OK (service.pas), line = 3009

	lda #$00
	sta Y

l_2AFA
; --- ForToDoCondition
	lda Y
	cmp #$10
	jcs l_2B08

; optimize OK (service.pas), line = 3014

	adc B
	tay
	lda A
	add adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 3016

	lda NEWVAUS.OFS
	add Z
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda NEWVAUS.OFS+1
	adc Z+1
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda NEWVAUS.OFS+2
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda NEWVAUS.OFS+3
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$80
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda NEWVAUS.WIDTH
	sta BLITTEMP.@040180000018100001820000182000.W
	lda NEWVAUS.WIDTH+1
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 3018

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda NEWVAUS.WIDTH
	sta BLITTEMP.@040180000018100001820000182000.W
	lda NEWVAUS.WIDTH+1
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 3020

	lda #$00
	sta X
	ldy NEWVAUS.WIDTH
	dey
	sty @FORTMP_2B3D_0

l_2B40
; --- ForToDoCondition
	lda @FORTMP_2B3D_0::#$00
	cmp X
	jcc l_2B4E

; optimize OK (service.pas), line = 3022

	ldy X
	lda adr.POM,y
	jne l_2B63
	jmp l_2B6D
l_2B63

; optimize OK (service.pas), line = 3033

	ldy X
	lda adr.POM,y
	sta adr.SCR,y
l_2B6D

; --- ForToDoEpilog
	inc X
	jne l_2B40
l_2B4E

; optimize OK (service.pas), line = 3036

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$03
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda NEWVAUS.WIDTH
	sta BLITTEMP.@040180000018100001820000182000.W
	lda NEWVAUS.WIDTH+1
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 3038

	lda Z
	add NEWVAUS.WIDTH
	sta Z
	lda Z+1
	adc NEWVAUS.WIDTH+1
	sta Z+1

; --- ForToDoEpilog
	inc Y
	jne l_2AFA
l_2B08

; optimize FAIL ('SYSTEM.PAUSE.@00', service.pas), line = 3041

	jsr SYSTEM.PAUSE.@00

; optimize OK (service.pas), line = 3043

	lda J
	add MW
	sta J
	lda J+1
	adc MW+1
	sta J+1

; --- ForToDoEpilog
	dec W
	jpl l_2ADE
l_2AEC

; -------------------  ASM Block 00000185  -------------------

	fxs FX_MEMS #$00
    
; ------------------------------------------------------------

X	= DATAORIGIN+$0337
Y	= DATAORIGIN+$0338
W	= DATAORIGIN+$0339
Z	= DATAORIGIN+$033A
J	= DATAORIGIN+$033C
MW	= DATAORIGIN+$033E
A	= DATAORIGIN+$0340
B	= DATAORIGIN+$0341

@VarData	= X
@VarDataSize	= 11

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	WRITE_SCORE					; PROCEDURE

	jmp l_2B9C

.local	PUT_DIGIT					; PROCEDURE
	sta NUM

; optimize OK (service.pas), line = 3149

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$03
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	ldy NUM
	lda adr.MUL_6,y
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda #$50
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$06
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$0B
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 3151

	lda HLP
	add #$07
	sta HLP
	scc
	inc HLP+1

; ------------------------------------------------------------

NUM	= DATAORIGIN+$034A

@VarData	= NUM
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_2B9C

; optimize OK (service.pas), line = 3158

	lda #$00
	sta F

; -------------------  ASM Block 00000186  -------------------

	fxs FX_MEMS #$80
    
; optimize OK (service.pas), line = 3166

	lda #$80
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$00
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 3168

	ldy PY
	lda adr.ROW,y
	add #$FD
	sta HLP
	lda adr.ROW+256,y
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 3173

	lda SC_
	sta SC
	lda SC_+1
	sta SC+1
	lda SC_+2
	sta SC+2
	lda SC_+3
	sta SC+3

; optimize OK (service.pas), line = 3175

	lda #$00
	sta N1

; --- WhileProlog
	jmp l_2BD1
l_2BD2

; optimize OK (service.pas), line = 3177

	lda SC
	sub #$A0
	sta SC
	lda SC+1
	sbc #$86
	sta SC+1
	lda SC+2
	sbc #$01
	sta SC+2
	lda SC+3
	sbc #$00
	sta SC+3

; optimize FAIL (0, service.pas), line = 3178

	inc N1
l_2BD1

; optimize OK (service.pas), line = 3176

	lda SC+3
	cmp #$00
	bne @+
	lda SC+2
	cmp #$01
	bne @+
	lda SC+1
	cmp #$86
	bne @+
	lda SC
	cmp #$A0
@
	jcs l_2BD2

; optimize OK (service.pas), line = 3180

	ldy N1
	lda adr.MOD10TABLE,y
	sta N1

; optimize OK (service.pas), line = 3181

	tya
	jeq l_2BFC
	lda #$01
	sta F
l_2BFC

; optimize OK (service.pas), line = 3182

	lda F
	jeq l_2C0F
	lda N1
	jmp l_2C1D
l_2C0F

; optimize OK (service.pas), line = 3183

	lda #$0A
l_2C1D
	jsr PUT_DIGIT

; optimize OK (service.pas), line = 3186

	lda #$00
	sta N1

; --- WhileProlog
	jmp l_2C25
l_2C26

; optimize OK (service.pas), line = 3188

	lda SC
	sub #$10
	sta SC
	lda SC+1
	sbc #$27
	sta SC+1
	lda SC+2
	sbc #$00
	sta SC+2
	lda SC+3
	sbc #$00
	sta SC+3

; optimize FAIL (0, service.pas), line = 3189

	inc N1
l_2C25

; optimize OK (service.pas), line = 3187

	lda SC+3
	cmp #$00
	bne @+
	lda SC+2
	cmp #$00
	bne @+
	lda SC+1
	cmp #$27
	bne @+
	lda SC
	cmp #$10
@
	jcs l_2C26

; optimize OK (service.pas), line = 3191

	ldy N1
	lda adr.MOD10TABLE,y
	sta N1

; optimize OK (service.pas), line = 3192

	tya
	jeq l_2C50
	lda #$01
	sta F
l_2C50

; optimize OK (service.pas), line = 3193

	lda F
	jeq l_2C63
	lda N1
	jmp l_2C71
l_2C63

; optimize OK (service.pas), line = 3194

	lda #$0A
l_2C71
	jsr PUT_DIGIT

; optimize OK (service.pas), line = 3197

	lda #$00
	sta N1

; --- WhileProlog
	jmp l_2C79
l_2C7A

; optimize OK (service.pas), line = 3199

	lda SC
	sub #$E8
	sta SC
	lda SC+1
	sbc #$03
	sta SC+1
	lda SC+2
	sbc #$00
	sta SC+2
	lda SC+3
	sbc #$00
	sta SC+3

; optimize FAIL (0, service.pas), line = 3200

	inc N1
l_2C79

; optimize OK (service.pas), line = 3198

	lda SC+1
	cmp #$03
	bne @+
	lda SC
	cmp #$E8
@
	jcs l_2C7A

; optimize OK (service.pas), line = 3202

	ldy N1
	lda adr.MOD10TABLE,y
	sta N1

; optimize OK (service.pas), line = 3203

	tya
	jeq l_2CA4
	lda #$01
	sta F
l_2CA4

; optimize OK (service.pas), line = 3204

	lda F
	jeq l_2CB7
	lda N1
	jmp l_2CC5
l_2CB7

; optimize OK (service.pas), line = 3205

	lda #$0A
l_2CC5
	jsr PUT_DIGIT

; optimize OK (service.pas), line = 3208

	lda #$00
	sta N1

; --- WhileProlog
	jmp l_2CCD
l_2CCE

; optimize OK (service.pas), line = 3210

	lda SC
	sub #$64
	sta SC
	lda SC+1
	sbc #$00
	sta SC+1
	lda SC+2
	sbc #$00
	sta SC+2
	lda SC+3
	sbc #$00
	sta SC+3

; optimize FAIL (0, service.pas), line = 3211

	inc N1
l_2CCD

; optimize OK (service.pas), line = 3209

	lda SC+1
	jne l_2CCE
	lda SC
	cmp #$64
	jcs l_2CCE

; optimize OK (service.pas), line = 3213

	ldy N1
	lda adr.MOD10TABLE,y
	sta N1

; optimize OK (service.pas), line = 3214

	tya
	jeq l_2CF8
	lda #$01
	sta F
l_2CF8

; optimize OK (service.pas), line = 3215

	lda F
	jeq l_2D0B
	lda N1
	jmp l_2D19
l_2D0B

; optimize OK (service.pas), line = 3216

	lda #$0A
l_2D19
	jsr PUT_DIGIT

; optimize OK (service.pas), line = 3219

	lda #$00
	sta N1

; --- WhileProlog
	jmp l_2D21
l_2D22

; optimize OK (service.pas), line = 3221

	lda SC
	sub #$0A
	sta SC
	lda SC+1
	sbc #$00
	sta SC+1
	lda SC+2
	sbc #$00
	sta SC+2
	lda SC+3
	sbc #$00
	sta SC+3

; optimize FAIL (0, service.pas), line = 3222

	inc N1
l_2D21

; optimize OK (service.pas), line = 3220

	lda SC
	cmp #$0A
	jcs l_2D22

; optimize OK (service.pas), line = 3225

	ldy N1
	lda adr.MOD10TABLE,y
	jsr PUT_DIGIT

; optimize OK (service.pas), line = 3229

	lda #$00
	jsr PUT_DIGIT

; -------------------  ASM Block 00000187  -------------------

	fxs FX_MEMS #$00
    
; ------------------------------------------------------------

PY	= DATAORIGIN+$0343
SC_	= DATAORIGIN+$0344
adr.MUL_6	= CODEORIGIN+$0292
.var MUL_6	= adr.MUL_6 .word
N1	= DATAORIGIN+$0348
F	= DATAORIGIN+$0349
SC	= :STACKORIGIN-4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLOT_LIVES					; PROCEDURE
	sta LIVES

; optimize FAIL (0, service.pas), line = 3283

	dec LIVES

; -------------------  ASM Block 00000188  -------------------

	fxs FX_MEMS #$80
    
; optimize OK (service.pas), line = 3290

	lda adr.ROW+$C0
	add #$0B
	sta HLP
	lda adr.ROW+256+$C0
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 3294

	lda #$A0
	sta BLITCLR.W
	lda #$00
	sta BLITCLR.W+1
	lda #$05
	sta BLITCLR.H
	jsr BLITCLR

; optimize OK (service.pas), line = 3297

	lda LIVES
	jeq l_2D65

; optimize OK (service.pas), line = 3300

	cmp #$08
	jcc l_2D78

; optimize OK (service.pas), line = 3301

	lda #$07
	sta I
	jmp l_2D86
l_2D78

; optimize OK (service.pas), line = 3303

	ldy LIVES
	dey
	sty I
l_2D86

; optimize OK (service.pas), line = 3305

	lda #$14
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$00
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 3307

	lda #$01
	sta BLT.BLT_CONTROL

; optimize OK (service.pas), line = 3310

	lda #$00
	sta CN

l_2DA2
; --- ForToDoCondition
	lda CN
	cmp I
	scc
	jne l_2DB0

; optimize OK (service.pas), line = 3314

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$02
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$9D
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda #$96
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$14
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$05
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 3315

	lda HLP
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda HLP+1
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$03
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$9D
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda #$96
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$14
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$05
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; optimize OK (service.pas), line = 3317

	lda HLP
	add #$14
	sta HLP
	scc
	inc HLP+1

; --- ForToDoEpilog
	inc CN
	jne l_2DA2
l_2DB0

; optimize OK (service.pas), line = 3320

	lda #$00
	sta BLT.BLT_CONTROL
l_2D65

; -------------------  ASM Block 00000189  -------------------

	fxs FX_MEMS #$00
    
; ------------------------------------------------------------

LIVES	= DATAORIGIN+$034B
XLIVES	= $0B
YLIVES	= $C0
X	= DATAORIGIN+$034C
Y	= DATAORIGIN+$034D
XL	= DATAORIGIN+$034E
YL	= DATAORIGIN+$034F
CN	= DATAORIGIN+$0350
CL	= DATAORIGIN+$0351
I	= DATAORIGIN+$0352

@VarData	= LIVES
@VarDataSize	= 8

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLACE_FIRE					; PROCEDURE

; optimize OK (service.pas), line = 3410

	ldy FIRE.Y
	lda FIRE.X
	add adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 3412

	lda #$4C
	sta BLITZERO.SRC
	lda #$BE
	sta BLITZERO.SRC+1
	lda #$00
	sta BLITZERO.SRC+2
	sta BLITZERO.SRC+3
	lda #$0D
	sta BLITZERO.W
	lda #$00
	sta BLITZERO.W+1
	lda #$08
	sta BLITZERO.H
	jsr BLITZERO

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_FIRE					; PROCEDURE

; optimize OK (service.pas), line = 3420

	ldy FIRE.Y
	lda FIRE.X
	add adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 3422

	lda #$0D
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda #$08
	sta BLITBOX.H
	jsr BLITBOX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CHECK_FIRE					; PROCEDURE

; optimize OK (service.pas), line = 3430

	lda FIRE.AVL
	jeq l_2E0B

; optimize FAIL ('MOUSECLICK', service.pas), line = 3432

	jsr MOUSECLICK
	ldy #1
	lda MOUSECLICK.RESULT
	cmp #$01
	beq @+
	dey
@
	tya
	and FIRE.AVL
	sta :STACKORIGIN+1,x
	ldy #1
	lda FIRE.SHOT
	beq @+
	dey
@
	tya
	and :STACKORIGIN+1,x
	jeq l_2E2B

; optimize OK (service.pas), line = 3434

	lda VAUS.WIDTH
	sub #$0D
	lsr @
	add VAUS.X
	sta FIRE.X

; optimize OK (service.pas), line = 3435

	lda VAUS.Y
	sub #$08
	sta FIRE.Y

; optimize OK (service.pas), line = 3436

	lda #$01
	sta FIRE.SHOT

; optimize OK (service.pas), line = 3437

	lda #$00
	sta FIRE.NW

; optimize OK (service.pas), line = 3439

	lda #$05
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000
l_2E2B

; optimize OK (service.pas), line = 3442

	lda FIRE.SHOT
	jeq l_2E62

; optimize OK (service.pas), line = 3444

	lda FIRE.NW
	jeq l_2E6F
	jsr REMOVE_FIRE
l_2E6F

; optimize OK (service.pas), line = 3445

	lda #$01
	sta FIRE.NW

; optimize OK (service.pas), line = 3447

	lda FIRE.Y
	sub #$04
	sta FIRE.Y

; optimize OK (service.pas), line = 3448

	cmp #$16
	jcs l_2E8A
	lda #$00
	sta FIRE.SHOT
	jmp l_2E98
l_2E8A

; optimize FAIL ('PLACE_FIRE', service.pas), line = 3451

	jsr PLACE_FIRE

; optimize OK (service.pas), line = 3453

	lda FIRE.Y
	sub #$16
	cmp #$00
	jcc l_2EBF
	lda FIRE.Y
	sub #$16
	cmp #$78
	jcs l_2EBF

; optimize OK (service.pas), line = 3455

	lda FIRE.X
	sub #$09
	lsr @
	lsr @
	lsr @
	lsr @
	sta X1

; optimize OK (service.pas), line = 3456

	lda FIRE.Y
	sub #$16
	lsr @
	lsr @
	lsr @
	sta Y1

; optimize OK (service.pas), line = 3458

	lda FIRE.X
	add #$04
	lsr @
	lsr @
	lsr @
	lsr @
	sta X2

; optimize OK (service.pas), line = 3459

	lda Y1
	sta Y2

; optimize OK (service.pas), line = 3461

	asl @
	asl @
	asl @
	asl @
	add X1
	tay
	lda adr.WALL,y
	jne l_2F2Cx
	lda Y2
	asl @
	asl @
	asl @
	asl @
	add X2
	tay
	lda adr.WALL,y
	jeq l_2F2C
l_2F2Cx

; optimize FAIL ('REMOVE_FIRE', service.pas), line = 3463

	jsr REMOVE_FIRE

; optimize OK (service.pas), line = 3464

	lda #$00
	sta FIRE.SHOT

; optimize OK (service.pas), line = 3466

	lda X1
	sta SHOOT_BLOCK_WITH_FIRE.XB
	lda Y1
	sta SHOOT_BLOCK_WITH_FIRE.YB
	jsr SHOOT_BLOCK_WITH_FIRE

; optimize OK (service.pas), line = 3467

	lda X2
	sta SHOOT_BLOCK_WITH_FIRE.XB
	lda Y2
	sta SHOOT_BLOCK_WITH_FIRE.YB
	jsr SHOOT_BLOCK_WITH_FIRE
l_2E98
l_2F2C
l_2EBF
l_2E62
l_2E0B

; ------------------------------------------------------------

X1	= DATAORIGIN+$0353
X2	= DATAORIGIN+$0354
Y1	= DATAORIGIN+$0355
Y2	= DATAORIGIN+$0356

@VarData	= X1
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_FLUX					; PROCEDURE

; optimize OK (service.pas), line = 3479

	lda adr.ROW+$B1
	add #$D9
	sta HLP
	lda adr.ROW+256+$B1
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 3481

	lda #$08
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda #$14
	sta BLITBOX.H
	jsr BLITBOX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CHECK_FLUX					; PROCEDURE

; optimize OK (service.pas), line = 3492

	lda SCRFLUX
	jeq l_2F69

; optimize OK (service.pas), line = 3495

	lda SCRFLUXCNT
	lsr @
	lsr @
	sta :STACKORIGIN+9
	asl :STACKORIGIN+9
	asl :STACKORIGIN+9
	asl :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta FX

; -------------------  ASM Block 00000190  -------------------

	fxs FX_MEMS #$80
      
; optimize OK (service.pas), line = 3503

	lda #$18
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$00
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 3506

	lda #$D9
	add adr.ROW+$B1
	sta BLITTEMP.@040180000018100001820000182000.DST
	lda #$00
	adc adr.ROW+256+$B1
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$03
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$80
	add FX
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda #$CA
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$01
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	lda #$00
	adc #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	lda #$08
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$15
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; -------------------  ASM Block 00000191  -------------------

	fxs FX_MEMS #$00
      
; optimize FAIL (0, service.pas), line = 3514

	inc SCRFLUXCNT

; optimize OK (service.pas), line = 3515

	lda SCRFLUXCNT
	cmp #$0C
	jcc l_2FA6
	lda #$00
	sta SCRFLUXCNT
l_2FA6
l_2F69

; ------------------------------------------------------------

Y	= DATAORIGIN+$0357
FX	= DATAORIGIN+$0358

@VarData	= Y
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	VAUS_OUT					; PROCEDURE

; optimize OK (service.pas), line = 3526

	lda #$0C
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000

; optimize OK (service.pas), line = 3528

	lda CUR_PLAYER
	asl @
	asl @
	tay
	lda adr.SCORE.PLAYER,y
	add #$10
	sta adr.SCORE.PLAYER,y
	lda adr.SCORE.PLAYER+1,y
	adc #$27
	sta adr.SCORE.PLAYER+1,y
	lda adr.SCORE.PLAYER+2,y
	adc #$00
	sta adr.SCORE.PLAYER+2,y
	lda adr.SCORE.PLAYER+3,y
	adc #$00
	sta adr.SCORE.PLAYER+3,y

; optimize OK (service.pas), line = 3529

	lda #$00
	sta REMAIN_BLK

; optimize OK (service.pas), line = 3531

	lda VAUS.X
	sta Z

; optimize FAIL ('WAIT_VBL', service.pas), line = 3533

	jsr WAIT_VBL

; optimize FAIL ('REMOVE_VAUS', service.pas), line = 3534

	jsr REMOVE_VAUS

; optimize FAIL ('PLACE_VAUS', service.pas), line = 3535

	jsr PLACE_VAUS

; optimize OK (service.pas), line = 3537

	lda Z
	sta X
	add #$2C
	sta @FORTMP_2FD4_0

l_2FD7
; --- ForToDoCondition
	lda @FORTMP_2FD4_0::#$00
	cmp X
	jcc l_2FE5

; optimize FAIL ('WAIT_VBL', service.pas), line = 3539

	jsr WAIT_VBL

; optimize OK (service.pas), line = 3541

	lda VAUS.X
	sta VAUS.OLDX

; optimize OK (service.pas), line = 3542

	lda X
	sta VAUS.X

; optimize FAIL ('REMOVE_VAUS', service.pas), line = 3543

	jsr REMOVE_VAUS

; optimize FAIL ('CHECK_FLUX', service.pas), line = 3544

	jsr CHECK_FLUX

; optimize FAIL ('PLACE_VAUS', service.pas), line = 3545

	jsr PLACE_VAUS

; optimize OK (service.pas), line = 3547

	ldy VAUS.Y
	lda adr.ROW,y
	add #$E1
	sta HLP
	lda adr.ROW+256,y
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 3549

	lda #$28
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda VAUS.HEIGHT
	sta BLITBOX.H
	jsr BLITBOX

; --- ForToDoEpilog
	inc X
	jne l_2FD7
l_2FE5

; ------------------------------------------------------------

X	= DATAORIGIN+$0359
Z	= DATAORIGIN+$035A

@VarData	= X
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CHECK_BONUS_TYPE				; PROCEDURE

; optimize OK (service.pas), line = 3560

	lda VAUS.LETTER
	cmp #$FF
	jeq l_3021

; optimize OK (service.pas), line = 3561

	lda VAUS.LETTER
	jeq l_3034

; optimize OK (service.pas), line = 3563

	sub #$01
	sta LETT.LAST
	lda #$00
	sbc #$00
	sta LETT.LAST+1

; optimize OK (service.pas), line = 3564

	mwy B2 :bp2
	ldy #B2.INPLAY-DATAORIGIN
	lda (:bp2),y
	jeq l_304B
	lda B2
	sta REMOVE_BALL.BALL
	lda B2+1
	sta REMOVE_BALL.BALL+1
	jsr REMOVE_BALL
l_304B

; optimize OK (service.pas), line = 3565

	mwy B3 :bp2
	ldy #B3.INPLAY-DATAORIGIN
	lda (:bp2),y
	jeq l_305D
	lda B3
	sta REMOVE_BALL.BALL
	lda B3+1
	sta REMOVE_BALL.BALL+1
	jsr REMOVE_BALL
l_305D

; optimize OK (service.pas), line = 3566

	mwy B2 :bp2
	ldy #B2.INPLAY-DATAORIGIN
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 3567

	mwy B3 :bp2
	ldy #B3.INPLAY-DATAORIGIN
	sta (:bp2),y

; optimize OK (service.pas), line = 3568

	sta SCRFLUX

; optimize FAIL ('REMOVE_FLUX', service.pas), line = 3569

	jsr REMOVE_FLUX

; optimize OK (service.pas), line = 3571

	lda VAUS.LETTER
	cmp #$06
	jeq l_3082

; optimize OK (service.pas), line = 3573

	mwy B1 :bp2
	ldy #B1.LAUNCH-DATAORIGIN
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 3574

	mwy B2 :bp2
	ldy #B2.LAUNCH-DATAORIGIN
	sta (:bp2),y

; optimize OK (service.pas), line = 3575

	mwy B3 :bp2
	ldy #B3.LAUNCH-DATAORIGIN
	sta (:bp2),y
l_3082
l_3034
l_3021

; optimize OK (service.pas), line = 3579

	lda VAUS.LETTER
	sta @CASETMP_000F
	cmp #$01
	jne l_30A0
@

; optimize OK (service.pas), line = 3582

	lda FIRE.SHOT
	jeq l_30AC
	jsr REMOVE_FIRE
l_30AC

; optimize OK (service.pas), line = 3583

	:7 mva adr.LASERS+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3584

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 3585

	lda #$00
	sta VAUS.LETTER

; optimize OK (service.pas), line = 3586

	lda #$01
	sta FIRE.AVL

; optimize OK (service.pas), line = 3587

	lda #$00
	sta FIRE.SHOT
	jmp a_000F
l_30A0
	cmp #$02
	jne l_30C6

; optimize OK (service.pas), line = 3591

	lda FIRE.SHOT
	jeq l_30D2
	jsr REMOVE_FIRE
l_30D2

; optimize OK (service.pas), line = 3592

	:7 mva adr.ENLARGED+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3593

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 3594

	lda #$00
	sta VAUS.LETTER

; optimize OK (service.pas), line = 3596

	lda #$03
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000

; optimize OK (service.pas), line = 3598

	lda #$00
	sta FIRE.AVL
	jmp a_000F
l_30C6
	cmp #$03
	jne l_30EA

; optimize OK (service.pas), line = 3602

	lda FIRE.SHOT
	jeq l_30F6
	jsr REMOVE_FIRE
l_30F6

; optimize OK (service.pas), line = 3603

	:7 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3604

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 3605

	lda #$00
	sta VAUS.LETTER

; optimize OK (service.pas), line = 3606

	sta FIRE.AVL

; optimize OK (service.pas), line = 3607

	lda #$01
	sta SCRFLUX
	jmp a_000F
l_30EA
	cmp #$04
	jne l_3110

; optimize OK (service.pas), line = 3611

	lda FIRE.SHOT
	jeq l_311C
	jsr REMOVE_FIRE
l_311C

; optimize OK (service.pas), line = 3612

	:7 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3613

	jsr MODIFY_VAUS
; optimize OK (service.pas), line = 3614
	jmp s_3159
l_3110
	cmp #$05
	jne l_312E

; optimize OK (service.pas), line = 3618

	lda FIRE.SHOT
	jeq l_313A
	jsr REMOVE_FIRE
l_313A

; optimize OK (service.pas), line = 3619

	:7 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3620

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 3621

	lda #$00
	sta VAUS.LETTER

; optimize OK (service.pas), line = 3622

	mwy B1 :bp2
	ldy #B1.SPEED-DATAORIGIN
	lda (:bp2),y
	sub #$F4
	sta MAX.A
	iny
	lda (:bp2),y
	sbc #$01
	sta MAX.A+1
	lda #$4B
	sta MAX.B
	lda #$02
	sta MAX.B+1
	jsr MAX
	lda MAX.RESULT
	sta X
	lda MAX.RESULT+1
	sta X+1

; optimize OK (service.pas), line = 3623

	lda B1
	sta SET_BALL_SPEED.BALL
	lda B1+1
	sta SET_BALL_SPEED.BALL+1
	lda X
	sta SET_BALL_SPEED.SPEED
	lda X+1
	sta SET_BALL_SPEED.SPEED+1
	jsr SET_BALL_SPEED
s_3159
; optimize OK (service.pas), line = 3624
	jmp s_3177
l_312E
	cmp #$06
	jne l_3160

; optimize OK (service.pas), line = 3628

	lda FIRE.SHOT
	jeq l_316C
	jsr REMOVE_FIRE
l_316C

; optimize OK (service.pas), line = 3629

	:7 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3630

	jsr MODIFY_VAUS
s_3177
; optimize OK (service.pas), line = 3631
	jmp s_31A6
l_3160
	cmp #$07
	jne l_317E

; optimize OK (service.pas), line = 3635

	lda FIRE.SHOT
	jeq l_318A
	jsr REMOVE_FIRE
l_318A

; optimize OK (service.pas), line = 3636

	:7 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3637

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 3638

	lda #$00
	sta VAUS.LETTER

; optimize OK (service.pas), line = 3639

	ldy CUR_PLAYER
	lda adr.SCORE.LIVES,y
	add #$01
	sta adr.SCORE.LIVES,y

; optimize OK (service.pas), line = 3640

	jsr PLOT_LIVES

; optimize OK (service.pas), line = 3643

	lda #$02
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000
s_31A6

; optimize OK (service.pas), line = 3645

	lda #$00
	sta FIRE.AVL
l_317E
a_000F

; ------------------------------------------------------------

B1	= DATAORIGIN+$035C
B1.X	= DATAORIGIN+$0000
B1.Y	= DATAORIGIN+$0002
B1.FINEX	= DATAORIGIN+$0004
B1.FINEY	= DATAORIGIN+$0005
B1.OLDX	= DATAORIGIN+$0006
B1.OLDY	= DATAORIGIN+$0008
B1.SPEED	= DATAORIGIN+$000A
B1.FINESPEED	= DATAORIGIN+$000C
B1.SPEEDX	= DATAORIGIN+$000E
B1.SPEEDY	= DATAORIGIN+$0010
B1.SBD	= DATAORIGIN+$0012
B1.BRWHIT	= DATAORIGIN+$0014
B1.INPLAY	= DATAORIGIN+$0015
B1.LAUNCH	= DATAORIGIN+$0016
B1.ONVAUS	= DATAORIGIN+$0017
B1.STM	= DATAORIGIN+$0019
B2	= DATAORIGIN+$0360
B2.X	= DATAORIGIN+$0000
B2.Y	= DATAORIGIN+$0002
B2.FINEX	= DATAORIGIN+$0004
B2.FINEY	= DATAORIGIN+$0005
B2.OLDX	= DATAORIGIN+$0006
B2.OLDY	= DATAORIGIN+$0008
B2.SPEED	= DATAORIGIN+$000A
B2.FINESPEED	= DATAORIGIN+$000C
B2.SPEEDX	= DATAORIGIN+$000E
B2.SPEEDY	= DATAORIGIN+$0010
B2.SBD	= DATAORIGIN+$0012
B2.BRWHIT	= DATAORIGIN+$0014
B2.INPLAY	= DATAORIGIN+$0015
B2.LAUNCH	= DATAORIGIN+$0016
B2.ONVAUS	= DATAORIGIN+$0017
B2.STM	= DATAORIGIN+$0019
B3	= DATAORIGIN+$0364
B3.X	= DATAORIGIN+$0000
B3.Y	= DATAORIGIN+$0002
B3.FINEX	= DATAORIGIN+$0004
B3.FINEY	= DATAORIGIN+$0005
B3.OLDX	= DATAORIGIN+$0006
B3.OLDY	= DATAORIGIN+$0008
B3.SPEED	= DATAORIGIN+$000A
B3.FINESPEED	= DATAORIGIN+$000C
B3.SPEEDX	= DATAORIGIN+$000E
B3.SPEEDY	= DATAORIGIN+$0010
B3.SBD	= DATAORIGIN+$0012
B3.BRWHIT	= DATAORIGIN+$0014
B3.INPLAY	= DATAORIGIN+$0015
B3.LAUNCH	= DATAORIGIN+$0016
B3.ONVAUS	= DATAORIGIN+$0017
B3.STM	= DATAORIGIN+$0019
X	= DATAORIGIN+$0368
@CASETMP_000F	= DATAORIGIN+$036A

@VarData	= B1
@VarDataSize	= 9

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DEVIATE_BALL					; PROCEDURE

; optimize OK (service.pas), line = 3656

	lda BALL
	sta GET_BALL_DIRECTION.BALL
	lda BALL+1
	sta GET_BALL_DIRECTION.BALL+1
	jsr GET_BALL_DIRECTION
	lda GET_BALL_DIRECTION.RESULT
	sta DIR
	lda GET_BALL_DIRECTION.RESULT+1
	sta DIR+1

; --- RepeatUntilProlog
l_31BA

; optimize FAIL (1, service.pas), line = 3659

	inx
	mva DIR :STACKORIGIN,x
	mva DIR+1 :STACKORIGIN+STACKWIDTH,x
	lda #$1E
	sta RAND.RANGE
	lda #$00
	sta RAND.RANGE+1
	jsr RAND
	inx
	mva RAND.RESULT :STACKORIGIN,x
	mva RAND.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	jsr addAX_CX
	dex
	lda :STACKORIGIN,x
	sub #$0F
	sta TEMP
	lda :STACKORIGIN+STACKWIDTH,x
	sbc #$00
	sta TEMP+1
	dex

; optimize OK (service.pas), line = 3660

	lda TEMP
	sta MOD90.A
	lda TEMP+1
	sta MOD90.A+1
	jsr MOD90
	inx
	ldy #1
	lda MOD90.RESULT
	cmp #$1F
	lda MOD90.RESULT+1
	sbc #$00
	svc
	eor #$80
	bpl @+
	dey
@
	sty :STACKORIGIN,x
	lda TEMP
	sta MOD90.A
	lda TEMP+1
	sta MOD90.A+1
	jsr MOD90
	dex
	ldy #1
	lda MOD90.RESULT
	cmp #$3C
	lda MOD90.RESULT+1
	sbc #$00
	svc
	eor #$80
	bmi @+
	dey
@
	tya
	and :STACKORIGIN+1,x
	jeq l_31BA

; optimize OK (service.pas), line = 3662

	lda BALL
	sta SET_BALL_DIRECTION.BALL
	lda BALL+1
	sta SET_BALL_DIRECTION.BALL+1
	lda TEMP
	sta SET_BALL_DIRECTION.ANGLE
	lda TEMP+1
	sta SET_BALL_DIRECTION.ANGLE+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 3663

	mwy BALL :bp2
	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED
	iny
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED+1
	lda BALL
	sta SET_BALL_SPEED.BALL
	lda BALL+1
	sta SET_BALL_SPEED.BALL+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 3665

	mwy BALL :bp2
	ldy #BALL.SBD-DATAORIGIN
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; ------------------------------------------------------------

BALL	= DATAORIGIN+$036B
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019
TEMP	= DATAORIGIN+$036F
DIR	= DATAORIGIN+$0371

@VarData	= BALL
@VarDataSize	= 6

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BOUNCEBALL					; FUNCTION

	jmp l_31F3

.local	CHECK_BALL					; PROCEDURE

; optimize OK (service.pas), line = 3698

	mwy BALL :bp2
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	iny
	cmp #$16
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jmi l_3212
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	iny
	cmp #$8E
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jpl l_3212

; optimize OK (service.pas), line = 3699

	lda BALL
	sta BALL_HIT_BLOCK.BALL
	lda BALL+1
	sta BALL_HIT_BLOCK.BALL+1
	jsr BALL_HIT_BLOCK
l_3212

; optimize OK (service.pas), line = 3701

	lda BALL
	sta SET_BALL.BALL
	lda BALL+1
	sta SET_BALL.BALL+1
	jsr SET_BALL

; optimize FAIL ('BALL_SPEED', service.pas), line = 3702

	inx
	mva BALL :STACKORIGIN,x
	mva BALL+1 :STACKORIGIN+STACKWIDTH,x
	jsr BALL_SPEED
	mwy BALL :bp2
	ldy #BALL.SPEED-DATAORIGIN
	lda BALL_SPEED.RESULT
	sta (:bp2),y
	iny
	lda BALL_SPEED.RESULT+1
	sta (:bp2),y

; ------------------------------------------------------------

BALL	= DATAORIGIN+$03CD
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019

@VarData	= BALL
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TEST_BALL					; PROCEDURE

; optimize OK (service.pas), line = 3712

	mwy BALL :bp2
	ldy #BALL.FINESPEED-DATAORIGIN
	lda (:bp2),y
	add #$01
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 3714

	ldy #BALL.FINESPEED-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	lda LV
	asl @
	tay
	lda adr.LEVEL+1,y
	cmp :STACKORIGIN+STACKWIDTH+9
	bne @+
	lda adr.LEVEL,y
	cmp :STACKORIGIN+9
@
	jcs l_323A

; optimize OK (service.pas), line = 3716

	ldy #BALL.FINESPEED-DATAORIGIN
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (service.pas), line = 3719

	ldy #BALL.SPEED-DATAORIGIN+$01
	lda (:bp2),y
	cmp #$03
	bne @+
	dey
	lda (:bp2),y
	cmp #$FF
@
	jcs l_3250

; optimize OK (service.pas), line = 3721

	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	adc #$11
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 3722

	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED
	iny
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED+1
	lda BALL
	sta SET_BALL_SPEED.BALL
	lda BALL+1
	sta SET_BALL_SPEED.BALL+1
	jsr SET_BALL_SPEED
l_3250
l_323A

; optimize OK (service.pas), line = 3726

	mwy BALL :bp2
	ldy #BALL.SBD-DATAORIGIN
	lda (:bp2),y
	add #$01
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 3730

	ldy #BALL.SBD-DATAORIGIN+$01
	lda (:bp2),y
	cmp #$02
	bne @+
	dey
	lda (:bp2),y
	cmp #$58
@
	jcc l_3278
@
	ldy #BALL.SPEEDY-DATAORIGIN+1
	lda (:bp2),y
	jpl l_3278
@

; optimize OK (service.pas), line = 3731

	lda BALL
	sta DEVIATE_BALL.BALL
	lda BALL+1
	sta DEVIATE_BALL.BALL+1
	jsr DEVIATE_BALL
l_3278

; ------------------------------------------------------------

BALL	= DATAORIGIN+$03D1
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0005
BALL.OLDX	= DATAORIGIN+$0006
BALL.OLDY	= DATAORIGIN+$0008
BALL.SPEED	= DATAORIGIN+$000A
BALL.FINESPEED	= DATAORIGIN+$000C
BALL.SPEEDX	= DATAORIGIN+$000E
BALL.SPEEDY	= DATAORIGIN+$0010
BALL.SBD	= DATAORIGIN+$0012
BALL.BRWHIT	= DATAORIGIN+$0014
BALL.INPLAY	= DATAORIGIN+$0015
BALL.LAUNCH	= DATAORIGIN+$0016
BALL.ONVAUS	= DATAORIGIN+$0017
BALL.STM	= DATAORIGIN+$0019

@VarData	= BALL
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_31F3

; optimize OK (service.pas), line = 3739

	lda #$00
	sta SCRFLUXCNT

; optimize OK (service.pas), line = 3740

	sta SCRFLUX

; optimize OK (service.pas), line = 3742

	lda #$01
	sta BALLS_IN_PLAY

; optimize OK (service.pas), line = 3744

	lda #$00
	sta FIRE.AVL

; optimize OK (service.pas), line = 3745

	:7 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize OK (service.pas), line = 3747

	lda #$FF
	sta LETT.LAST
	lda #$00
	sta LETT.LAST+1

; optimize OK (service.pas), line = 3748

	sta LETT.ACTIVE

; optimize FAIL ('FILL_PICTURE_WITH_PATTERN', service.pas), line = 3751

	jsr FILL_PICTURE_WITH_PATTERN

; optimize OK (service.pas), line = 3754

	lda #$00
	sta HLP
	sta HLP+1

; optimize OK (service.pas), line = 3755

	lda #$40
	sta BLITBOX.W
	lda #$01
	sta BLITBOX.W+1
	lda #$C8
	sta BLITBOX.H
	jsr BLITBOX

; optimize OK (service.pas), line = 3759

	ldy CUR_PLAYER
	lda adr.SCORE.LIVES,y
	jsr PLOT_LIVES

; optimize OK (service.pas), line = 3765

	lda adr.SCORE.PLAYER+$04
	sta WRITE_SCORE.SC_
	lda adr.SCORE.PLAYER+1+$04
	sta WRITE_SCORE.SC_+1
	lda adr.SCORE.PLAYER+2+$04
	sta WRITE_SCORE.SC_+2
	lda adr.SCORE.PLAYER+3+$04
	sta WRITE_SCORE.SC_+3
	lda #$3C
	sta WRITE_SCORE.PY
	jsr WRITE_SCORE

; optimize OK (service.pas), line = 3766

	lda adr.SCORE.PLAYER+$08
	sta WRITE_SCORE.SC_
	lda adr.SCORE.PLAYER+1+$08
	sta WRITE_SCORE.SC_+1
	lda adr.SCORE.PLAYER+2+$08
	sta WRITE_SCORE.SC_+2
	lda adr.SCORE.PLAYER+3+$08
	sta WRITE_SCORE.SC_+3
	lda #$5D
	sta WRITE_SCORE.PY
	jsr WRITE_SCORE

; optimize OK (service.pas), line = 3767

	lda #$80
	sta WRITE_SCORE.PY
	lda SCORE.HISCORE
	sta WRITE_SCORE.SC_
	lda SCORE.HISCORE+1
	sta WRITE_SCORE.SC_+1
	lda SCORE.HISCORE+2
	sta WRITE_SCORE.SC_+2
	lda SCORE.HISCORE+3
	sta WRITE_SCORE.SC_+3
	jsr WRITE_SCORE

; optimize FAIL ('PUT_WALL', service.pas), line = 3770

	jsr PUT_WALL

; optimize OK (service.pas), line = 3777

	lda #$01
	sta BALL0.INPLAY

; optimize OK (service.pas), line = 3778

	sta BALL0.LAUNCH

; optimize OK (service.pas), line = 3781

	lda #$6F
	sta BALL0.X
	lda #$00
	sta BALL0.X+1

; optimize OK (service.pas), line = 3782

	lda #$B5
	sta BALL0.Y
	lda #$00
	sta BALL0.Y+1

; optimize OK (service.pas), line = 3785

	lda #$FF
	sta BALL0.OLDX
	lda #$00
	sta BALL0.OLDX+1

; optimize OK (service.pas), line = 3786

	lda #$FF
	sta BALL0.OLDY
	lda #$00
	sta BALL0.OLDY+1

; optimize OK (service.pas), line = 3789

	sta BALL0.SBD
	sta BALL0.SBD+1

; optimize OK (service.pas), line = 3793

	lda #$10
	sta BALL0.ONVAUS
	lda #$00
	sta BALL0.ONVAUS+1

; optimize OK (service.pas), line = 3798

	sta BALL0.STM

; optimize OK (service.pas), line = 3802

	lda #$E8
	sta RAND.RANGE
	lda #$03
	sta RAND.RANGE+1
	jsr RAND
	lda RAND.RESULT
	sta LETT.INCOMING
	lda RAND.RESULT+1
	sta LETT.INCOMING+1

; optimize FAIL ('CREATE_VAUS', service.pas), line = 3805

	jsr CREATE_VAUS

; optimize FAIL ('WRITE_ROUND_LEVEL', service.pas), line = 3808

	jsr WRITE_ROUND_LEVEL

; optimize FAIL ('SET_VAUS', service.pas), line = 3810

	jsr SET_VAUS

; optimize OK (service.pas), line = 3811

	lda VAUS.X
	sta MOVE_VAUS.X
	lda #$B8
	sta MOVE_VAUS.Y
	jsr MOVE_VAUS

; optimize FAIL ('START_LEVEL', service.pas), line = 3812

	jsr START_LEVEL

; optimize FAIL ('REMOVE_ROUND_LEVEL', service.pas), line = 3813

	jsr REMOVE_ROUND_LEVEL

; optimize OK (service.pas), line = 3814

	lda BALL0
	sta SET_BALL.BALL
	lda BALL0+1
	sta SET_BALL.BALL+1
	jsr SET_BALL

; optimize OK (service.pas), line = 3821

	lda #$0F
	sta RAND.RANGE
	lda #$00
	sta RAND.RANGE+1
	jsr RAND
	inx
	inx
	lda RAND.RESULT
	add #$3C
	sta :STACKORIGIN-1,x
	lda RAND.RESULT+1
	adc #$00
	sta :STACKORIGIN-1+STACKWIDTH,x
	lda BALL0
	sta SET_BALL_DIRECTION.BALL
	lda BALL0+1
	sta SET_BALL_DIRECTION.BALL+1
	dex
	lda :STACKORIGIN,x
	sta SET_BALL_DIRECTION.ANGLE
	lda :STACKORIGIN+STACKWIDTH,x
	sta SET_BALL_DIRECTION.ANGLE+1
	dex
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 3823

	lda BALL0
	sta SET_BALL_SPEED.BALL
	lda BALL0+1
	sta SET_BALL_SPEED.BALL+1
	lda #$4B
	sta SET_BALL_SPEED.SPEED
	lda #$02
	sta SET_BALL_SPEED.SPEED+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 3826

	lda #$00
	sta BALL0.FINESPEED
	sta BALL0.FINESPEED+1

; optimize OK (service.pas), line = 3828

	sta BALL1.INPLAY

; optimize OK (service.pas), line = 3829

	sta BALL2.INPLAY

; optimize OK (service.pas), line = 3831

	lda VAUS.X
	sta X

; --- WhileProlog
	jmp l_330B
l_330C

; -------------------  ASM Block 00000192  -------------------

      mva #$00 $d01a
      @: lda vcount
      cmp #110
      bne @-
      mva #$0f $d01a       
     
; optimize OK (service.pas), line = 3853

	lda <X
	sta MOUSECOORDS.X
	lda >X
	sta MOUSECOORDS.X+1
	jsr MOUSECOORDS

; optimize OK (service.pas), line = 3855

	lda X
	sta MOVE_VAUS.X
	lda #$B8
	sta MOVE_VAUS.Y
	jsr MOVE_VAUS

; optimize OK (service.pas), line = 3861

	lda BALL0.LAUNCH
	cmp #$01
	jne l_3325

; optimize FAIL (0, service.pas), line = 3863

	inc BALL0.STM

; optimize OK (service.pas), line = 3868

	lda BALL0.STM
	cmp #$FA
	jne l_333C
	lda #$00
	sta BALL0.LAUNCH
l_333C

; optimize OK (service.pas), line = 3871

	lda BALL0
	sta START_BALL.BALL
	lda BALL0+1
	sta START_BALL.BALL+1
	jsr START_BALL

; optimize FAIL ('MOUSECLICK', service.pas), line = 3874

	jsr MOUSECLICK
	lda MOUSECLICK.RESULT
	cmp #$01
	jne l_3356
	lda #$00
	sta BALL0.LAUNCH
l_3356

; optimize OK (service.pas), line = 3876

	lda BALL0.LAUNCH
	jne l_336F
	lda #$06
	sta XSFX.TSFX.INIT.@010180000.SFX
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.INIT.@010180000
l_336F
	jmp l_337D
l_3325

; optimize OK (service.pas), line = 3884

	lda BALL0.INPLAY
	jeq l_3389
	lda BALL0
	sta MOVE_BALL.BALL
	lda BALL0+1
	sta MOVE_BALL.BALL+1
	jsr MOVE_BALL
l_3389

; optimize OK (service.pas), line = 3885

	lda BALL1.INPLAY
	jeq l_339B
	lda BALL1
	sta MOVE_BALL.BALL
	lda BALL1+1
	sta MOVE_BALL.BALL+1
	jsr MOVE_BALL
l_339B

; optimize OK (service.pas), line = 3886

	lda BALL2.INPLAY
	jeq l_33AD
	lda BALL2
	sta MOVE_BALL.BALL
	lda BALL2+1
	sta MOVE_BALL.BALL+1
	jsr MOVE_BALL
l_33AD
l_337D

; optimize OK (service.pas), line = 3894

	lda BALL0.INPLAY
	jeq l_33BF
	lda BALL0
	sta CHECK_BALL.BALL
	lda BALL0+1
	sta CHECK_BALL.BALL+1
	jsr CHECK_BALL
l_33BF

; optimize OK (service.pas), line = 3895

	lda BALL1.INPLAY
	jeq l_33D1
	lda BALL1
	sta CHECK_BALL.BALL
	lda BALL1+1
	sta CHECK_BALL.BALL+1
	jsr CHECK_BALL
l_33D1

; optimize OK (service.pas), line = 3896

	lda BALL2.INPLAY
	jeq l_33E3
	lda BALL2
	sta CHECK_BALL.BALL
	lda BALL2+1
	sta CHECK_BALL.BALL+1
	jsr CHECK_BALL
l_33E3

; optimize FAIL ('CHECKSHINE', service.pas), line = 3913

	jsr CHECKSHINE

; optimize FAIL ('CHECK_LETTER', service.pas), line = 3914

	jsr CHECK_LETTER

; optimize OK (service.pas), line = 3915

	lda BALL0
	sta CHECK_BONUS_TYPE.B1
	lda BALL0+1
	sta CHECK_BONUS_TYPE.B1+1
	lda BALL1
	sta CHECK_BONUS_TYPE.B2
	lda BALL1+1
	sta CHECK_BONUS_TYPE.B2+1
	lda BALL2
	sta CHECK_BONUS_TYPE.B3
	lda BALL2+1
	sta CHECK_BONUS_TYPE.B3+1
	jsr CHECK_BONUS_TYPE

; optimize FAIL ('CHECK_FIRE', service.pas), line = 3916

	jsr CHECK_FIRE

; optimize FAIL ('CHECK_FLUX', service.pas), line = 3917

	jsr CHECK_FLUX

; optimize OK (service.pas), line = 3919

	lda VAUS.X
	add VAUS.WIDTH
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	ldy #1
	cmp #$00
	bne @+
	lda :STACKORIGIN+9
	cmp #$D7
@
	beq @+
	dey
@
	tya
	and SCRFLUX
	jeq l_3412
	jsr VAUS_OUT
l_3412

; optimize OK (service.pas), line = 3921

	lda VAUS.LETTER
	cmp #$04
	jne l_3428

; optimize OK (service.pas), line = 3923

	lda #$03
	sta BALLS_IN_PLAY

; optimize OK (service.pas), line = 3925

	lda #$00
	sta BALL0.BRWHIT

; optimize OK (service.pas), line = 3927

	mwy BALL1 :bp2
	ldy #$19
	mva:rpl adr.BALL0,y (:bp2),y-

; optimize OK (service.pas), line = 3928

	mwy BALL2 :bp2
	ldy #$19
	mva:rpl adr.BALL0,y (:bp2),y-

; optimize OK (service.pas), line = 3930

	lda BALL0
	sta GET_BALL_DIRECTION.BALL
	lda BALL0+1
	sta GET_BALL_DIRECTION.BALL+1
	jsr GET_BALL_DIRECTION
	lda GET_BALL_DIRECTION.RESULT
	sta TMP
	lda GET_BALL_DIRECTION.RESULT+1
	sta TMP+1

; optimize OK (service.pas), line = 3932

	lda #$00
	sta T1
	sta T1+1

; --- WhileProlog
	jmp l_3441
l_3442

; optimize OK (service.pas), line = 3934

	lda TMP
	sub #$5A
	sta TMP
	scs
	dec TMP+1

; optimize FAIL (0, service.pas), line = 3935

	inc T1
	sne
	inc T1+1
l_3441

; optimize OK (service.pas), line = 3933

	lda TMP
	cmp #$5A
	lda TMP+1
	sbc #$00
	svc
	eor #$80
	jpl l_3442

; optimize OK (service.pas), line = 3941

	lda BALL0.SPEED
	sta T2
	lda BALL0.SPEED+1
	sta T2+1

; optimize OK (service.pas), line = 3948

	ldy T1
	lda adr.MUL90_16,y
	sta T1
	lda adr.MUL90_16+16,y
	sta T1+1

; optimize OK (service.pas), line = 3950

	lda T1
	add #$1E
	sta SET_BALL_DIRECTION.ANGLE
	lda T1+1
	adc #$00
	sta SET_BALL_DIRECTION.ANGLE+1
	lda BALL0
	sta SET_BALL_DIRECTION.BALL
	lda BALL0+1
	sta SET_BALL_DIRECTION.BALL+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 3951

	lda T1
	add #$2D
	sta SET_BALL_DIRECTION.ANGLE
	lda T1+1
	adc #$00
	sta SET_BALL_DIRECTION.ANGLE+1
	lda BALL1
	sta SET_BALL_DIRECTION.BALL
	lda BALL1+1
	sta SET_BALL_DIRECTION.BALL+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 3952

	lda T1
	add #$3C
	sta SET_BALL_DIRECTION.ANGLE
	lda T1+1
	adc #$00
	sta SET_BALL_DIRECTION.ANGLE+1
	lda BALL2
	sta SET_BALL_DIRECTION.BALL
	lda BALL2+1
	sta SET_BALL_DIRECTION.BALL+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 3956

	lda BALL0
	sta SET_BALL_SPEED.BALL
	lda BALL0+1
	sta SET_BALL_SPEED.BALL+1
	lda T2
	sta SET_BALL_SPEED.SPEED
	lda T2+1
	sta SET_BALL_SPEED.SPEED+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 3957

	lda BALL1
	sta SET_BALL_SPEED.BALL
	lda BALL1+1
	sta SET_BALL_SPEED.BALL+1
	lda T2
	sta SET_BALL_SPEED.SPEED
	lda T2+1
	sta SET_BALL_SPEED.SPEED+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 3958

	lda BALL2
	sta SET_BALL_SPEED.BALL
	lda BALL2+1
	sta SET_BALL_SPEED.BALL+1
	lda T2
	sta SET_BALL_SPEED.SPEED
	lda T2+1
	sta SET_BALL_SPEED.SPEED+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 3960

	lda #$00
	sta VAUS.LETTER
l_3428

; optimize OK (service.pas), line = 3964

	lda BALLS_IN_PLAY
	cmp #$02
	jcc l_34A0
	lda #$00
	sta LETT.INCOMING
	sta LETT.INCOMING+1
l_34A0

; optimize OK (service.pas), line = 3968

	lda CUR_PLAYER
	asl @
	asl @
	tay
	lda adr.SCORE.PLAYER,y
	sta SCORES
	lda adr.SCORE.PLAYER+1,y
	sta SCORES+1
	lda adr.SCORE.PLAYER+2,y
	sta SCORES+2
	lda adr.SCORE.PLAYER+3,y
	sta SCORES+3

; optimize OK (service.pas), line = 3970

	lda OLD_SCORES+3
	cmp SCORES+3
	bne @+
	lda OLD_SCORES+2
	cmp SCORES+2
	bne @+
	lda OLD_SCORES+1
	cmp SCORES+1
	bne @+
	lda OLD_SCORES
	cmp SCORES
@
	jeq l_34BE

; optimize OK (service.pas), line = 3972

	ldy CUR_PLAYER
	lda adr.POS_DIGIT,y
	sta WRITE_SCORE.PY
	lda SCORES
	sta WRITE_SCORE.SC_
	lda SCORES+1
	sta WRITE_SCORE.SC_+1
	lda SCORES+2
	sta WRITE_SCORE.SC_+2
	lda SCORES+3
	sta WRITE_SCORE.SC_+3
	jsr WRITE_SCORE

; optimize OK (service.pas), line = 3974

	lda SCORES
	sta OLD_SCORES
	lda SCORES+1
	sta OLD_SCORES+1
	lda SCORES+2
	sta OLD_SCORES+2
	lda SCORES+3
	sta OLD_SCORES+3
l_34BE

; optimize OK (service.pas), line = 3980

	lda CUR_PLAYER
	asl @
	asl @
	tay
	lda adr.SCORE.PLAYER,y
	sta :STACKORIGIN+9
	lda adr.SCORE.PLAYER+1,y
	sta :STACKORIGIN+STACKWIDTH+9
	lda adr.SCORE.PLAYER+3,y
	cmp SCORE.HISCORE+3
	bne @+
	lda adr.SCORE.PLAYER+2,y
	cmp SCORE.HISCORE+2
	bne @+
	lda :STACKORIGIN+STACKWIDTH+9
	cmp SCORE.HISCORE+1
	bne @+
	lda :STACKORIGIN+9
	cmp SCORE.HISCORE
@
	jcc l_34E0
	jeq l_34E0

; optimize OK (service.pas), line = 3983

	lda adr.SCORE.PLAYER,y
	sta SCORE.HISCORE
	lda adr.SCORE.PLAYER+1,y
	sta SCORE.HISCORE+1
	lda adr.SCORE.PLAYER+2,y
	sta SCORE.HISCORE+2
	lda adr.SCORE.PLAYER+3,y
	sta SCORE.HISCORE+3

; optimize OK (service.pas), line = 3985

	lda #$80
	sta WRITE_SCORE.PY
	lda SCORE.HISCORE
	sta WRITE_SCORE.SC_
	lda SCORE.HISCORE+1
	sta WRITE_SCORE.SC_+1
	lda SCORE.HISCORE+2
	sta WRITE_SCORE.SC_+2
	lda SCORE.HISCORE+3
	sta WRITE_SCORE.SC_+3
	jsr WRITE_SCORE
l_34E0

; optimize OK (service.pas), line = 3992

	lda BALL0.LAUNCH
	jne l_3505
	lda BALL0.INPLAY
	jeq l_3505
	lda BALL0
	sta TEST_BALL.BALL
	lda BALL0+1
	sta TEST_BALL.BALL+1
	jsr TEST_BALL
l_3505

; optimize OK (service.pas), line = 3993

	lda BALL1.INPLAY
	jeq l_3517
	lda BALL1
	sta TEST_BALL.BALL
	lda BALL1+1
	sta TEST_BALL.BALL+1
	jsr TEST_BALL
l_3517

; optimize OK (service.pas), line = 3994

	lda BALL2.INPLAY
	jeq l_3529
	lda BALL2
	sta TEST_BALL.BALL
	lda BALL2+1
	sta TEST_BALL.BALL+1
	jsr TEST_BALL
l_3529

; optimize OK (service.pas), line = 4044

	lda BALL0.INPLAY
	jne l_353E

; optimize OK (service.pas), line = 4045

	lda BALL1.INPLAY
	jeq l_354B

; optimize OK (service.pas), line = 4046

	mwy BALL0 :bp2
	ldy #$19
	mva:rpl adr.BALL1,y (:bp2),y-

; optimize OK (service.pas), line = 4047

	lda #$00
	sta BALL1.INPLAY
	jmp l_355B
l_354B

; optimize OK (service.pas), line = 4049

	lda BALL2.INPLAY
	jeq l_3567

; optimize OK (service.pas), line = 4050

	mwy BALL0 :bp2
	ldy #$19
	mva:rpl adr.BALL2,y (:bp2),y-

; optimize OK (service.pas), line = 4051

	lda #$00
	sta BALL2.INPLAY
l_355B
l_3567
l_353E

; optimize OK (service.pas), line = 4055

	lda #$00
	sta BALLS_IN_PLAY

; optimize OK (service.pas), line = 4057

	lda BALL0.INPLAY
	jeq l_3582
	inc BALLS_IN_PLAY
l_3582

; optimize OK (service.pas), line = 4058

	lda BALL1.INPLAY
	jeq l_3595
	inc BALLS_IN_PLAY
l_3595

; optimize OK (service.pas), line = 4059

	lda BALL2.INPLAY
	jeq l_35A8
	inc BALLS_IN_PLAY
l_35A8

; optimize OK (service.pas), line = 4062

	lda BALL0.INPLAY
	jne l_35BE

; optimize OK (service.pas), line = 4064

	lda #$01
	sta BALL0.LAUNCH

; optimize OK (service.pas), line = 4065

	lda BALL0
	sta REMOVE_BALL.BALL
	lda BALL0+1
	sta REMOVE_BALL.BALL+1
	jsr REMOVE_BALL

; optimize FAIL ('DESTROY_VAUS', service.pas), line = 4066

	jsr DESTROY_VAUS

; optimize OK (service.pas), line = 4067

	ldy CUR_PLAYER
	lda adr.SCORE.LIVES,y
	sub #$01
	sta adr.SCORE.LIVES,y

; optimize OK (service.pas), line = 4068

	lda WALL_P
	sta @move.dst
	lda CUR_PLAYER
	add WALL_P+1
	sta @move.dst+1
	lda WALL
	sta @move.src
	lda WALL+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move

; optimize FAIL ('NOSOUND', service.pas), line = 4076

	jsr NOSOUND
l_35BE
l_330B

; optimize OK (service.pas), line = 3839

	lda REMAIN_BLK
	jeq l_330Cw
	lda BALL0.INPLAY
	jeq l_330Cw
	lda SCORE.ABORTPLAY
	jeq l_330C
l_330Cw

; optimize OK (service.pas), line = 4132

	lda #$00
	sta RESULT

; optimize OK (service.pas), line = 4133

	lda REMAIN_BLK
	jne l_360C
	lda #$01
	sta RESULT
l_360C
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$0373
X	= DATAORIGIN+$0374
TMP	= DATAORIGIN+$0375
T1	= DATAORIGIN+$0377
T2	= DATAORIGIN+$0379
adr.BALL0	= DATAORIGIN+$037B	; [26] RECORD
.var BALL0	= adr.BALL0 .word
BALL0.X	= DATAORIGIN+$037B
BALL0.Y	= DATAORIGIN+$037D
BALL0.FINEX	= DATAORIGIN+$037F
BALL0.FINEY	= DATAORIGIN+$0380
BALL0.OLDX	= DATAORIGIN+$0381
BALL0.OLDY	= DATAORIGIN+$0383
BALL0.SPEED	= DATAORIGIN+$0385
BALL0.FINESPEED	= DATAORIGIN+$0387
BALL0.SPEEDX	= DATAORIGIN+$0389
BALL0.SPEEDY	= DATAORIGIN+$038B
BALL0.SBD	= DATAORIGIN+$038D
BALL0.BRWHIT	= DATAORIGIN+$038F
BALL0.INPLAY	= DATAORIGIN+$0390
BALL0.LAUNCH	= DATAORIGIN+$0391
BALL0.ONVAUS	= DATAORIGIN+$0392
BALL0.STM	= DATAORIGIN+$0394
adr.BALL1	= DATAORIGIN+$0395	; [26] RECORD
.var BALL1	= adr.BALL1 .word
BALL1.X	= DATAORIGIN+$0395
BALL1.Y	= DATAORIGIN+$0397
BALL1.FINEX	= DATAORIGIN+$0399
BALL1.FINEY	= DATAORIGIN+$039A
BALL1.OLDX	= DATAORIGIN+$039B
BALL1.OLDY	= DATAORIGIN+$039D
BALL1.SPEED	= DATAORIGIN+$039F
BALL1.FINESPEED	= DATAORIGIN+$03A1
BALL1.SPEEDX	= DATAORIGIN+$03A3
BALL1.SPEEDY	= DATAORIGIN+$03A5
BALL1.SBD	= DATAORIGIN+$03A7
BALL1.BRWHIT	= DATAORIGIN+$03A9
BALL1.INPLAY	= DATAORIGIN+$03AA
BALL1.LAUNCH	= DATAORIGIN+$03AB
BALL1.ONVAUS	= DATAORIGIN+$03AC
BALL1.STM	= DATAORIGIN+$03AE
adr.BALL2	= DATAORIGIN+$03AF	; [26] RECORD
.var BALL2	= adr.BALL2 .word
BALL2.X	= DATAORIGIN+$03AF
BALL2.Y	= DATAORIGIN+$03B1
BALL2.FINEX	= DATAORIGIN+$03B3
BALL2.FINEY	= DATAORIGIN+$03B4
BALL2.OLDX	= DATAORIGIN+$03B5
BALL2.OLDY	= DATAORIGIN+$03B7
BALL2.SPEED	= DATAORIGIN+$03B9
BALL2.FINESPEED	= DATAORIGIN+$03BB
BALL2.SPEEDX	= DATAORIGIN+$03BD
BALL2.SPEEDY	= DATAORIGIN+$03BF
BALL2.SBD	= DATAORIGIN+$03C1
BALL2.BRWHIT	= DATAORIGIN+$03C3
BALL2.INPLAY	= DATAORIGIN+$03C4
BALL2.LAUNCH	= DATAORIGIN+$03C5
BALL2.ONVAUS	= DATAORIGIN+$03C6
BALL2.STM	= DATAORIGIN+$03C8
SCORES	= DATAORIGIN+$03C9

@VarData	= X
@VarDataSize	= 89

	rts						; ret
.endl

.local	CHOOSE_START_WALL				; FUNCTION

; optimize OK (service.pas), line = 4160

	lda #$01
	sta ST
	lda #$00
	sta ST+1

; optimize OK (service.pas), line = 4218

	lda ST
	sta RESULT
	lda ST+1
	sta RESULT+1
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$03D5
ST	= DATAORIGIN+$03D7

@VarData	= ST
@VarDataSize	= 2

	rts						; ret
.endl

.local	SET_START_PARAMETERS				; PROCEDURE

; optimize OK (service.pas), line = 4227

	lda #$01
	sta OLD_SCORES
	lda #$00
	sta OLD_SCORES+1
	sta OLD_SCORES+2
	sta OLD_SCORES+3

; optimize OK (service.pas), line = 4229

	lda #$01
	sta X

l_3631
; --- ForToDoCondition
	lda X
	cmp #$03
	jcs l_363F

; optimize OK (service.pas), line = 4231

	asl @
	asl @
	tay
	lda #$00
	sta adr.SCORE.PLAYER,y
	sta adr.SCORE.PLAYER+1,y
	sta adr.SCORE.PLAYER+2,y
	sta adr.SCORE.PLAYER+3,y

; optimize OK (service.pas), line = 4232

	ldy X
	lda #$05
	sta adr.SCORE.LIVES,y

; optimize OK (service.pas), line = 4233

	lda #$01
	sta adr.SCORE.WALL_N,y

; optimize OK (service.pas), line = 4234

	lda WALL_P
	sta @move.dst
	lda X
	add WALL_P+1
	sta @move.dst+1
	lda ALL_WALLS
	sta @move.src
	lda ALL_WALLS+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move

; optimize OK (service.pas), line = 4236

	ldy X
	lda #$00
	sta adr.SCORE.ROUNDSEL,y

; --- ForToDoEpilog
	inc X
	jne l_3631
l_363F

; optimize OK (service.pas), line = 4239

	lda #$01
	sta CUR_PLAYER

; ------------------------------------------------------------

X	= DATAORIGIN+$03D9

@VarData	= X
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MAINSCREEN					; FUNCTION

; optimize FAIL ('NOSOUND', service.pas), line = 4273

	jsr NOSOUND

; optimize OK (service.pas), line = 4274

	lda #$00
	sta SCORE.ABORTPLAY

; -------------------  ASM Block 00000193  -------------------

      fxs FX_MEMS #$80
    
; optimize OK (service.pas), line = 4291

	lda #$40
	sta BLITTEMP.@0201810000181000.SWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.SWIDTH+1
	lda #$40
	sta BLITTEMP.@0201810000181000.DWIDTH
	lda #$01
	sta BLITTEMP.@0201810000181000.DWIDTH+1
	jsr BLITTEMP.@0201810000181000

; optimize OK (service.pas), line = 4292

	lda #$80
	sta BLITTEMP.@040180000018100001820000182000.SRC
	lda #$D0
	sta BLITTEMP.@040180000018100001820000182000.SRC+1
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.SRC+2
	sta BLITTEMP.@040180000018100001820000182000.SRC+3
	sta BLITTEMP.@040180000018100001820000182000.DST
	sta BLITTEMP.@040180000018100001820000182000.DST+1
	lda #$03
	sta BLITTEMP.@040180000018100001820000182000.DST+2
	lda #$00
	sta BLITTEMP.@040180000018100001820000182000.DST+3
	lda #$40
	sta BLITTEMP.@040180000018100001820000182000.W
	lda #$01
	sta BLITTEMP.@040180000018100001820000182000.W+1
	lda #$C8
	sta BLITTEMP.@040180000018100001820000182000.H
	jsr BLITTEMP.@040180000018100001820000182000

; -------------------  ASM Block 00000194  -------------------

      fxs FX_MEMS #$00
    
; optimize OK (service.pas), line = 4335

	lda #$01
	sta RESULT
	lda #$00
	sta RESULT+1
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$03DA
K	= DATAORIGIN+$03DC
IK	= DATAORIGIN+$03DE

@VarData	= K
@VarDataSize	= 4

	rts						; ret
.endl

.local	START_GAME					; PROCEDURE

; optimize FAIL ('SET_START_PARAMETERS', service.pas), line = 4343

	jsr SET_START_PARAMETERS

; optimize OK (service.pas), line = 4344

	lda PLAYERS+1
	bne @+
	lda PLAYERS
	cmp #$01
@
	jne l_36A1
	lda #$00
	sta adr.SCORE.LIVES+$02
l_36A1

; optimize OK (service.pas), line = 4347

	lda #$00
	sta TRAINER

; optimize OK (service.pas), line = 4348

	lda WALL
	sta @move.dst
	lda WALL+1
	sta @move.dst+1
	lda WALL_P
	sta @move.src
	lda CUR_PLAYER
	add WALL_P+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move

; optimize FAIL ('SET_WALL', service.pas), line = 4352

	jsr SET_WALL

; optimize FAIL ('FILL_PICTURE_WITH_PATTERN', service.pas), line = 4354

	jsr FILL_PICTURE_WITH_PATTERN

; optimize OK (service.pas), line = 4356

	lda #$00
	sta HLP
	sta HLP+1

; optimize OK (service.pas), line = 4357

	lda #$40
	sta BLITBOX.W
	lda #$01
	sta BLITBOX.W+1
	lda #$C8
	sta BLITBOX.H
	jsr BLITBOX

; optimize OK (service.pas), line = 4364

	lda adr.SCORE.PLAYER+$04
	sta WRITE_SCORE.SC_
	lda adr.SCORE.PLAYER+1+$04
	sta WRITE_SCORE.SC_+1
	lda adr.SCORE.PLAYER+2+$04
	sta WRITE_SCORE.SC_+2
	lda adr.SCORE.PLAYER+3+$04
	sta WRITE_SCORE.SC_+3
	lda #$3C
	sta WRITE_SCORE.PY
	jsr WRITE_SCORE

; optimize OK (service.pas), line = 4365

	lda adr.SCORE.PLAYER+$08
	sta WRITE_SCORE.SC_
	lda adr.SCORE.PLAYER+1+$08
	sta WRITE_SCORE.SC_+1
	lda adr.SCORE.PLAYER+2+$08
	sta WRITE_SCORE.SC_+2
	lda adr.SCORE.PLAYER+3+$08
	sta WRITE_SCORE.SC_+3
	lda #$5D
	sta WRITE_SCORE.PY
	jsr WRITE_SCORE

; optimize OK (service.pas), line = 4366

	lda #$80
	sta WRITE_SCORE.PY
	lda SCORE.HISCORE
	sta WRITE_SCORE.SC_
	lda SCORE.HISCORE+1
	sta WRITE_SCORE.SC_+1
	lda SCORE.HISCORE+2
	sta WRITE_SCORE.SC_+2
	lda SCORE.HISCORE+3
	sta WRITE_SCORE.SC_+3
	jsr WRITE_SCORE

; --- RepeatUntilProlog
l_36CF

; --- RepeatUntilProlog
l_36D0

; optimize OK (service.pas), line = 4376

	ldy CUR_PLAYER
	lda adr.SCORE.ROUNDSEL,y
	jne l_36E2

; optimize FAIL (1, service.pas), line = 4378

	inx
	mva CUR_PLAYER :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr CHOOSE_START_WALL
	inx
	mva CHOOSE_START_WALL.RESULT :STACKORIGIN,x
	mva CHOOSE_START_WALL.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	ldy :STACKORIGIN-1,x
	lda :STACKORIGIN,x
	sta adr.SCORE.WALL_N,y
	dex
	dex

; optimize OK (service.pas), line = 4381

	lda #$00
	sta :STACKORIGIN+9
	lda CUR_PLAYER
	sta :STACKORIGIN+STACKWIDTH+9
	ldy CUR_PLAYER
	lda adr.SCORE.WALL_N,y
	sub #$01
	sta :eax+1
	lda WALL_P
	add :STACKORIGIN+9
	sta @move.dst
	lda WALL_P+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta @move.dst+1
	lda ALL_WALLS
	sta @move.src
	lda :eax+1
	add ALL_WALLS+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move

; optimize OK (service.pas), line = 4385

	ldy CUR_PLAYER
	lda #$01
	sta adr.SCORE.ROUNDSEL,y
l_36E2

; optimize OK (service.pas), line = 4389

	lda WALL
	sta @move.dst
	lda WALL+1
	sta @move.dst+1
	lda WALL_P
	sta @move.src
	lda CUR_PLAYER
	add WALL_P+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move

; optimize FAIL ('SET_WALL', service.pas), line = 4390

	jsr SET_WALL

; optimize FAIL ('BOUNCEBALL', service.pas), line = 4395

	jsr BOUNCEBALL
	lda BOUNCEBALL.RESULT
	sta NWALL

; optimize OK (service.pas), line = 4398

	jeq l_3730

; optimize OK (service.pas), line = 4401

	ldy CUR_PLAYER
	lda adr.SCORE.WALL_N,y
	add #$01
	sta adr.SCORE.WALL_N,y

; optimize OK (service.pas), line = 4404

	lda TOTALWALL
	cmp adr.SCORE.WALL_N,y
	jcs l_374C

; optimize OK (service.pas), line = 4405

	lda #$01
	sta adr.SCORE.WALL_N,y
l_374C

; optimize OK (service.pas), line = 4408

	lda #$00
	sta :STACKORIGIN+9
	lda CUR_PLAYER
	sta :STACKORIGIN+STACKWIDTH+9
	ldy CUR_PLAYER
	lda adr.SCORE.WALL_N,y
	sub #$01
	sta :eax+1
	lda WALL_P
	add :STACKORIGIN+9
	sta @move.dst
	lda WALL_P+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta @move.dst+1
	lda ALL_WALLS
	sta @move.src
	lda :eax+1
	add ALL_WALLS+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move
	jmp l_377E
l_3730

; optimize OK (service.pas), line = 4414

	ldy CUR_PLAYER
	lda adr.SCORE.LIVES,y
	jne l_3793
	jsr GAME_OVER
l_377E
l_3793

; optimize OK (service.pas), line = 4419

	lda NWALL
	jne l_36D0

; optimize FAIL (0, service.pas), line = 4422

	inc CUR_PLAYER

; optimize OK (service.pas), line = 4423

	lda PLAYERS
	cmp CUR_PLAYER
	lda PLAYERS+1
	sbc #$00
	svc
	eor #$80
	jpl l_37BB
	lda #$01
	sta CUR_PLAYER
l_37BB

; optimize OK (service.pas), line = 4429

	ldy CUR_PLAYER
	lda adr.SCORE.LIVES,y
	jne l_37D7
	lda #$03
	sub CUR_PLAYER
	sta CUR_PLAYER
l_37D7

; optimize OK (service.pas), line = 4434

	ldy #1
	lda adr.SCORE.LIVES+$01
	beq @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda adr.SCORE.LIVES+$02
	beq @+
	dey
@
	tya
	and :STACKORIGIN+9
	ora SCORE.ABORTPLAY
	jeq l_36CF

; ------------------------------------------------------------

PLAYERS	= DATAORIGIN+$03E0
NWALL	= DATAORIGIN+$03E2

@VarData	= PLAYERS
@VarDataSize	= 3

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	INIT_GAME					; PROCEDURE

; optimize FAIL ('NOSOUND', arkanoid_vbxe.pas), line = 1029

	jsr NOSOUND

; optimize FAIL ('SYSTEM.RANDOMIZE', arkanoid_vbxe.pas), line = 1031

	jsr SYSTEM.RANDOMIZE

; optimize FAIL ('XSFX.TSFX.CLEAR', arkanoid_vbxe.pas), line = 1033

	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.CLEAR

; optimize OK (arkanoid_vbxe.pas), line = 1035

	lda #$AA
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$20
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1036

	lda #$CD
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$20
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1037

	lda #$DE
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$20
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1038

	lda #$EF
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$20
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1039

	lda #$00
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$21
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1040

	lda #$14
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$21
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1041

	lda #$37
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$21
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1042

	lda #$5A
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$21
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1043

	lda #$7D
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$21
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1044

	lda #$A0
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$21
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1045

	lda #$41
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$22
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize OK (arkanoid_vbxe.pas), line = 1046

	lda #$70
	sta XSFX.TSFX.ADD.@010188000.ASFX
	lda #$22
	sta XSFX.TSFX.ADD.@010188000.ASFX+1
	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.ADD.@010188000

; optimize FAIL ('XSFX.TSFX.PLAY', arkanoid_vbxe.pas), line = 1048

	lda SFX
	ldy SFX+1
	jsr XSFX.TSFX.PLAY

; optimize FAIL ('INITSVGA', arkanoid_vbxe.pas), line = 1051

	jsr INITSVGA

; optimize FAIL ('INITROWARRAY', arkanoid_vbxe.pas), line = 1052

	jsr INITROWARRAY

; optimize OK (btm.inc), line = 1

	lda #$00
	sta EXPLOSION.OFS
	lda #$60
	sta EXPLOSION.OFS+1
	lda #$00
	sta EXPLOSION.OFS+2
	sta EXPLOSION.OFS+3

; optimize OK (btm.inc), line = 2

	lda #$2A
	sta EXPLOSION.WIDTH
	lda #$00
	sta EXPLOSION.WIDTH+1

; optimize OK (btm.inc), line = 3

	lda #$72
	sta EXPLOSION.HEIGHT

; optimize OK (btm.inc), line = 5

	lda #$B4
	sta NEWVAUS.OFS
	lda #$72
	sta NEWVAUS.OFS+1
	lda #$00
	sta NEWVAUS.OFS+2
	sta NEWVAUS.OFS+3

; optimize OK (btm.inc), line = 6

	lda #$29
	sta NEWVAUS.WIDTH
	lda #$00
	sta NEWVAUS.WIDTH+1

; optimize OK (btm.inc), line = 7

	lda #$C1
	sta NEWVAUS.HEIGHT

; optimize OK (btm.inc), line = 9

	lda #$9D
	sta SHINEWALL.OFS
	lda #$91
	sta SHINEWALL.OFS+1
	lda #$00
	sta SHINEWALL.OFS+2
	sta SHINEWALL.OFS+3

; optimize OK (btm.inc), line = 10

	lda #$10
	sta SHINEWALL.WIDTH
	lda #$00
	sta SHINEWALL.WIDTH+1

; optimize OK (btm.inc), line = 11

	lda #$50
	sta SHINEWALL.HEIGHT

; optimize OK (btm.inc), line = 13

	lda #$9D
	sta MINIVAUS.OFS
	lda #$96
	sta MINIVAUS.OFS+1
	lda #$00
	sta MINIVAUS.OFS+2
	sta MINIVAUS.OFS+3

; optimize OK (btm.inc), line = 14

	lda #$14
	sta MINIVAUS.WIDTH
	lda #$00
	sta MINIVAUS.WIDTH+1

; optimize OK (btm.inc), line = 15

	lda #$05
	sta MINIVAUS.HEIGHT

; optimize OK (btm.inc), line = 17

	lda #$01
	sta LEVELSEL.OFS
	lda #$97
	sta LEVELSEL.OFS+1
	lda #$00
	sta LEVELSEL.OFS+2
	sta LEVELSEL.OFS+3

; optimize OK (btm.inc), line = 18

	lda #$15
	sta LEVELSEL.WIDTH
	lda #$00
	sta LEVELSEL.WIDTH+1

; optimize OK (btm.inc), line = 19

	lda #$5F
	sta LEVELSEL.HEIGHT

; optimize OK (btm.inc), line = 21

	lda #$CC
	sta LETTERS.OFS
	lda #$9E
	sta LETTERS.OFS+1
	lda #$00
	sta LETTERS.OFS+2
	sta LETTERS.OFS+3

; optimize OK (btm.inc), line = 22

	lda #$80
	sta LETTERS.WIDTH
	lda #$00
	sta LETTERS.WIDTH+1

; optimize OK (btm.inc), line = 23

	lda #$38
	sta LETTERS.HEIGHT

; optimize OK (btm.inc), line = 25

	lda #$CC
	sta NORMAL.OFS
	lda #$BA
	sta NORMAL.OFS+1
	lda #$00
	sta NORMAL.OFS+2
	sta NORMAL.OFS+3

; optimize OK (btm.inc), line = 26

	lda #$20
	sta NORMAL.WIDTH
	lda #$00
	sta NORMAL.WIDTH+1

; optimize OK (btm.inc), line = 27

	lda #$07
	sta NORMAL.HEIGHT

; optimize OK (btm.inc), line = 29

	lda #$AC
	sta LASERS.OFS
	lda #$BB
	sta LASERS.OFS+1
	lda #$00
	sta LASERS.OFS+2
	sta LASERS.OFS+3

; optimize OK (btm.inc), line = 30

	lda #$20
	sta LASERS.WIDTH
	lda #$00
	sta LASERS.WIDTH+1

; optimize OK (btm.inc), line = 31

	lda #$07
	sta LASERS.HEIGHT

; optimize OK (btm.inc), line = 33

	lda #$8C
	sta ENLARGED.OFS
	lda #$BC
	sta ENLARGED.OFS+1
	lda #$00
	sta ENLARGED.OFS+2
	sta ENLARGED.OFS+3

; optimize OK (btm.inc), line = 34

	lda #$40
	sta ENLARGED.WIDTH
	lda #$00
	sta ENLARGED.WIDTH+1

; optimize OK (btm.inc), line = 35

	lda #$07
	sta ENLARGED.HEIGHT

; optimize OK (btm.inc), line = 37

	lda #$4C
	sta SHOOTS.OFS
	lda #$BE
	sta SHOOTS.OFS+1
	lda #$00
	sta SHOOTS.OFS+2
	sta SHOOTS.OFS+3

; optimize OK (btm.inc), line = 38

	lda #$0D
	sta SHOOTS.WIDTH
	lda #$00
	sta SHOOTS.WIDTH+1

; optimize OK (btm.inc), line = 39

	lda #$08
	sta SHOOTS.HEIGHT

; optimize OK (btm.inc), line = 41

	lda #$B4
	sta BALLDATA.OFS
	lda #$BE
	sta BALLDATA.OFS+1
	lda #$00
	sta BALLDATA.OFS+2
	sta BALLDATA.OFS+3

; optimize OK (btm.inc), line = 42

	lda #$05
	sta BALLDATA.WIDTH
	lda #$00
	sta BALLDATA.WIDTH+1

; optimize OK (btm.inc), line = 43

	lda #$05
	sta BALLDATA.HEIGHT

; optimize OK (btm.inc), line = 45

	lda #$CD
	sta PATTERN0.OFS
	lda #$BE
	sta PATTERN0.OFS+1
	lda #$00
	sta PATTERN0.OFS+2
	sta PATTERN0.OFS+3

; optimize OK (btm.inc), line = 46

	lda #$1A
	sta PATTERN0.WIDTH
	lda #$00
	sta PATTERN0.WIDTH+1

; optimize OK (btm.inc), line = 47

	lda #$18
	sta PATTERN0.HEIGHT

; optimize OK (btm.inc), line = 49

	lda #$3D
	sta PATTERN1.OFS
	lda #$C1
	sta PATTERN1.OFS+1
	lda #$00
	sta PATTERN1.OFS+2
	sta PATTERN1.OFS+3

; optimize OK (btm.inc), line = 50

	lda #$0E
	sta PATTERN1.WIDTH
	lda #$00
	sta PATTERN1.WIDTH+1

; optimize OK (btm.inc), line = 51

	lda #$0E
	sta PATTERN1.HEIGHT

; optimize OK (btm.inc), line = 53

	lda #$01
	sta PATTERN2.OFS
	lda #$C2
	sta PATTERN2.OFS+1
	lda #$00
	sta PATTERN2.OFS+2
	sta PATTERN2.OFS+3

; optimize OK (btm.inc), line = 54

	lda #$26
	sta PATTERN2.WIDTH
	lda #$00
	sta PATTERN2.WIDTH+1

; optimize OK (btm.inc), line = 55

	lda #$23
	sta PATTERN2.HEIGHT

; optimize OK (btm.inc), line = 57

	lda #$33
	sta PATTERN3.OFS
	lda #$C7
	sta PATTERN3.OFS+1
	lda #$00
	sta PATTERN3.OFS+2
	sta PATTERN3.OFS+3

; optimize OK (btm.inc), line = 58

	lda #$1C
	sta PATTERN3.WIDTH
	lda #$00
	sta PATTERN3.WIDTH+1

; optimize OK (btm.inc), line = 59

	lda #$1D
	sta PATTERN3.HEIGHT

; optimize OK (btm.inc), line = 61

	lda #$5F
	sta PATTERN4.OFS
	lda #$CA
	sta PATTERN4.OFS+1
	lda #$00
	sta PATTERN4.OFS+2
	sta PATTERN4.OFS+3

; optimize OK (btm.inc), line = 62

	lda #$1E
	sta PATTERN4.WIDTH
	lda #$00
	sta PATTERN4.WIDTH+1

; optimize OK (btm.inc), line = 63

	lda #$1E
	sta PATTERN4.HEIGHT

; optimize OK (arkanoid_vbxe.pas), line = 1059

	lda #$20
	sta TOTALWALL

; optimize OK (arkanoid_vbxe.pas), line = 1061

	lda #$50
	sta SCORE.HISCORE
	lda #$C3
	sta SCORE.HISCORE+1
	lda #$00
	sta SCORE.HISCORE+2
	sta SCORE.HISCORE+3

; optimize OK (arkanoid_vbxe.pas), line = 1064

	lda #$01
	sta SOUND_ON

; optimize OK (arkanoid_vbxe.pas), line = 1065

	lda #$03
	sta LV
	lda #$00
	sta LV+1

; --- RepeatUntilProlog
l_38F8

; optimize FAIL ('MAINSCREEN', arkanoid_vbxe.pas), line = 1072

	jsr MAINSCREEN
	lda MAINSCREEN.RESULT
	sta SCORE.PL_NUMB

; optimize OK (arkanoid_vbxe.pas), line = 1074

	jeq l_390E
	lda #$01
	sta START_GAME.PLAYERS
	lda #$00
	sta START_GAME.PLAYERS+1
	jsr START_GAME
l_390E

; optimize OK (arkanoid_vbxe.pas), line = 1077

	lda SCORE.PL_NUMB
	cmp #$01
	jcs l_38F8

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_0022

; optimize FAIL ('INIT_GAME', arkanoid_vbxe.pas), line = 1085

	jsr INIT_GAME

; ------------------------------------------------------------

VBXE_DIGIT	= $5000
VBXE_DATA	= $6000
PLAYSCREEN_OFS	= $20000
VRAM	= $30000
PATTERN_TEMP	= $40000
EXPLOSION_OFS	= $6000
SHINEWALL_OFS	= $919D
LETTERS_OFS	= $9ECC
MINIVAUS_OFS	= $969D
SHOOTS_OFS	= $BE4C
BALLDATA_OFS	= $BEB4
PRESENTS_OFS	= $D080
FLUX2_OFS	= $1CA80
MINIVAUS_WIDTH	= $14
MINIVAUS_HEIGHT	= $05
EXPLOSION_WIDTH	= $2A
SHOOTS_WIDTH	= $0D
SHOOTS_HEIGHT	= $08
ERR1	= $01
ERR2	= $02
ERR3	= $03
ERR4	= $04
SCRMIN	= $0A
SCRMAX	= $D8
SCRTOP	= $0C
SCRBOT	= $C8
VAUS_W	= $22
VAUS_H	= $04
VAUS_LINE	= $B8
EMP	= $FF
BALLDIM	= $05
BALLSPOT	= $03
BALLDEV	= $1E
SPEEDFLASH	= $0A
adr.FLASH	= CODEORIGIN+$005E
.var FLASH	= adr.FLASH .word
adr.SCORE_WALL	= CODEORIGIN+$0069
.var SCORE_WALL	= adr.SCORE_WALL .word
adr.EMERG_DEV	= CODEORIGIN+$007F
.var EMERG_DEV	= adr.EMERG_DEV .word
adr.COLORBLOCK	= CODEORIGIN+$0088
.var COLORBLOCK	= adr.COLORBLOCK .word
GRAYDOWN	= $01
STARTWALL	= $01
BALLSPEED	= $024B
MAXSPEED	= $03FF
MAXBRWHIT	= $64
PATNUMBER	= $04
adr.POS_DIGIT	= CODEORIGIN+$0092
.var POS_DIGIT	= adr.POS_DIGIT .word
adr.LEVEL	= CODEORIGIN+$0096
.var LEVEL	= adr.LEVEL .word
SBDIR	= $0258
DEFLEVEL	= $03
LETTER_PROB	= $012C
LETTER_DROP	= $03E8
LETTER_FRM	= $08
LETTER_SBF	= $05
adr.LETTER_DIS	= CODEORIGIN+$00A2
.var LETTER_DIS	= adr.LETTER_DIS .word
FLUXLEVEL	= $B1
adr.SFX1	= CODEORIGIN+$00AA
.var SFX1	= adr.SFX1 .word
adr.SFX2	= CODEORIGIN+$00CD
.var SFX2	= adr.SFX2 .word
adr.SFX3	= CODEORIGIN+$00DE
.var SFX3	= adr.SFX3 .word
adr.SFX4	= CODEORIGIN+$00EF
.var SFX4	= adr.SFX4 .word
adr.SFX5	= CODEORIGIN+$0100
.var SFX5	= adr.SFX5 .word
adr.SFX6	= CODEORIGIN+$0114
.var SFX6	= adr.SFX6 .word
adr.SFX7	= CODEORIGIN+$0137
.var SFX7	= adr.SFX7 .word
adr.SFX8	= CODEORIGIN+$015A
.var SFX8	= adr.SFX8 .word
adr.SFX9	= CODEORIGIN+$017D
.var SFX9	= adr.SFX9 .word
adr.SFX10	= CODEORIGIN+$01A0
.var SFX10	= adr.SFX10 .word
adr.SFX11	= CODEORIGIN+$0241
.var SFX11	= adr.SFX11 .word
adr.SFX12	= CODEORIGIN+$0270
.var SFX12	= adr.SFX12 .word
adr.BLT	= $B100
.var BLT	= adr.BLT .word
adr.BLT.SRC_ADR	= $B100
.var BLT.SRC_ADR	= adr.BLT.SRC_ADR .word
BLT.SRC_ADR.BYTE0	= $B100
BLT.SRC_ADR.BYTE1	= $B101
BLT.SRC_ADR.BYTE2	= $B102
BLT.SRC_STEP_Y	= $B103
BLT.SRC_STEP_X	= $B105
adr.BLT.DST_ADR	= $B106
.var BLT.DST_ADR	= adr.BLT.DST_ADR .word
BLT.DST_ADR.BYTE0	= $B106
BLT.DST_ADR.BYTE1	= $B107
BLT.DST_ADR.BYTE2	= $B108
BLT.DST_STEP_Y	= $B109
BLT.DST_STEP_X	= $B10B
BLT.BLT_WIDTH	= $B10C
BLT.BLT_HEIGHT	= $B10E
BLT.BLT_AND_MASK	= $B10F
BLT.BLT_XOR_MASK	= $B110
BLT.BLT_COLLISION_MASK	= $B111
BLT.BLT_ZOOM	= $B112
BLT.PATTERN_FEATURE	= $B113
BLT.BLT_CONTROL	= $B114
adr.BLT_LETTER	= $B115
.var BLT_LETTER	= adr.BLT_LETTER .word
adr.BLT_LETTER.SRC_ADR	= $B115
.var BLT_LETTER.SRC_ADR	= adr.BLT_LETTER.SRC_ADR .word
BLT_LETTER.SRC_ADR.BYTE0	= $B115
BLT_LETTER.SRC_ADR.BYTE1	= $B116
BLT_LETTER.SRC_ADR.BYTE2	= $B117
BLT_LETTER.SRC_STEP_Y	= $B118
BLT_LETTER.SRC_STEP_X	= $B11A
adr.BLT_LETTER.DST_ADR	= $B11B
.var BLT_LETTER.DST_ADR	= adr.BLT_LETTER.DST_ADR .word
BLT_LETTER.DST_ADR.BYTE0	= $B11B
BLT_LETTER.DST_ADR.BYTE1	= $B11C
BLT_LETTER.DST_ADR.BYTE2	= $B11D
BLT_LETTER.DST_STEP_Y	= $B11E
BLT_LETTER.DST_STEP_X	= $B120
BLT_LETTER.BLT_WIDTH	= $B121
BLT_LETTER.BLT_HEIGHT	= $B123
BLT_LETTER.BLT_AND_MASK	= $B124
BLT_LETTER.BLT_XOR_MASK	= $B125
BLT_LETTER.BLT_COLLISION_MASK	= $B126
BLT_LETTER.BLT_ZOOM	= $B127
BLT_LETTER.PATTERN_FEATURE	= $B128
BLT_LETTER.BLT_CONTROL	= $B129
adr.BLT_BOX	= $B12A
.var BLT_BOX	= adr.BLT_BOX .word
adr.BLT_BOX.SRC_ADR	= $B12A
.var BLT_BOX.SRC_ADR	= adr.BLT_BOX.SRC_ADR .word
BLT_BOX.SRC_ADR.BYTE0	= $B12A
BLT_BOX.SRC_ADR.BYTE1	= $B12B
BLT_BOX.SRC_ADR.BYTE2	= $B12C
BLT_BOX.SRC_STEP_Y	= $B12D
BLT_BOX.SRC_STEP_X	= $B12F
adr.BLT_BOX.DST_ADR	= $B130
.var BLT_BOX.DST_ADR	= adr.BLT_BOX.DST_ADR .word
BLT_BOX.DST_ADR.BYTE0	= $B130
BLT_BOX.DST_ADR.BYTE1	= $B131
BLT_BOX.DST_ADR.BYTE2	= $B132
BLT_BOX.DST_STEP_Y	= $B133
BLT_BOX.DST_STEP_X	= $B135
BLT_BOX.BLT_WIDTH	= $B136
BLT_BOX.BLT_HEIGHT	= $B138
BLT_BOX.BLT_AND_MASK	= $B139
BLT_BOX.BLT_XOR_MASK	= $B13A
BLT_BOX.BLT_COLLISION_MASK	= $B13B
BLT_BOX.BLT_ZOOM	= $B13C
BLT_BOX.PATTERN_FEATURE	= $B13D
BLT_BOX.BLT_CONTROL	= $B13E
adr.BLT_ZERO	= $B13F
.var BLT_ZERO	= adr.BLT_ZERO .word
adr.BLT_ZERO.SRC_ADR	= $B13F
.var BLT_ZERO.SRC_ADR	= adr.BLT_ZERO.SRC_ADR .word
BLT_ZERO.SRC_ADR.BYTE0	= $B13F
BLT_ZERO.SRC_ADR.BYTE1	= $B140
BLT_ZERO.SRC_ADR.BYTE2	= $B141
BLT_ZERO.SRC_STEP_Y	= $B142
BLT_ZERO.SRC_STEP_X	= $B144
adr.BLT_ZERO.DST_ADR	= $B145
.var BLT_ZERO.DST_ADR	= adr.BLT_ZERO.DST_ADR .word
BLT_ZERO.DST_ADR.BYTE0	= $B145
BLT_ZERO.DST_ADR.BYTE1	= $B146
BLT_ZERO.DST_ADR.BYTE2	= $B147
BLT_ZERO.DST_STEP_Y	= $B148
BLT_ZERO.DST_STEP_X	= $B14A
BLT_ZERO.BLT_WIDTH	= $B14B
BLT_ZERO.BLT_HEIGHT	= $B14D
BLT_ZERO.BLT_AND_MASK	= $B14E
BLT_ZERO.BLT_XOR_MASK	= $B14F
BLT_ZERO.BLT_COLLISION_MASK	= $B150
BLT_ZERO.BLT_ZOOM	= $B151
BLT_ZERO.PATTERN_FEATURE	= $B152
BLT_ZERO.BLT_CONTROL	= $B153
adr.VBXE_RAM	= DATAORIGIN+$00F7	; [8] OBJECT
.var VBXE_RAM	= adr.VBXE_RAM .word
VBXE_RAM.POSITION	= DATAORIGIN+$00F7
VBXE_RAM.SIZE	= DATAORIGIN+$00FB
adr.SFX	= DATAORIGIN+$00FF	; [0] OBJECT
.var SFX	= adr.SFX .word
adr.BALLDATA	= DATAORIGIN+$00FF	; [7] RECORD
.var BALLDATA	= adr.BALLDATA .word
BALLDATA.WIDTH	= DATAORIGIN+$00FF
BALLDATA.HEIGHT	= DATAORIGIN+$0101
BALLDATA.OFS	= DATAORIGIN+$0102
adr.PLAYSCREEN	= DATAORIGIN+$0106	; [7] RECORD
.var PLAYSCREEN	= adr.PLAYSCREEN .word
PLAYSCREEN.WIDTH	= DATAORIGIN+$0106
PLAYSCREEN.HEIGHT	= DATAORIGIN+$0108
PLAYSCREEN.OFS	= DATAORIGIN+$0109
adr.PLAYVAUS	= DATAORIGIN+$010D	; [7] RECORD
.var PLAYVAUS	= adr.PLAYVAUS .word
PLAYVAUS.WIDTH	= DATAORIGIN+$010D
PLAYVAUS.HEIGHT	= DATAORIGIN+$010F
PLAYVAUS.OFS	= DATAORIGIN+$0110
adr.NORMAL	= DATAORIGIN+$0114	; [7] RECORD
.var NORMAL	= adr.NORMAL .word
NORMAL.WIDTH	= DATAORIGIN+$0114
NORMAL.HEIGHT	= DATAORIGIN+$0116
NORMAL.OFS	= DATAORIGIN+$0117
adr.ENLARGED	= DATAORIGIN+$011B	; [7] RECORD
.var ENLARGED	= adr.ENLARGED .word
ENLARGED.WIDTH	= DATAORIGIN+$011B
ENLARGED.HEIGHT	= DATAORIGIN+$011D
ENLARGED.OFS	= DATAORIGIN+$011E
adr.LASERS	= DATAORIGIN+$0122	; [7] RECORD
.var LASERS	= adr.LASERS .word
LASERS.WIDTH	= DATAORIGIN+$0122
LASERS.HEIGHT	= DATAORIGIN+$0124
LASERS.OFS	= DATAORIGIN+$0125
adr.EXPLOSION	= DATAORIGIN+$0129	; [7] RECORD
.var EXPLOSION	= adr.EXPLOSION .word
EXPLOSION.WIDTH	= DATAORIGIN+$0129
EXPLOSION.HEIGHT	= DATAORIGIN+$012B
EXPLOSION.OFS	= DATAORIGIN+$012C
adr.NEWVAUS	= DATAORIGIN+$0130	; [7] RECORD
.var NEWVAUS	= adr.NEWVAUS .word
NEWVAUS.WIDTH	= DATAORIGIN+$0130
NEWVAUS.HEIGHT	= DATAORIGIN+$0132
NEWVAUS.OFS	= DATAORIGIN+$0133
adr.PRESENTS	= DATAORIGIN+$0137	; [7] RECORD
.var PRESENTS	= adr.PRESENTS .word
PRESENTS.WIDTH	= DATAORIGIN+$0137
PRESENTS.HEIGHT	= DATAORIGIN+$0139
PRESENTS.OFS	= DATAORIGIN+$013A
adr.SHINEWALL	= DATAORIGIN+$013E	; [7] RECORD
.var SHINEWALL	= adr.SHINEWALL .word
SHINEWALL.WIDTH	= DATAORIGIN+$013E
SHINEWALL.HEIGHT	= DATAORIGIN+$0140
SHINEWALL.OFS	= DATAORIGIN+$0141
adr.MINIVAUS	= DATAORIGIN+$0145	; [7] RECORD
.var MINIVAUS	= adr.MINIVAUS .word
MINIVAUS.WIDTH	= DATAORIGIN+$0145
MINIVAUS.HEIGHT	= DATAORIGIN+$0147
MINIVAUS.OFS	= DATAORIGIN+$0148
adr.LEVELSEL	= DATAORIGIN+$014C	; [7] RECORD
.var LEVELSEL	= adr.LEVELSEL .word
LEVELSEL.WIDTH	= DATAORIGIN+$014C
LEVELSEL.HEIGHT	= DATAORIGIN+$014E
LEVELSEL.OFS	= DATAORIGIN+$014F
adr.LETTERS	= DATAORIGIN+$0153	; [7] RECORD
.var LETTERS	= adr.LETTERS .word
LETTERS.WIDTH	= DATAORIGIN+$0153
LETTERS.HEIGHT	= DATAORIGIN+$0155
LETTERS.OFS	= DATAORIGIN+$0156
adr.SHOOTS	= DATAORIGIN+$015A	; [7] RECORD
.var SHOOTS	= adr.SHOOTS .word
SHOOTS.WIDTH	= DATAORIGIN+$015A
SHOOTS.HEIGHT	= DATAORIGIN+$015C
SHOOTS.OFS	= DATAORIGIN+$015D
adr.VAUS	= DATAORIGIN+$0161	; [10] RECORD
.var VAUS	= adr.VAUS .word
VAUS.X	= DATAORIGIN+$0161
VAUS.Y	= DATAORIGIN+$0162
VAUS.OLDX	= DATAORIGIN+$0163
VAUS.OLDY	= DATAORIGIN+$0164
VAUS.OLDLEN	= DATAORIGIN+$0165
VAUS.WIDTH	= DATAORIGIN+$0166
VAUS.HEIGHT	= DATAORIGIN+$0167
VAUS.FLASH	= DATAORIGIN+$0168
VAUS.IFLASH	= DATAORIGIN+$0169
VAUS.LETTER	= DATAORIGIN+$016A
adr.PATTERN	= DATAORIGIN+$016B	; [7] RECORD
.var PATTERN	= adr.PATTERN .word
PATTERN.WIDTH	= DATAORIGIN+$016B
PATTERN.HEIGHT	= DATAORIGIN+$016D
PATTERN.OFS	= DATAORIGIN+$016E
adr.PATTERN0	= DATAORIGIN+$0172	; [7] RECORD
.var PATTERN0	= adr.PATTERN0 .word
PATTERN0.WIDTH	= DATAORIGIN+$0172
PATTERN0.HEIGHT	= DATAORIGIN+$0174
PATTERN0.OFS	= DATAORIGIN+$0175
adr.PATTERN1	= DATAORIGIN+$0179	; [7] RECORD
.var PATTERN1	= adr.PATTERN1 .word
PATTERN1.WIDTH	= DATAORIGIN+$0179
PATTERN1.HEIGHT	= DATAORIGIN+$017B
PATTERN1.OFS	= DATAORIGIN+$017C
adr.PATTERN2	= DATAORIGIN+$0180	; [7] RECORD
.var PATTERN2	= adr.PATTERN2 .word
PATTERN2.WIDTH	= DATAORIGIN+$0180
PATTERN2.HEIGHT	= DATAORIGIN+$0182
PATTERN2.OFS	= DATAORIGIN+$0183
adr.PATTERN3	= DATAORIGIN+$0187	; [7] RECORD
.var PATTERN3	= adr.PATTERN3 .word
PATTERN3.WIDTH	= DATAORIGIN+$0187
PATTERN3.HEIGHT	= DATAORIGIN+$0189
PATTERN3.OFS	= DATAORIGIN+$018A
adr.PATTERN4	= DATAORIGIN+$018E	; [7] RECORD
.var PATTERN4	= adr.PATTERN4 .word
PATTERN4.WIDTH	= DATAORIGIN+$018E
PATTERN4.HEIGHT	= DATAORIGIN+$0190
PATTERN4.OFS	= DATAORIGIN+$0191
STATUS	= DATAORIGIN+$0195
REMAIN_BLK	= DATAORIGIN+$0196
TOTALWALL	= DATAORIGIN+$0197
adr.SCORE	= DATAORIGIN+$0198	; [27] RECORD
.var SCORE	= adr.SCORE .word
adr.SCORE.PLAYER	= [DATAORIGIN+$0198] .array [3] .dword
.var SCORE.PLAYER	= adr.SCORE.PLAYER .word
adr.SCORE.WALL_N	= [DATAORIGIN+$01A4] .array [3]
.var SCORE.WALL_N	= adr.SCORE.WALL_N .word
adr.SCORE.LIVES	= [DATAORIGIN+$01A7] .array [3]
.var SCORE.LIVES	= adr.SCORE.LIVES .word
SCORE.HISCORE	= DATAORIGIN+$01AA
SCORE.PL_NUMB	= DATAORIGIN+$01AE
adr.SCORE.ROUNDSEL	= [DATAORIGIN+$01AF] .array [3]
.var SCORE.ROUNDSEL	= adr.SCORE.ROUNDSEL .word
SCORE.ABORTPLAY	= DATAORIGIN+$01B2
CUR_PLAYER	= DATAORIGIN+$01B3
adr.SHINEREC	= DATAORIGIN+$01B4	; [5] RECORD
.var SHINEREC	= adr.SHINEREC .word
SHINEREC.XB	= DATAORIGIN+$01B4
SHINEREC.YB	= DATAORIGIN+$01B5
SHINEREC.FRAME	= DATAORIGIN+$01B6
SHINEREC.BLOCK	= DATAORIGIN+$01B7
SHINEREC.ACTIVE	= DATAORIGIN+$01B8
LV	= DATAORIGIN+$01B9
TRAINER	= DATAORIGIN+$01BB
adr.LETT	= DATAORIGIN+$01BC	; [15] RECORD
.var LETT	= adr.LETT .word
LETT.X	= DATAORIGIN+$01BC
LETT.Y	= DATAORIGIN+$01BD
LETT.TYP	= DATAORIGIN+$01BE
LETT.FRAME	= DATAORIGIN+$01C0
LETT.SUBFRAME	= DATAORIGIN+$01C1
LETT.ACTIVE	= DATAORIGIN+$01C2
LETT.INCOMING	= DATAORIGIN+$01C3
LETT.NEXTX	= DATAORIGIN+$01C5
LETT.NEXTY	= DATAORIGIN+$01C6
LETT.NEXTTYPE	= DATAORIGIN+$01C7
LETT.LAST	= DATAORIGIN+$01C9
adr.FIRE	= DATAORIGIN+$01CB	; [5] RECORD
.var FIRE	= adr.FIRE .word
FIRE.X	= DATAORIGIN+$01CB
FIRE.Y	= DATAORIGIN+$01CC
FIRE.SHOT	= DATAORIGIN+$01CD
FIRE.AVL	= DATAORIGIN+$01CE
FIRE.NW	= DATAORIGIN+$01CF
BALLS_IN_PLAY	= DATAORIGIN+$01D0
SCRFLUX	= DATAORIGIN+$01D1
SCRFLUXCNT	= DATAORIGIN+$01D2
SOUND_ON	= DATAORIGIN+$01D3
OLD_SCORES	= DATAORIGIN+$01D4
HLP	= DATAORIGIN+$01D8
adr.SCR	= $B200
.var SCR	= adr.SCR .word
adr.POM	= $B280
.var POM	= adr.POM .word
adr.SQRTABLE	= $A000
.var SQRTABLE	= adr.SQRTABLE .word
adr.ROW	= $C000
.var ROW	= adr.ROW .word
adr.MOD10TABLE	= $C200
.var MOD10TABLE	= adr.MOD10TABLE .word
adr.MOD90TABLE	= $C300
.var MOD90TABLE	= adr.MOD90TABLE .word
adr.MOD360TABLE	= $C400
.var MOD360TABLE	= adr.MOD360TABLE .word
adr.ATAN_TAB	= $C600
.var ATAN_TAB	= adr.ATAN_TAB .word
adr.LOG2_TAB	= $C700
.var LOG2_TAB	= adr.LOG2_TAB .word
adr.SCALE360	= $C800
.var SCALE360	= adr.SCALE360 .word
adr.SINTABLE	= $CA00
.var SINTABLE	= adr.SINTABLE .word
adr.WALL_P	= $D800
.var WALL_P	= adr.WALL_P .word
adr.WALL	= $DB00
.var WALL	= adr.WALL .word
adr.MUL90_16	= $DC00
.var MUL90_16	= adr.MUL90_16 .word
adr.ALL_WALLS	= $DD00
.var ALL_WALLS	= adr.ALL_WALLS .word
@exit

@halt	ldx #$00
	txs

	.ifdef MAIN.@DEFINES.ROMOFF
	inc portb
	.fi

	ldy #$01

	rts

; ------------------------------------------------------------

.local	@DEFINES
ATARI
CPU_6502
.endl

.local	@RESOURCE
.endl

.endl							; MAIN

; ------------------------------------------------------------
; ------------------------------------------------------------

.macro	UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.ATARI.@UnitInit
	jsr MAIN.ATARI.@UnitInit
	.fi

	.ifdef MAIN.CRT.@UnitInit
	jsr MAIN.CRT.@UnitInit
	.fi

	.ifdef MAIN.TYPES.@UnitInit
	jsr MAIN.TYPES.@UnitInit
	.fi

	.ifdef MAIN.GRAPH.@UnitInit
	jsr MAIN.GRAPH.@UnitInit
	.fi

	.ifdef MAIN.VBXE.@UnitInit
	jsr MAIN.VBXE.@UnitInit
	.fi

	.ifdef MAIN.JOYSTICK.@UnitInit
	jsr MAIN.JOYSTICK.@UnitInit
	.fi

	.ifdef MAIN.MISC.@UnitInit
	jsr MAIN.MISC.@UnitInit
	.fi

	.ifdef MAIN.XSFX.@UnitInit
	jsr MAIN.XSFX.@UnitInit
	.fi
.endm

; ------------------------------------------------------------

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.ATARI) > 0
	.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
	eif

	ift .SIZEOF(MAIN.CRT) > 0
	.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
	eif

	ift .SIZEOF(MAIN.TYPES) > 0
	.print 'TYPES: ',MAIN.TYPES,'..',MAIN.TYPES+.SIZEOF(MAIN.TYPES)-1
	eif

	ift .SIZEOF(MAIN.GRAPH) > 0
	.print 'GRAPH: ',MAIN.GRAPH,'..',MAIN.GRAPH+.SIZEOF(MAIN.GRAPH)-1
	eif

	ift .SIZEOF(MAIN.VBXE) > 0
	.print 'VBXE: ',MAIN.VBXE,'..',MAIN.VBXE+.SIZEOF(MAIN.VBXE)-1
	eif

	ift .SIZEOF(MAIN.JOYSTICK) > 0
	.print 'JOYSTICK: ',MAIN.JOYSTICK,'..',MAIN.JOYSTICK+.SIZEOF(MAIN.JOYSTICK)-1
	eif

	ift .SIZEOF(MAIN.MISC) > 0
	.print 'MISC: ',MAIN.MISC,'..',MAIN.MISC+.SIZEOF(MAIN.MISC)-1
	eif

	ift .SIZEOF(MAIN.XSFX) > 0
	.print 'XSFX: ',MAIN.XSFX,'..',MAIN.XSFX+.SIZEOF(MAIN.XSFX)-1
	eif

.nowarn	.print 'CODE: ',CODEORIGIN,'..',MAIN.@RESOURCE-1

	ift .SIZEOF(MAIN.@RESOURCE)>0
.nowarn	.print 'RESOURCE: ',MAIN.@RESOURCE,'..',MAIN.@RESOURCE+.SIZEOF(MAIN.@RESOURCE)-1
	eif

@end

.nowarn	.print 'VARS: ',MAIN.@RESOURCE+.SIZEOF(MAIN.@RESOURCE),'..',@end-1

; ------------------------------------------------------------

	?adr = *
	ift (?adr < ?old_adr) && (?old_adr - ?adr < $120)
	?adr = ?old_adr
	eif

	org ?adr
	?old_adr = *

DATAORIGIN
.by  $2D $0C $00 $00 $00 $28 $00 $18  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $27 $00  $00 $00 $17 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $FF $FF $FF $FF

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 995

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

	ert DATAORIGIN<@end,'DATA memory overlap'

	run START

; ------------------------------------------------------------

.macro	STATICDATA
.by  $11 $56 $42 $58 $45 $20 $6E $6F  $74 $20 $64 $65 $74 $65 $63 $74  $65 $64 $0B $47 $61 $6D $65 $20
.by  $50 $61 $75 $73 $65 $64 $00 $00  $00 $00 $00 $00 $AA $00 $00 $AA  $00 $00 $00 $55 $AA $00 $AA $00
.by  $00 $00 $AA $00 $AA $00 $AA $AA  $00 $00 $AA $AA $AA $00 $55 $55  $55 $00 $55 $55 $FF $00 $55 $FF
.by  $55 $00 $55 $FF $FF $00 $FF $55  $55 $00 $FF $55 $FF $00 $FF $FF  $55 $00 $FF $FF $FF $00 $FF $D4
.by  $D3 $D2 $D1 $D0 $CF $CE $CD $CC  $CB $00 $00 $0A $00 $14 $00 $1E  $00 $28 $00 $32 $00 $64 $00 $C8
.by  $00 $FA $00 $F4 $01 $E8 $03 $00  $02 $13 $24 $35 $12 $23 $34 $45  $D4 $D3 $D2 $D1 $D0 $CF $CE $CD
.by  $CC $CB $00 $3C $5D $80 $00 $00  $E8 $03 $2C $01 $64 $00 $3C $00  $23 $00 $00 $10 $14 $03 $12 $14
.by  $14 $03 $01 $00 $00 $01 $13 $AF  $01 $12 $AD $01 $12 $A7 $01 $13  $A5 $01 $12 $A5 $01 $12 $A4 $01
.by  $12 $A3 $01 $12 $A1 $01 $12 $A0  $01 $12 $A1 $00 $FF $01 $00 $00  $02 $2F $AC $02 $33 $AC $03 $2F
.by  $AE $03 $33 $AE $00 $FF $01 $00  $00 $03 $FF $AC $03 $F5 $AD $02  $EB $AE $02 $E1 $AF $00 $FF $01
.by  $00 $00 $04 $1E $8A $01 $20 $88  $01 $24 $85 $01 $2C $84 $00 $FF  $01 $00 $00 $01 $01 $27 $01 $02
.by  $29 $01 $04 $2A $01 $05 $28 $01  $04 $25 $00 $FF $01 $00 $00 $01  $3C $AF $01 $3B $AD $01 $3B $A7
.by  $01 $3C $A5 $01 $3B $A5 $01 $3C  $A4 $01 $3C $A3 $01 $3C $A1 $01  $3C $A0 $01 $3C $A1 $00 $FF $01
.by  $00 $00 $01 $32 $AF $01 $31 $AD  $01 $31 $A7 $01 $32 $A5 $01 $31  $A5 $01 $32 $A4 $01 $32 $A3 $01
.by  $32 $A1 $01 $32 $A0 $01 $32 $A1  $00 $FF $01 $00 $00 $01 $19 $AF  $01 $18 $AD $01 $18 $A7 $01 $19
.by  $A5 $01 $18 $A5 $01 $19 $A4 $01  $19 $A3 $01 $19 $A1 $01 $19 $A0  $01 $19 $A1 $00 $FF $01 $00 $00
.by  $01 $13 $AF $01 $12 $AD $01 $12  $A7 $01 $13 $A5 $01 $12 $A5 $01  $12 $A4 $01 $12 $A3 $01 $12 $A1
.by  $01 $12 $A0 $01 $12 $A1 $00 $FF  $01 $00 $00 $03 $03 $22 $03 $05  $22 $03 $04 $22 $03 $03 $22 $03
.by  $03 $24 $03 $05 $24 $03 $04 $24  $03 $03 $24 $03 $03 $26 $03 $05  $26 $03 $04 $26 $03 $03 $26 $03
.by  $03 $28 $03 $05 $28 $03 $04 $28  $03 $03 $28 $03 $03 $2A $03 $05  $2A $03 $04 $2A $03 $03 $2A $03
.by  $03 $2C $03 $05 $2C $03 $04 $2C  $03 $03 $2C $03 $03 $2E $03 $05  $2E $03 $04 $2E $03 $03 $2E $03
.by  $03 $2C $03 $05 $2C $03 $04 $2C  $03 $03 $2C $03 $03 $2A $03 $05  $2A $03 $04 $2A $03 $03 $2A $03
.by  $03 $28 $03 $05 $28 $03 $04 $28  $03 $03 $28 $03 $03 $26 $03 $05  $26 $03 $04 $26 $03 $03 $26 $03
.by  $03 $24 $03 $05 $24 $03 $04 $24  $03 $03 $24 $03 $03 $22 $03 $05  $22 $03 $04 $22 $03 $03 $22 $00
.by  $FF $03 $14 $29 $04 $10 $2C $02  $12 $2B $03 $14 $27 $04 $10 $2A  $02 $12 $29 $03 $14 $25 $04 $10
.by  $28 $02 $12 $27 $03 $14 $23 $04  $10 $26 $02 $12 $25 $03 $14 $22  $04 $10 $25 $02 $12 $24 $00 $FF
.by  $01 $00 $00 $07 $1F $2F $07 $21  $2D $07 $23 $2B $07 $25 $29 $06  $27 $27 $06 $29 $25 $06 $2B $23
.by  $00 $FF $3F $00 $C0 $FF $40 $7F  $BF $80 $00 $06 $0C $12 $18 $1E  $24 $2A $30 $36 $3C
.endm

	end
