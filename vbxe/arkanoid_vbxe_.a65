; ------------------------------------------------------------
; Mad Pascal Compiler version 1.7.5 [2025/08/28] for MOS 6502 CPU
; ------------------------------------------------------------

STACKWIDTH	= 16
CODEORIGIN	= $2000

TRUE		= 1
FALSE		= 0
EOL		= $9B
__BUFFER	= $0400
@BUF		= __BUFFER

; ------------------------------------------------------------

	org $80

zpage

.if .def(@vbxe_detect)
fxptr	.ds 2						; VBXE pointer
.fi

.if .def(@AllocMem)||.def(MAIN.SYSTEM.GETMEM)||.def(MAIN.SYSTEM.FREEMEM)
psptr	.ds 2						; PROGRAMSTACK Pointer
.fi

bp	.ds 2
bp2	.ds 2
bp3	= bp+1

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4

TMP
ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

STACKORIGIN	.ds STACKWIDTH*4
zpend

; ------------------------------------------------------------

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

	.ifdef MAIN.@DEFINES.BASICOFF
	org CODEORIGIN
	icl 'atari\basicoff.asm'
	ini CODEORIGIN
	.fi

	.ifdef MAIN.@DEFINES.S_VBXE
	opt h-
	ins 'atari\s_vbxe\sdxld2.obx'
	opt h+
	.fi

	org CODEORIGIN

.local	MAIN.@RESOURCE
.endl

.local	RESOURCE
	icl 'atari\resource.asm'
	?EXTDETECT = 0
	?VBXDETECT = 0

	RCDATA 'walls.dat' adr.ALL_WALLS 0 0 0 0 0 0 0 0
	XBMP 'btm.bmp' VBXE_DATA 0 1 0 0 0 0 0 0
.endl

; ------------------------------------------------------------

	org CODEORIGIN

	STATICDATA

; ------------------------------------------------------------

RTLIB
	icl 'rtl6502_a8.asm'

.print 'ZPAGE: ',zpage,'..',zpend-1

.print 'RTBUF: ',@buf,'..',@buf+255

.print 'RTLIB: ',RTLIB,'..',*-1

; ------------------------------------------------------------

START
	tsx
	stx MAIN.@halt+1

	.ifdef MAIN.@DEFINES.ROMOFF
	icl 'atari\romoff.asm'
	.fi

VLEN	= VARDATASIZE-VARINITSIZE
VADR	= DATAORIGIN+VARINITSIZE

	ift (VADR > $BFFF) && .not(.def MAIN.@DEFINES.ROMOFF)
	ert 'Invalid memory address range ',VADR
	eif

	ift (VLEN > 0) && (VLEN <= 256)
	ldx #256-VLEN
	lda #$00
	sta:rne VADR+VLEN-256,x+
	eli VLEN>256
	m@init
	eif

.ifdef psptr
	mwa #PROGRAMSTACK psptr
.fi

	ldx #$00					; X = 0
	stx bp						; BP = 0

	stx audctl					; reset POKEY
	stx audctl+$10
	lda #3
	sta skctl
	sta skctl+$10

	dex						; X = 255

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	jmp l_0022

; ------------------------------------------------------------

.local	SYSTEM						; UNIT

.local	PEEK						; FUNCTION | ASSEMBLER | REGISTER

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta A
	lda :STACKORIGIN+STACKWIDTH,x
	sta A+1
	dex
@main

; -------------------  ASM Block 00000002  -------------------

	ldy #0
	mva (:edx),y Result

@exit

; ------------------------------------------------------------

; Push BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

A	= :EDX
RESULT	= :STACKORIGIN-4

	rts						; ret
.endl

.local	ABS						; FUNCTION | ASSEMBLER | OVERLOAD | REGISTER
.local	@010183000
	sta X

; -------------------  ASM Block 00000007  -------------------

	lda :edx
	bpl @+

	eor #$ff
	add #1
@
	sta Result

@exit

; ------------------------------------------------------------

X	= :EDX
RESULT	= :STACKORIGIN-4

	rts						; ret
.endl
.endl							; overload

.local	ABS						; FUNCTION | ASSEMBLER | OVERLOAD | REGISTER
.local	@010184000

; -------------------  ASM Block 00000008  -------------------

	lda :edx+1
	bpl @+

	lda #$00
	sub :edx
	sta :edx
	lda #$00
	sbc :edx+1
	sta :edx+1
@
	sta Result+1

	mva :edx Result

@exit

; ------------------------------------------------------------

X	= :EDX
RESULT	= :STACKORIGIN-4

	rts						; ret
.endl
.endl							; overload

.local	ABS						; FUNCTION | ASSEMBLER | OVERLOAD | REGISTER
.local	@010185000

; -------------------  ASM Block 00000009  -------------------

	lda :edx+3
	spl
	jsr @negEDX

	sta Result+3

	mva :edx Result
	mva :edx+1 Result+1
	mva :edx+2 Result+2

@exit

; ------------------------------------------------------------

X	= :EDX
RESULT	= :STACKORIGIN-4

	rts						; ret
.endl
.endl							; overload

.local	ARCTAN						; FUNCTION | OVERLOAD
.local	@01018F000

; optimize OK (SYSTEM), line = 904

	lda #$00
	sta SIGN

; optimize OK (SYSTEM), line = 905

	lda VALUE
	sta X
	lda VALUE+1
	sta X+1
	lda VALUE+2
	sta X+2
	lda VALUE+3
	sta X+3

; optimize OK (SYSTEM), line = 906

	lda #$00
	sta Y
	sta Y+1
	sta Y+2
	sta Y+3

; optimize OK (SYSTEM), line = 908

	lda VALUE+3
	bne @+
	lda VALUE+2
	bne @+
	lda VALUE+1
	bne @+
	lda VALUE
@
	jne l_0054

; optimize OK (SYSTEM), line = 909

	lda #$00
	sta RESULT
	sta RESULT+1
	sta RESULT+2
	sta RESULT+3
	jmp @exit
l_0054

; optimize OK (SYSTEM), line = 912

	lda X+3
	jpl l_0072

; optimize OK (SYSTEM), line = 913

	lda #$01
	sta SIGN

; optimize OK (SYSTEM), line = 914

	lda X+3
	eor #$80
	sta X+3
l_0072
l_0062

; optimize OK (SYSTEM), line = 917

	lda #$00
	sta :FP2MAN0
	sta :FP2MAN1
	lda #$80
	sta :FP2MAN2
	lda #$3F
	sta :FP2MAN3
	lda X
	sta :FP1MAN0
	lda X+1
	sta :FP1MAN1
	lda X+2
	sta :FP1MAN2
	lda X+3
	sta :FP1MAN3
	jsr @FSUB
	lda :FPMAN0
	sta :STACKORIGIN+9
	lda :FPMAN1
	sta :STACKORIGIN+STACKWIDTH+9
	lda :FPMAN2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :FPMAN3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda #$00
	sta :FP2MAN0
	sta :FP2MAN1
	lda #$80
	sta :FP2MAN2
	lda #$3F
	sta :FP2MAN3
	lda X
	sta :FP1MAN0
	lda X+1
	sta :FP1MAN1
	lda X+2
	sta :FP1MAN2
	lda X+3
	sta :FP1MAN3
	jsr @FADD
	lda :FPMAN0
	sta :FP2MAN0
	lda :FPMAN1
	sta :FP2MAN1
	lda :FPMAN2
	sta :FP2MAN2
	lda :FPMAN3
	sta :FP2MAN3
	lda :STACKORIGIN+9
	sta :FP1MAN0
	lda :STACKORIGIN+STACKWIDTH+9
	sta :FP1MAN1
	lda :STACKORIGIN+STACKWIDTH*2+9
	sta :FP1MAN2
	lda :STACKORIGIN+STACKWIDTH*3+9
	sta :FP1MAN3
	jsr @FDIV
	lda :FPMAN0
	sta X
	lda :FPMAN1
	sta X+1
	lda :FPMAN2
	sta X+2
	lda :FPMAN3
	sta X+3

; optimize OK (SYSTEM), line = 918

	lda X
	sta :FP2MAN0
	lda X+1
	sta :FP2MAN1
	lda X+2
	sta :FP2MAN2
	lda X+3
	sta :FP2MAN3
	lda X
	sta :FP1MAN0
	lda X+1
	sta :FP1MAN1
	lda X+2
	sta :FP1MAN2
	lda X+3
	sta :FP1MAN3
	jsr @FMUL
	lda :FPMAN0
	sta Y
	lda :FPMAN1
	sta Y+1
	lda :FPMAN2
	sta Y+2
	lda :FPMAN3
	sta Y+3

; optimize OK (SYSTEM), line = 919

	lda Y
	sta :FP2MAN0
	lda Y+1
	sta :FP2MAN1
	lda Y+2
	sta :FP2MAN2
	lda Y+3
	sta :FP2MAN3
	lda #$4A
	sta :FP1MAN0
	lda #$D7
	sta :FP1MAN1
	lda #$3B
	sta :FP1MAN2
	sta :FP1MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$02
	sta :FP2MAN0
	lda #$6E
	sta :FP2MAN1
	lda #$84
	sta :FP2MAN2
	lda #$3C
	sta :FP2MAN3
	jsr @FSUB
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda Y
	sta :FP2MAN0
	lda Y+1
	sta :FP2MAN1
	lda Y+2
	sta :FP2MAN2
	lda Y+3
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$FE
	sta :FP2MAN0
	lda #$C1
	sta :FP2MAN1
	lda #$2F
	sta :FP2MAN2
	lda #$3D
	sta :FP2MAN3
	jsr @FADD
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda Y
	sta :FP2MAN0
	lda Y+1
	sta :FP2MAN1
	lda Y+2
	sta :FP2MAN2
	lda Y+3
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$74
	sta :FP2MAN0
	lda #$31
	sta :FP2MAN1
	lda #$9A
	sta :FP2MAN2
	lda #$3D
	sta :FP2MAN3
	jsr @FSUB
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda Y
	sta :FP2MAN0
	lda Y+1
	sta :FP2MAN1
	lda Y+2
	sta :FP2MAN2
	lda Y+3
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$83
	sta :FP2MAN0
	lda #$3D
	sta :FP2MAN1
	lda #$DA
	sta :FP2MAN2
	lda #$3D
	sta :FP2MAN3
	jsr @FADD
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda Y
	sta :FP2MAN0
	lda Y+1
	sta :FP2MAN1
	lda Y+2
	sta :FP2MAN2
	lda Y+3
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$C7
	sta :FP2MAN0
	lda #$7F
	sta :FP2MAN1
	lda #$11
	sta :FP2MAN2
	lda #$3E
	sta :FP2MAN3
	jsr @FSUB
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda Y
	sta :FP2MAN0
	lda Y+1
	sta :FP2MAN1
	lda Y+2
	sta :FP2MAN2
	lda Y+3
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$E5
	sta :FP2MAN0
	lda #$BB
	sta :FP2MAN1
	lda #$4C
	sta :FP2MAN2
	lda #$3E
	sta :FP2MAN3
	jsr @FADD
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda Y
	sta :FP2MAN0
	lda Y+1
	sta :FP2MAN1
	lda Y+2
	sta :FP2MAN2
	lda Y+3
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$6C
	sta :FP2MAN0
	lda #$AA
	sta :FP2MAN1
	sta :FP2MAN2
	lda #$3E
	sta :FP2MAN3
	jsr @FSUB
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda Y
	sta :FP2MAN0
	lda Y+1
	sta :FP2MAN1
	lda Y+2
	sta :FP2MAN2
	lda Y+3
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$00
	sta :FP2MAN0
	sta :FP2MAN1
	lda #$80
	sta :FP2MAN2
	lda #$3F
	sta :FP2MAN3
	jsr @FADD
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda X
	sta :FP2MAN0
	lda X+1
	sta :FP2MAN1
	lda X+2
	sta :FP2MAN2
	lda X+3
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta X
	lda :FPMAN1
	sta X+1
	lda :FPMAN2
	sta X+2
	lda :FPMAN3
	sta X+3

; optimize OK (SYSTEM), line = 922

	lda X
	sta :FP2MAN0
	lda X+1
	sta :FP2MAN1
	lda X+2
	sta :FP2MAN2
	lda X+3
	sta :FP2MAN3
	lda #$DB
	sta :FP1MAN0
	lda #$0F
	sta :FP1MAN1
	lda #$49
	sta :FP1MAN2
	lda #$3F
	sta :FP1MAN3
	jsr @FADD
	lda :FPMAN0
	sta X
	lda :FPMAN1
	sta X+1
	lda :FPMAN2
	sta X+2
	lda :FPMAN3
	sta X+3

; optimize OK (SYSTEM), line = 924

	lda SIGN
	jeq l_00F4

; optimize OK (SYSTEM), line = 925

	lda X
	sta RESULT
	lda X+1
	sta RESULT+1
	lda X+2
	sta RESULT+2
	lda X+3
	eor #$80
	jmp l_0105
l_00F4

; optimize OK (SYSTEM), line = 927

	lda X
	sta RESULT
	lda X+1
	sta RESULT+1
	lda X+2
	sta RESULT+2
	lda X+3
l_0105
	sta RESULT+3
@exit

; ------------------------------------------------------------

VALUE	= DATAORIGIN+$000B
RESULT	= DATAORIGIN+$000F
X	= DATAORIGIN+$0013
Y	= DATAORIGIN+$0017
SIGN	= DATAORIGIN+$001B

@VarData	= VALUE
@VarDataSize	= 13

	rts						; ret
.endl
.endl							; overload

.local	POKE						; PROCEDURE | ASSEMBLER | REGISTER

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta A
	lda :STACKORIGIN+STACKWIDTH,x
	sta A+1
	dex
	jmi @main

; ------------------------------------------------------------

; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
; as Pointer
	lda :STACKORIGIN,x
	sta VALUE
	dex
@main

; -------------------  ASM Block 00000025  -------------------

	ldy #0
	mva value (:edx),y

; ------------------------------------------------------------

A	= :EDX
VALUE	= :ECX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	FILLBYTE					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER | INLINE
.local	@03018000001810000300000

	.MACRO m@INLINE

; -------------------  ASM Block 00000033  -------------------

	jsr @fill

	.ENDM

; ------------------------------------------------------------

A	= :EDX
COUNT	= :ECX
VALUE	= :EAX

@exit
.endl
.endl							; overload

.local	FSINCOS						; FUNCTION

; --- WhileProlog
	jmp l_015B
l_015C

; optimize OK (SYSTEM), line = 1909

	lda #$DB
	sta :FP2MAN0
	lda #$0F
	sta :FP2MAN1
	lda #$C9
	sta :FP2MAN2
	lda #$40
	sta :FP2MAN3
	lda X
	sta :FP1MAN0
	lda X+1
	sta :FP1MAN1
	lda X+2
	sta :FP1MAN2
	lda X+3
	sta :FP1MAN3
	jsr @FSUB
	lda :FPMAN0
	sta X
	lda :FPMAN1
	sta X+1
	lda :FPMAN2
	sta X+2
	lda :FPMAN3
	sta X+3
l_015B
	lda #$DB
	sta @FCMPL.A
	lda #$0F
	sta @FCMPL.A+1
	lda #$C9
	sta @FCMPL.A+2
	lda #$40
	sta @FCMPL.A+3
	lda X
	sta @FCMPL.B
	lda X+1
	sta @FCMPL.B+1
	lda X+2
	sta @FCMPL.B+2
	lda X+3
	sta @FCMPL.B+3
	jsr @FCMPL
	smi
	jne l_015C

; --- WhileProlog
	jmp l_0170
l_0171

; optimize OK (SYSTEM), line = 1910

	lda #$DB
	sta :FP2MAN0
	lda #$0F
	sta :FP2MAN1
	lda #$C9
	sta :FP2MAN2
	lda #$40
	sta :FP2MAN3
	lda X
	sta :FP1MAN0
	lda X+1
	sta :FP1MAN1
	lda X+2
	sta :FP1MAN2
	lda X+3
	sta :FP1MAN3
	jsr @FADD
	lda :FPMAN0
	sta X
	lda :FPMAN1
	sta X+1
	lda :FPMAN2
	sta X+2
	lda :FPMAN3
	sta X+3
l_0170
	lda X+3
	jmi l_0171

; optimize OK (SYSTEM), line = 1913

	lda #$83
	sta :FP2MAN0
	lda #$F9
	sta :FP2MAN1
	lda #$22
	sta :FP2MAN2
	lda #$3F
	sta :FP2MAN3
	lda X
	sta :FP1MAN0
	lda X+1
	sta :FP1MAN1
	lda X+2
	sta :FP1MAN2
	lda X+3
	sta :FP1MAN3
	jsr @FMUL
	lda :FPMAN0
	sta X
	lda :FPMAN1
	sta X+1
	lda :FPMAN2
	sta X+2
	lda :FPMAN3
	sta X+3

; optimize OK (SYSTEM), line = 1916

	lda X
	sta :FPMAN0
	lda X+1
	sta :FPMAN1
	lda X+2
	sta :FPMAN2
	lda X+3
	sta :FPMAN3
	jsr @F2I
	lda :FPMAN0
	sta I

; optimize OK (SYSTEM), line = 1919

	lda X+3
	jpl l_019F
	dec I
l_019F

; optimize OK (SYSTEM), line = 1922

	ldy #$00
	lda I
	spl
	dey
	sta :FPMAN0
	sty :FPMAN1
	sty :FPMAN2
	sty :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta :FP2MAN0
	lda :FPMAN1
	sta :FP2MAN1
	lda :FPMAN2
	sta :FP2MAN2
	lda :FPMAN3
	sta :FP2MAN3
	lda X
	sta :FP1MAN0
	lda X+1
	sta :FP1MAN1
	lda X+2
	sta :FP1MAN2
	lda X+3
	sta :FP1MAN3
	jsr @FSUB
	lda :FPMAN0
	sta X
	lda :FPMAN1
	sta X+1
	lda :FPMAN2
	sta X+2
	lda :FPMAN3
	sta X+3

; optimize OK (SYSTEM), line = 1925

	lda SC
	jeq l_01BC
	inc I
l_01BC

; optimize OK (SYSTEM), line = 1928

	lda I
	and #$01
	jne l_01D9
	lda X
	sta :FP2MAN0
	lda X+1
	sta :FP2MAN1
	lda X+2
	sta :FP2MAN2
	lda X+3
	sta :FP2MAN3
	lda #$00
	sta :FP1MAN0
	sta :FP1MAN1
	lda #$80
	sta :FP1MAN2
	lda #$3F
	sta :FP1MAN3
	jsr @FSUB
	lda :FPMAN0
	sta X
	lda :FPMAN1
	sta X+1
	lda :FPMAN2
	sta X+2
	lda :FPMAN3
	sta X+3
l_01D9

; optimize OK (SYSTEM), line = 1931

	lda X
	sta :FP2MAN0
	lda X+1
	sta :FP2MAN1
	lda X+2
	sta :FP2MAN2
	lda X+3
	sta :FP2MAN3
	lda X
	sta :FP1MAN0
	lda X+1
	sta :FP1MAN1
	lda X+2
	sta :FP1MAN2
	lda X+3
	sta :FP1MAN3
	jsr @FMUL
	lda :FPMAN0
	sta X
	lda :FPMAN1
	sta X+1
	lda :FPMAN2
	sta X+2
	lda :FPMAN3
	sta X+3

; optimize OK (SYSTEM), line = 1932

	lda #$42
	sta :FP2MAN0
	lda #$01
	sta :FP2MAN1
	lda #$5E
	sta :FP2MAN2
	lda #$3A
	sta :FP2MAN3
	lda X
	sta :FP1MAN0
	lda X+1
	sta :FP1MAN1
	lda X+2
	sta :FP1MAN2
	lda X+3
	sta :FP1MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP2MAN0
	lda :FPMAN1
	sta :FP2MAN1
	lda :FPMAN2
	sta :FP2MAN2
	lda :FPMAN3
	sta :FP2MAN3
	lda #$D3
	sta :FP1MAN0
	lda #$59
	sta :FP1MAN1
	lda #$A3
	sta :FP1MAN2
	lda #$3C
	sta :FP1MAN3
	jsr @FSUB
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda X
	sta :FP2MAN0
	lda X+1
	sta :FP2MAN1
	lda X+2
	sta :FP2MAN2
	lda X+3
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$DE
	sta :FP2MAN0
	lda #$4D
	sta :FP2MAN1
	lda #$6F
	sta :FP2MAN2
	lda #$3E
	sta :FP2MAN3
	jsr @FSUB
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda X
	sta :FP2MAN0
	lda X+1
	sta :FP2MAN1
	lda X+2
	sta :FP2MAN2
	lda X+3
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$00
	sta :FP2MAN0
	sta :FP2MAN1
	lda #$80
	sta :FP2MAN2
	lda #$3F
	sta :FP2MAN3
	jsr @FADD
	lda :FPMAN0
	sta :STACKORIGIN+9
	lda :FPMAN1
	sta :STACKORIGIN+STACKWIDTH+9
	lda :FPMAN2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :FPMAN3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda X
	sta :FP2MAN0
	lda X+1
	sta :FP2MAN1
	lda X+2
	sta :FP2MAN2
	lda X+3
	sta :FP2MAN3
	lda #$00
	sta :FP1MAN0
	sta :FP1MAN1
	lda #$80
	sta :FP1MAN2
	lda #$3F
	sta :FP1MAN3
	jsr @FSUB
	lda :FPMAN0
	sta :FP2MAN0
	lda :FPMAN1
	sta :FP2MAN1
	lda :FPMAN2
	sta :FP2MAN2
	lda :FPMAN3
	sta :FP2MAN3
	lda :STACKORIGIN+9
	sta :FP1MAN0
	lda :STACKORIGIN+STACKWIDTH+9
	sta :FP1MAN1
	lda :STACKORIGIN+STACKWIDTH*2+9
	sta :FP1MAN2
	lda :STACKORIGIN+STACKWIDTH*3+9
	sta :FP1MAN3
	jsr @FMUL
	lda :FPMAN0
	sta RESULT
	lda :FPMAN1
	sta RESULT+1
	lda :FPMAN2
	sta RESULT+2
	lda :FPMAN3
	sta RESULT+3

; optimize OK (SYSTEM), line = 1935

	lda I
	and #$02
	cmp #$02
	jne l_0226
	lda RESULT+3
	eor #$80
	sta RESULT+3
l_0226
@exit

; ------------------------------------------------------------

X	= DATAORIGIN+$001C
SC	= DATAORIGIN+$0020
RESULT	= DATAORIGIN+$0021
I	= DATAORIGIN+$0025

@VarData	= X
@VarDataSize	= 6

	rts						; ret
.endl

.local	SIN						; FUNCTION | OVERLOAD
.local	@01018F000

; optimize OK (SYSTEM), line = 1949

	lda X
	sta FSINCOS.X
	lda X+1
	sta FSINCOS.X+1
	lda X+2
	sta FSINCOS.X+2
	lda X+3
	sta FSINCOS.X+3
	lda #$00
	sta FSINCOS.SC
	jsr FSINCOS
	lda FSINCOS.RESULT
	sta RESULT
	lda FSINCOS.RESULT+1
	sta RESULT+1
	lda FSINCOS.RESULT+2
	sta RESULT+2
	lda FSINCOS.RESULT+3
	sta RESULT+3
@exit

; ------------------------------------------------------------

X	= DATAORIGIN+$0026
RESULT	= DATAORIGIN+$002A

@VarData	= X
@VarDataSize	= 4

	rts						; ret
.endl
.endl							; overload

.local	COS						; FUNCTION | OVERLOAD
.local	@01018F000

; optimize OK (SYSTEM), line = 1963

	lda X
	sta FSINCOS.X
	lda X+1
	sta FSINCOS.X+1
	lda X+2
	sta FSINCOS.X+2
	lda X+3
	sta FSINCOS.X+3
	lda #$01
	sta FSINCOS.SC
	jsr FSINCOS
	lda FSINCOS.RESULT
	sta RESULT
	lda FSINCOS.RESULT+1
	sta RESULT+1
	lda FSINCOS.RESULT+2
	sta RESULT+2
	lda FSINCOS.RESULT+3
	sta RESULT+3
@exit

; ------------------------------------------------------------

X	= DATAORIGIN+$002E
RESULT	= DATAORIGIN+$0032

@VarData	= X
@VarDataSize	= 4

	rts						; ret
.endl
.endl							; overload

.local	PAUSE						; PROCEDURE | ASSEMBLER | OVERLOAD
.local	@00

; -------------------  ASM Block 00000043  -------------------

	bit VCOUNT
	bmi *-3
	bit VCOUNT
	bpl *-3

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	RANDOMIZE					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000045  -------------------


  mva $d20a RndSeed
  mva #$00  RndSeed+1


@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	RANDOM						; FUNCTION | ASSEMBLER | OVERLOAD
.local	@010180000
	sta RANGE

; -------------------  ASM Block 00000049  -------------------


;BYTE FUNC Rand(BYTE range)
; returns random number between 0 and
; range-1.  If range=0, then a random
; number between 0 and 255 is returned

  ldy $d20a   ; RANDOM

  lda range
  beq stop

  sta :ecx
  sty :eax

  jsr imulCL
  tay

stop  sty Result


@exit

; ------------------------------------------------------------

RANGE	= DATAORIGIN+$0036
RESULT	= DATAORIGIN+$0037

@VarData	= RANGE
@VarDataSize	= 1

	rts						; ret
.endl
.endl							; overload

.local	RANDOM						; FUNCTION | OVERLOAD
.local	@010184000

; optimize OK (system_atari.inc), line = 179

	lda RANGE+1
	ora RANGE
	jne l_0266

; optimize OK (system_atari.inc), line = 180

	lda #$00
	sta RESULT
	sta RESULT+1
	jmp l_0274
l_0266

; optimize OK (system_atari.inc), line = 183

	lda RNDSEED
	sta :ecx
	lda RNDSEED+1
	sta :ecx+1
	lda #$95
	sta :eax
	lda #$45
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	sta RNDSEED
	lda :eax+1
	sta RNDSEED+1

; optimize OK (system_atari.inc), line = 184

	lda RANGE
	sta @SMALLINT.MOD.B
	lda RANGE+1
	sta @SMALLINT.MOD.B+1
	lda RNDSEED
	sta @SMALLINT.MOD.A
	lda RNDSEED+1
	sta @SMALLINT.MOD.A+1
	jsr @SMALLINT.MOD
	lda @SMALLINT.MOD.RESULT
	sta RESULT
	lda @SMALLINT.MOD.RESULT+1
	sta RESULT+1

; -------------------  ASM Block 00000050  -------------------

	lda range+1
	bpl plus

	lda Result+1
	bmi ok
	bpl sign

plus	lda Result+1
	bpl ok

sign 	lda #0
	sub Result
	sta Result

	lda #0
	sbc Result+1
	sta Result+1
ok

l_0274
@exit

; ------------------------------------------------------------

RANGE	= DATAORIGIN+$0038
RESULT	= DATAORIGIN+$003A

@VarData	= RANGE
@VarDataSize	= 2

	rts						; ret
.endl
.endl							; overload

; ------------------------------------------------------------
; ------------------------------------------------------------
@UnitInit

; -------------------  ASM Block 00000060  -------------------

	.ifdef @CmdLine

	ldx #$0F
	mva:rpl $340,x IOCB@COPY,x-
	rts

IOCB@COPY	:16 brk
	eif


	rts

; ------------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $04
__PORTB_BANKS	= $0101
MGTIA	= $00
MVBXE	= $80
VBXE_XDLADR	= $00
VBXE_BCBTMP	= $E0
VBXE_BCBADR	= $0100
VBXE_MAPADR	= $1000
VBXE_CHBASE	= $1000
VBXE_OVRADR	= $5000
VBXE_WINDOW	= $B000
IDLI	= $00
IVBL	= $01
IVBLD	= $01
IVBLI	= $02
ITIM1	= $03
ITIM2	= $04
ITIM4	= $05
CH_DELCHR	= $FE
CH_ENTER	= $9B
CH_ESC	= $1B
CH_CURS_UP	= $1C
CH_CURS_DOWN	= $1D
CH_CURS_LEFT	= $1E
CH_CURS_RIGHT	= $1F
CH_TAB	= $7F
CH_EOL	= $9B
CH_CLR	= $7D
CH_BELL	= $FD
CH_DEL	= $7E
CH_DELLINE	= $9C
CH_INSLINE	= $9D
PAL_PMCOLOR0	= $00
PAL_PMCOLOR1	= $01
PAL_PMCOLOR2	= $02
PAL_PMCOLOR3	= $03
PAL_COLOR0	= $04
PAL_COLOR1	= $05
PAL_COLOR2	= $06
PAL_COLOR3	= $07
PAL_COLBAK	= $08
COLOR_BLACK	= $00
COLOR_WHITE	= $0E
COLOR_RED	= $32
COLOR_CYAN	= $96
COLOR_VIOLET	= $68
COLOR_GREEN	= $C4
COLOR_BLUE	= $74
COLOR_YELLOW	= $EE
COLOR_ORANGE	= $28
COLOR_BROWN	= $E4
COLOR_LIGHTRED	= $3C
COLOR_GRAY1	= $04
COLOR_GRAY2	= $06
COLOR_GRAY3	= $0A
COLOR_LIGHTGREEN	= $CC
COLOR_LIGHTBLUE	= $7C
FMOPENREAD	= $04
FMOPENWRITE	= $08
FMOPENAPPEND	= $09
FMOPENREADWRITE	= $0C
DATESEPARATOR	= DATAORIGIN+$0000
RND	= $D20A
adr.PALETTE	= $02C0
.var PALETTE	= adr.PALETTE .word
adr.HPALETTE	= $D012
.var HPALETTE	= adr.HPALETTE .word
FILEMODE	= DATAORIGIN+$0001
GRAPHMODE	= DATAORIGIN+$0002
IORESULT	= DATAORIGIN+$0003
EOLN	= DATAORIGIN+$0004
SCREENWIDTH	= DATAORIGIN+$0005
SCREENHEIGHT	= DATAORIGIN+$0007
adr.MEM	= $00
.var MEM	= adr.MEM .word
RNDSEED	= DATAORIGIN+$0009

.endl							; UNIT SYSTEM

; ------------------------------------------------------------

.local	ATARI						; UNIT

; ------------------------------------------------------------

DL_BLANK1	= $00
DL_BLANK2	= $10
DL_BLANK3	= $20
DL_BLANK4	= $30
DL_BLANK5	= $40
DL_BLANK6	= $50
DL_BLANK7	= $60
DL_BLANK8	= $70
DL_DLI	= $80
DL_LMS	= $40
DL_VSCROLL	= $20
DL_HSCROLL	= $10
DL_JMP	= $01
DL_JVB	= $41
DL_MODE_2	= $02
DL_MODE_3	= $03
DL_MODE_4	= $04
DL_MODE_5	= $05
DL_MODE_E	= $0E
DL_MODE_F	= $0F
IRQENS	= $10
RTCLOK	= $12
RTCLOK1	= $12
RTCLOK2	= $13
RTCLOK3	= $14
ATRACT	= $4D
LMARGIN	= $52
RMARGIN	= $53
ROWCRS	= $54
COLCRS	= $55
DINDEX	= $57
SAVMSC	= $58
PALNTS	= $62
RAMTOP	= $6A
VDSLST	= $0200
SDLSTL	= $0230
TXTROW	= $0290
TXTCOL	= $0291
TINDEX	= $0293
TXTMSC	= $0294
SDMCTL	= $022F
GPRIOR	= $026F
CRSINH	= $02F0
CHACT	= $02F3
CHBAS	= $02F4
CH	= $02FC
FILDAT	= $02FD
PCOLR0	= $02C0
PCOLR1	= $02C1
PCOLR2	= $02C2
PCOLR3	= $02C3
COLOR0	= $02C4
COLOR1	= $02C5
COLOR2	= $02C6
COLOR3	= $02C7
COLOR4	= $02C8
COLBAKS	= $02C8
HPOSP0	= $D000
HPOSP1	= $D001
HPOSP2	= $D002
HPOSP3	= $D003
HPOSM0	= $D004
HPOSM1	= $D005
HPOSM2	= $D006
HPOSM3	= $D007
SIZEP0	= $D008
SIZEP1	= $D009
SIZEP2	= $D00A
SIZEP3	= $D00B
SIZEM	= $D00C
GRAFP0	= $D00D
GRAFP1	= $D00E
GRAFP2	= $D00F
GRAFP3	= $D010
GRAFM	= $D011
P0PF	= $D004
PAL	= $D014
TRIG3	= $D013
COLPM0	= $D012
COLPM1	= $D013
COLPM2	= $D014
COLPM3	= $D015
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBAK	= $D01A
COLBK	= $D01A
PRIOR	= $D01B
GRACTL	= $D01D
PMCNTL	= $D01D
HITCLR	= $D01E
CONSOL	= $D01F
AUDF1	= $D200
AUDC1	= $D201
AUDF2	= $D202
AUDC2	= $D203
AUDF3	= $D204
AUDC3	= $D205
AUDF4	= $D206
AUDC4	= $D207
AUDCTL	= $D208
KBCODE	= $D209
IRQEN	= $D20E
SKSTAT	= $D20F
PORTA	= $D300
PORTB	= $D301
PACTL	= $D302
DMACTL	= $D400
CHACTL	= $D401
DLISTL	= $D402
HSCROL	= $D404
VSCROL	= $D405
PMBASE	= $D407
CHBASE	= $D409
WSYNC	= $D40A
VCOUNT	= $D40B
PENH	= $D40C
PENV	= $D40D
NMIEN	= $D40E
NMIVEC	= $FFFA
RESETVEC	= $FFFC
IRQVEC	= $FFFE

.endl							; UNIT ATARI

; ------------------------------------------------------------

.local	CRT						; UNIT

; ------------------------------------------------------------

TEXTATTR	= DATAORIGIN+$003C
CONSOL	= $D01F
CN_START_SELECT_OPTION	= $00
CN_SELECT_OPTION	= $01
CN_START_OPTION	= $02
CN_OPTION	= $03
CN_START_SELECT	= $04
CN_SELECT	= $05
CN_START	= $06
CN_NONE	= $07
BLACK	= $00
WHITE	= $0F
RED	= $26
CYAN	= $AC
PURPLE	= $48
GREEN	= $B6
BLUE	= $86
YELLOW	= $DC
ORANGE	= $18
BROWN	= $F4
LIGHT_RED	= $2A
DARK_GREY	= $04
GREY	= $08
LIGHT_GREEN	= $BC
LIGHT_BLUE	= $9A
LIGHT_GREY	= $0C
BW40	= $00
CO40	= $01
BW80	= $02
CO80	= $03
MONO	= $07
C40	= $01
C80	= $03
BLINK	= $80

.endl							; UNIT CRT

; ------------------------------------------------------------

.local	TYPES						; UNIT

; ------------------------------------------------------------

.endl							; UNIT TYPES

; ------------------------------------------------------------

.local	GRAPH						; UNIT

; ------------------------------------------------------------

CURRENTDRIVER	= $80
DETECT	= $00
CGA	= $01
MCGA	= $02
EGA	= $03
EGA64	= $04
EGAMONO	= $05
LOWRES	= $06
HERCMONO	= $07
VGA	= $09
VESA	= $0A
D1BIT	= $0B
D2BIT	= $0C
D4BIT	= $0D
D6BIT	= $0E
D8BIT	= $0F
D12BIT	= $10
M640X400	= $18
M640X480	= $18
GROK	= $01
GRNOINITGRAPH	= $FF
GRNOTDETECTED	= $FE
GRFILENOTFOUND	= $FD
GRINVALIDDRIVER	= $FC
GRNOLOADMEM	= $FB
GRNOSCANMEM	= $FA
GRNOFLOODMEM	= $F9
GRFONTNOTFOUND	= $F8
GRNOFONTMEM	= $F7
GRINVALIDMODE	= $F6
GRERROR	= $F5
GRIOERROR	= $F4
GRINVALIDFONT	= $F3
GRINVALIDFONTNUM	= $F2
GRINVALIDVERSION	= $EE
CGAC0	= $00
CGAC1	= $01
CGAC2	= $02
CGAC3	= $03
CGAHI	= $04
MCGAC0	= $00
MCGAC1	= $01
MCGAC2	= $02
MCGAC3	= $03
MCGAMED	= $04
MCGAHI	= $05
EGALO	= $00
EGAHI	= $01
EGA64LO	= $00
EGA64HI	= $01
EGAMONOHI	= $03
VGALO	= $0A
VGAMED	= $1F
VGAHI	= $18
GRAPHRESULT	= DATAORIGIN+$003D
GETCOLOR	= DATAORIGIN+$003E
VIDEORAM	= DATAORIGIN+$003F
adr.LASTARCCOORDS	= DATAORIGIN+$0041	; [12] RECORD
.var LASTARCCOORDS	= adr.LASTARCCOORDS .word
LASTARCCOORDS.X	= DATAORIGIN+$0041
LASTARCCOORDS.Y	= DATAORIGIN+$0043
LASTARCCOORDS.XSTART	= DATAORIGIN+$0045
LASTARCCOORDS.YSTART	= DATAORIGIN+$0047
LASTARCCOORDS.XEND	= DATAORIGIN+$0049
LASTARCCOORDS.YEND	= DATAORIGIN+$004B
WIN_LEFT	= DATAORIGIN+$004D
WIN_RIGHT	= DATAORIGIN+$004F
WIN_TOP	= DATAORIGIN+$0051
WIN_BOTTOM	= DATAORIGIN+$0053
SCANLINE_WIDTH	= DATAORIGIN+$0055
CURRENTX	= DATAORIGIN+$0056
CURRENTY	= DATAORIGIN+$0058

.endl							; UNIT GRAPH

; ------------------------------------------------------------

.local	VBXE						; UNIT

.local	SETTOPBORDER					; PROCEDURE | ASSEMBLER | REGISTER
	sta A

; -------------------  ASM Block 00000100  -------------------

	fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000

	lda a
	sub #1

	ldy #s@xdl.RPTL_
	sta MAIN.SYSTEM.VBXE_WINDOW,y

	fxs FX_MEMS #$00

; ------------------------------------------------------------

A	= :EDX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SETXDLHEIGHT					; PROCEDURE | ASSEMBLER | REGISTER
	sta A

; -------------------  ASM Block 00000101  -------------------

	fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000

	lda a
	sub #1

	ldy #s@xdl.RPTL
	sta MAIN.SYSTEM.VBXE_WINDOW,y

	fxs FX_MEMS #$00

; ------------------------------------------------------------

A	= :EDX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	VBXEMEMORYBANK					; PROCEDURE | ASSEMBLER
	sta B

; -------------------  ASM Block 00000113  -------------------

	fxs FX_MEMS b

; ------------------------------------------------------------

B	= DATAORIGIN+$006E

@VarData	= B
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	READVBXEMEMORYBYTE				; FUNCTION

; optimize OK (vbxe_memorystream.inc), line = 20

	mwy POSITION :bp2
	ldy #$02
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	dey
	lda (:bp2),y
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	ora #$80
	sta BNK

; optimize OK (vbxe_memorystream.inc), line = 21

	dey
	lda (:bp2),y
	sta ADR
	iny
	lda (:bp2),y
	and #$0F
	ora #$B0
	sta ADR+1

; optimize OK (vbxe_memorystream.inc), line = 23

	lda BNK
	jsr VBXEMEMORYBANK

; optimize OK (vbxe_memorystream.inc), line = 25

	ldy ADR+1
	sty :bp+1
	ldy ADR
	lda (:bp),y
	sta RESULT

; optimize OK (vbxe_memorystream.inc), line = 27

	mwy POSITION :bp2
	ldy #$00
	lda (:bp2),y
	add #$01
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y
@exit

; ------------------------------------------------------------

POSITION	= DATAORIGIN+$006F
RESULT	= DATAORIGIN+$0071
BNK	= DATAORIGIN+$0072
ADR	= DATAORIGIN+$0073

@VarData	= POSITION
@VarDataSize	= 5

	rts						; ret
.endl

.local	WRITEVBXEMEMORYBYTE				; PROCEDURE

; optimize OK (vbxe_memorystream.inc), line = 39

	mwy POSITION :bp2
	ldy #$02
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	dey
	lda (:bp2),y
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	ora #$80
	sta BNK

; optimize OK (vbxe_memorystream.inc), line = 40

	dey
	lda (:bp2),y
	sta ADR
	iny
	lda (:bp2),y
	and #$0F
	ora #$B0
	sta ADR+1

; optimize OK (vbxe_memorystream.inc), line = 42

	lda BNK
	jsr VBXEMEMORYBANK

; optimize OK (vbxe_memorystream.inc), line = 44

	ldy ADR+1
	sty :bp+1
	ldy ADR
	lda A
	sta (:bp),y

; optimize OK (vbxe_memorystream.inc), line = 46

	mwy POSITION :bp2
	ldy #$00
	lda (:bp2),y
	add #$01
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; ------------------------------------------------------------

POSITION	= DATAORIGIN+$0075
A	= DATAORIGIN+$0077
BNK	= DATAORIGIN+$0078
ADR	= DATAORIGIN+$0079

@VarData	= POSITION
@VarDataSize	= 6

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TVBXEMEMORYSTREAM.READBUFFER			; PROCEDURE
	sta TVBXEMEMORYSTREAM
	sty TVBXEMEMORYSTREAM+1
	sta POSITION
	sty POSITION+1
	add #4
	scc
	iny
	sta SIZE
	sty SIZE+1

; optimize OK (vbxe_memorystream.inc), line = 87

	mwy POSITION :bp2
	ldy #$02
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	dey
	lda (:bp2),y
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	ora #$80
	sta BNK

; optimize OK (vbxe_memorystream.inc), line = 88

	dey
	lda (:bp2),y
	sta ADR
	iny
	lda (:bp2),y
	and #$0F
	ora #$B0
	sta ADR+1

; optimize OK (vbxe_memorystream.inc), line = 90

	lda BNK
	jsr VBXEMEMORYBANK

; optimize OK (vbxe_memorystream.inc), line = 92

	lda BUFFER
	sta DST
	lda BUFFER+1
	sta DST+1

; optimize OK (vbxe_memorystream.inc), line = 94

	lda #$00
	sta I
	sta I+1
	lda COUNT
	sub #$01
	sta @FORTMP_0393_0
	lda COUNT+1
	sbc #$00
	sta @FORTMP_0393_1

l_0396
; --- ForToDoCondition
	lda @FORTMP_0393_1::#$00
	cmp I+1
	bne @+
	lda @FORTMP_0393_0::#$00
	cmp I
@
	jcc l_03A2

; optimize OK (vbxe_memorystream.inc), line = 96

	ldy ADR+1
	sty :bp+1
	ldy ADR
	lda (:bp),y
	mvy DST+1 :bp+1
	ldy DST
	sta (:bp),y

; optimize FAIL (0, vbxe_memorystream.inc), line = 98

	inc ADR
	sne
	inc ADR+1

; optimize FAIL (0, vbxe_memorystream.inc), line = 99

	inc DST
	sne
	inc DST+1

; optimize OK (vbxe_memorystream.inc), line = 101

	lda ADR+1
	cmp #$C0
	jcc l_03C1
	bne @+
	lda ADR
	jcc l_03C1
@

; optimize FAIL (0, vbxe_memorystream.inc), line = 102

	inc BNK

; optimize OK (vbxe_memorystream.inc), line = 103

	lda BNK
	jsr VBXEMEMORYBANK

; optimize OK (vbxe_memorystream.inc), line = 104

	lda #$00
	sta ADR
	lda #$B0
	sta ADR+1
l_03C1

; --- ForToDoEpilog
	inc I
	jne l_0396
	inc I+1
	jne l_0396
l_03A2

; optimize OK (vbxe_memorystream.inc), line = 109

	lda #$00
	jsr VBXEMEMORYBANK

; optimize OK (vbxe_memorystream.inc), line = 111

	mwy POSITION :bp2
	ldy #$00
	lda (:bp2),y
	add COUNT
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc COUNT+1
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; ------------------------------------------------------------

TVBXEMEMORYSTREAM	= DATAORIGIN+$0083
BUFFER	= DATAORIGIN+$0085
COUNT	= DATAORIGIN+$0087
POSITION	= DATAORIGIN+$0089
SIZE	= DATAORIGIN+$008B
BNK	= DATAORIGIN+$008D
ADR	= DATAORIGIN+$008E
I	= DATAORIGIN+$0090
DST	= DATAORIGIN+$0092

@VarData	= TVBXEMEMORYSTREAM
@VarDataSize	= 17

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TVBXEMEMORYSTREAM.WRITEBUFFER			; PROCEDURE
	sta TVBXEMEMORYSTREAM
	sty TVBXEMEMORYSTREAM+1
	sta POSITION
	sty POSITION+1
	add #4
	scc
	iny
	sta SIZE
	sty SIZE+1

; optimize OK (vbxe_memorystream.inc), line = 124

	mwy POSITION :bp2
	ldy #$02
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	dey
	lda (:bp2),y
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	ora #$80
	sta BNK

; optimize OK (vbxe_memorystream.inc), line = 125

	dey
	lda (:bp2),y
	sta ADR
	iny
	lda (:bp2),y
	and #$0F
	ora #$B0
	sta ADR+1

; optimize OK (vbxe_memorystream.inc), line = 127

	lda BNK
	jsr VBXEMEMORYBANK

; optimize OK (vbxe_memorystream.inc), line = 129

	lda BUFFER
	sta SRC
	lda BUFFER+1
	sta SRC+1

; optimize OK (vbxe_memorystream.inc), line = 131

	lda #$00
	sta I
	sta I+1
	lda COUNT
	sub #$01
	sta @FORTMP_0409_0
	lda COUNT+1
	sbc #$00
	sta @FORTMP_0409_1

l_040C
; --- ForToDoCondition
	lda @FORTMP_0409_1::#$00
	cmp I+1
	bne @+
	lda @FORTMP_0409_0::#$00
	cmp I
@
	jcc l_0418

; optimize OK (vbxe_memorystream.inc), line = 133

	mwy SRC :bp2
	ldy #$00
	lda (:bp2),y
	ldy ADR+1
	sty :bp+1
	ldy ADR
	sta (:bp),y

; optimize FAIL (0, vbxe_memorystream.inc), line = 135

	inc ADR
	sne
	inc ADR+1

; optimize FAIL (0, vbxe_memorystream.inc), line = 136

	inc SRC
	sne
	inc SRC+1

; optimize OK (vbxe_memorystream.inc), line = 138

	lda ADR+1
	cmp #$C0
	jcc l_0437
	bne @+
	lda ADR
	jcc l_0437
@

; optimize FAIL (0, vbxe_memorystream.inc), line = 139

	inc BNK

; optimize OK (vbxe_memorystream.inc), line = 140

	lda BNK
	jsr VBXEMEMORYBANK

; optimize OK (vbxe_memorystream.inc), line = 141

	lda #$00
	sta ADR
	lda #$B0
	sta ADR+1
l_0437

; --- ForToDoEpilog
	inc I
	jne l_040C
	inc I+1
	jne l_040C
l_0418

; optimize OK (vbxe_memorystream.inc), line = 146

	lda #$00
	jsr VBXEMEMORYBANK

; optimize OK (vbxe_memorystream.inc), line = 148

	mwy POSITION :bp2
	ldy #$00
	lda (:bp2),y
	add COUNT
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc COUNT+1
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; ------------------------------------------------------------

TVBXEMEMORYSTREAM	= DATAORIGIN+$0096
BUFFER	= DATAORIGIN+$0098
COUNT	= DATAORIGIN+$009A
POSITION	= DATAORIGIN+$009C
SIZE	= DATAORIGIN+$009E
BNK	= DATAORIGIN+$00A0
ADR	= DATAORIGIN+$00A1
I	= DATAORIGIN+$00A3
SRC	= DATAORIGIN+$00A5

@VarData	= TVBXEMEMORYSTREAM
@VarDataSize	= 17

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TVBXEMEMORYSTREAM.READBYTE			; FUNCTION
	sta TVBXEMEMORYSTREAM
	sty TVBXEMEMORYSTREAM+1
	sta POSITION
	sty POSITION+1
	add #4
	scc
	iny
	sta SIZE
	sty SIZE+1

; optimize OK (vbxe_memorystream.inc), line = 158

	lda POSITION
	sta READVBXEMEMORYBYTE.POSITION
	lda POSITION+1
	sta READVBXEMEMORYBYTE.POSITION+1
	jsr READVBXEMEMORYBYTE
	lda READVBXEMEMORYBYTE.RESULT
	sta RESULT

; optimize OK (vbxe_memorystream.inc), line = 160

	lda #$00
	jsr VBXEMEMORYBANK
@exit

; ------------------------------------------------------------

TVBXEMEMORYSTREAM	= DATAORIGIN+$00A9
RESULT	= DATAORIGIN+$00AB
POSITION	= DATAORIGIN+$00AC
SIZE	= DATAORIGIN+$00AE

@VarData	= TVBXEMEMORYSTREAM
@VarDataSize	= 6

	rts						; ret
.endl

.local	TVBXEMEMORYSTREAM.WRITEBYTE			; PROCEDURE
	sta TVBXEMEMORYSTREAM
	sty TVBXEMEMORYSTREAM+1
	sta POSITION
	sty POSITION+1
	add #4
	scc
	iny
	sta SIZE
	sty SIZE+1

; optimize OK (vbxe_memorystream.inc), line = 198

	lda POSITION
	sta WRITEVBXEMEMORYBYTE.POSITION
	lda POSITION+1
	sta WRITEVBXEMEMORYBYTE.POSITION+1
	lda B
	sta WRITEVBXEMEMORYBYTE.A
	jsr WRITEVBXEMEMORYBYTE

; optimize OK (vbxe_memorystream.inc), line = 200

	lda #$00
	jsr VBXEMEMORYBANK

; ------------------------------------------------------------

TVBXEMEMORYSTREAM	= DATAORIGIN+$00B8
B	= DATAORIGIN+$00BA
POSITION	= DATAORIGIN+$00BB
SIZE	= DATAORIGIN+$00BD

@VarData	= TVBXEMEMORYSTREAM
@VarDataSize	= 7

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TVBXEMEMORYSTREAM.CLEAR				; PROCEDURE
	sta TVBXEMEMORYSTREAM
	sty TVBXEMEMORYSTREAM+1
	sta POSITION
	sty POSITION+1
	add #4
	scc
	iny
	sta SIZE
	sty SIZE+1

; optimize OK (vbxe_memorystream.inc), line = 239

	mwy POSITION :bp2
	ldy #$00
	lda (:bp2),y
	sta ADR
	iny
	lda (:bp2),y
	sta ADR+1
	iny
	lda (:bp2),y
	sta ADR+2
	iny
	lda (:bp2),y
	sta ADR+3

; optimize OK (vbxe_memorystream.inc), line = 240

	mwy SIZE :bp2
	ldy #$00
	lda (:bp2),y
	sta SIZ
	iny
	lda (:bp2),y
	sta SIZ+1
	iny
	lda (:bp2),y
	sta SIZ+2
	iny
	lda (:bp2),y
	sta SIZ+3

; -------------------  ASM Block 00000114  -------------------

	txa:pha

	mva adr _adr
	mva adr+1 _adr+1
	mva adr+2 _adr+2

	fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000

loop	cpw _adr+1 siz+1
	bcs skp

	ldy #20
	mva:rpl bltClr,y MAIN.SYSTEM.VBXE_WINDOW+MAIN.SYSTEM.VBXE_BCBTMP,y-

	fxs FX_BL_ADR0 #MAIN.SYSTEM.VBXE_BCBTMP	; program blittera od adresu MAIN.SYSTEM.VBXE_BCBTMP
	fxs FX_BL_ADR1 #$00			; zaraz za programem VBXE Display List
	fxsa FX_BL_ADR2

	fxs FX_BLITTER_START #$01	; !!! start gdy 1 !!!

wait	fxla FX_BLITTER_BUSY
	bne wait

	lda #$00
	sta _adr
	inw _adr+1

	jmp loop

skp	fxs FX_MEMS #$00		; disable VBXE bank

	jmp stop

bltClr	.long 0x00	; source address
	.word 0x00	; source step y
	.byte 0x00	; source step x
_adr	.long 0x00	; destination address
	.word 0x0100	; destination step y
	.byte 0x01	; destination step x
_siz	.word 0xff	; width
	.byte 0x00	; height
	dta 0x00	; and mask (and mask equal to 0, memory will be filled with xor mask)
	dta 0x00	; xor mask
	dta 0x00	; collision and mask
	dta 0x00	; zoom
	dta 0x00	; pattern feature
	dta 0x00	; control

stop	pla:tax

; optimize OK (vbxe_memorystream.inc), line = 292

	mwy POSITION :bp2
	ldy #$00
	tya
	sta (:bp2),y
	iny
	sta (:bp2),y
	iny
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (vbxe_memorystream.inc), line = 293

	mwy SIZE :bp2
	ldy #$00
	sta (:bp2),y
	iny
	sta (:bp2),y
	iny
	lda #$08
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; ------------------------------------------------------------

TVBXEMEMORYSTREAM	= DATAORIGIN+$00C7
POSITION	= DATAORIGIN+$00C9
SIZE	= DATAORIGIN+$00CB
ADR	= DATAORIGIN+$00CD
SIZ	= DATAORIGIN+$00D1

@VarData	= TVBXEMEMORYSTREAM
@VarDataSize	= 14

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	COLORMAPOFF					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000123  -------------------

	@setxdl #e@xdl.mapoff

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SETHORIZONTALRES				; PROCEDURE | OVERLOAD
.local	@0201810000180000

; optimize OK (VBXE), line = 643

	lda A
	sta SYSTEM.GRAPHMODE

; optimize OK (VBXE), line = 645

	lda #$C0
	sta SYSTEM.SCREENHEIGHT
	lda #$00
	sta SYSTEM.SCREENHEIGHT+1

; optimize OK (VBXE), line = 647

	lda A
	sta @CASETMP_0005
	cmp #$0A
	jne l_04AE
@

; optimize OK (VBXE), line = 648

	lda #$A0
	sta SYSTEM.SCREENWIDTH
	lda #$00
	sta SYSTEM.SCREENWIDTH+1
	lda #$01
	sta A
	jmp a_0005
l_04AE
	cmp #$1F
	jne l_04BD

; optimize OK (VBXE), line = 649

	lda #$40
	sta SYSTEM.SCREENWIDTH
	lda #$01
	sta SYSTEM.SCREENWIDTH+1
	lda #$02
	sta A
	jmp a_0005
l_04BD
	cmp #$18
	jne l_04CC

; optimize OK (VBXE), line = 650

	lda #$80
	sta SYSTEM.SCREENWIDTH
	lda #$02
	sta SYSTEM.SCREENWIDTH+1
	lda #$03
	sta A
	jmp a_0005
l_04CC

; optimize OK (VBXE), line = 654

	lda #$50
	sta SYSTEM.SCREENWIDTH
	lda #$00
	sta SYSTEM.SCREENWIDTH+1

; optimize OK (VBXE), line = 655

	lda #$18
	sta SYSTEM.SCREENHEIGHT
	lda #$00
	sta SYSTEM.SCREENHEIGHT+1

; optimize OK (VBXE), line = 656

	lda #$02
	sta A
a_0005

; -------------------  ASM Block 00000124  -------------------

	txa:pha

	lda MAIN.SYSTEM.ScreenWidth
	ldx MAIN.SYSTEM.ScreenWidth+1

	ldy MAIN.SYSTEM.ScreenHeight

	@SCREENSIZE

	@setxdl a

	fxs FX_MEMS #$80+MAIN.SYSTEM.VBXE_XDLADR/$1000

	ldy #s@xdl.ovstep

	lda s
	sta MAIN.SYSTEM.VBXE_WINDOW,y

	lda s+1
	sta MAIN.SYSTEM.VBXE_WINDOW+1,y

	fxs FX_MEMS #$00

	pla:tax

; ------------------------------------------------------------

A	= DATAORIGIN+$00D5
S	= DATAORIGIN+$00D6
@CASETMP_0005	= DATAORIGIN+$00D8

@VarData	= A
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	SETHORIZONTALRES				; PROCEDURE | OVERLOAD
.local	@010180000
	sta A

; optimize OK (VBXE), line = 698

	sta SETHORIZONTALRES.@0201810000180000.A
	lda #$40
	sta SETHORIZONTALRES.@0201810000180000.S
	lda #$01
	sta SETHORIZONTALRES.@0201810000180000.S+1
	jsr SETHORIZONTALRES.@0201810000180000

; ------------------------------------------------------------

A	= DATAORIGIN+$00D9

@VarData	= A
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	RUNBCB						; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000126  -------------------

	fxs	FX_BL_ADR0	a
	lda	a+1
	and	#$0f
	fxsa	FX_BL_ADR1
	fxs	FX_BL_ADR2	#$00

	fxs	FX_BLITTER_START #$01		; !!! start gdy 1 !!!

;wait	fxla	FX_BLITTER_BUSY
;	bne	wait

; ------------------------------------------------------------

A	= DATAORIGIN+$00DA
A.SRC_ADR	= DATAORIGIN+$0000
A.SRC_ADR.BYTE0	= DATAORIGIN+$0000
A.SRC_ADR.BYTE1	= DATAORIGIN+$0001
A.SRC_ADR.BYTE2	= DATAORIGIN+$0002
A.SRC_STEP_Y	= DATAORIGIN+$0003
A.SRC_STEP_X	= DATAORIGIN+$0005
A.DST_ADR	= DATAORIGIN+$0006
A.DST_ADR.BYTE0	= DATAORIGIN+$0006
A.DST_ADR.BYTE1	= DATAORIGIN+$0007
A.DST_ADR.BYTE2	= DATAORIGIN+$0008
A.DST_STEP_Y	= DATAORIGIN+$0009
A.DST_STEP_X	= DATAORIGIN+$000B
A.BLT_WIDTH	= DATAORIGIN+$000C
A.BLT_HEIGHT	= DATAORIGIN+$000E
A.BLT_AND_MASK	= DATAORIGIN+$000F
A.BLT_XOR_MASK	= DATAORIGIN+$0010
A.BLT_COLLISION_MASK	= DATAORIGIN+$0011
A.BLT_ZOOM	= DATAORIGIN+$0012
A.PATTERN_FEATURE	= DATAORIGIN+$0013
A.BLT_CONTROL	= DATAORIGIN+$0014

@VarData	= A
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	VBXECONTROL					; PROCEDURE | ASSEMBLER
	sta A

; -------------------  ASM Block 00000130  -------------------

	fxs FX_VIDEO_CONTROL a

; ------------------------------------------------------------

A	= DATAORIGIN+$00DE

@VarData	= A
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------
; ------------------------------------------------------------
@UnitInit

; -------------------  ASM Block 00000138  -------------------

	txa:pha

	jsr @vbxe_detect
	bcc ok

	ldx #MAIN.GRAPH.grNoInitGraph
	bne status

ok	jsr @vbxe_init

	ldx #MAIN.GRAPH.grOK
status	stx MAIN.GRAPH.GraphResult

	pla:tax

	rts

; ------------------------------------------------------------

VC_XDL	= $01
VC_XCOLOR	= $02
VC_NO_TRANS	= $04
VC_TRANS15	= $08
TCBLACK	= $00
TCRED	= $01
TCGREEN	= $02
TCYELLOW	= $03
TCBLUE	= $04
TCMAGENTA	= $05
TCCYAN	= $06
TCWHITE	= $07
TCBRIGHTBLACK	= $08
TCBRIGHTRED	= $09
TCBRIGHTGREEN	= $0A
TCBRIGHTYELLOW	= $0B
TCBRIGHTBLUE	= $0C
TCBRIGHTMAGENTA	= $0D
TCBRIGHTCYAN	= $0E
TCBRIGHTWHITE	= $0F
TBBLACK	= $80
TBRED	= $90
TBGREEN	= $A0
TBYELLOW	= $B0
TBBLUE	= $C0
TBMAGENTA	= $D0
TBCYAN	= $E0
TBWHITE	= $F0
adr.VRAM	= DATAORIGIN+$0066	; [8] OBJECT
.var VRAM	= adr.VRAM .word
VRAM.POSITION	= DATAORIGIN+$0066
VRAM.SIZE	= DATAORIGIN+$006A
SCROLLBACK_FILL	= $63
COLORMAPCONTROL = @VBXE_CMAP.CONFIG
adr.SCROLLBACK_BUFFER	= $0400
.var SCROLLBACK_BUFFER	= adr.SCROLLBACK_BUFFER .word
FILDAT	= $02FD
ROWCRS	= $54
COLCRS	= $55
CRSADR	= $68

.endl							; UNIT VBXE

; ------------------------------------------------------------

.local	JOYSTICK					; UNIT

; ------------------------------------------------------------

JOY_NONE	= $0F
JOY_UP	= $0E
JOY_DOWN	= $0D
JOY_LEFT	= $0B
JOY_LEFT_UP	= $0A
JOY_LEFT_DOWN	= $09
JOY_RIGHT	= $07
JOY_RIGHT_UP	= $06
JOY_RIGHT_DOWN	= $05
JOY_1	= $0278
JOY_2	= $0279
adr.STICK	= $0278
.var STICK	= adr.STICK .word
STICK0	= $0278
STICK1	= $0279
adr.STRIG	= $0284
.var STRIG	= adr.STRIG .word
STRIG0	= $0284
STRIG1	= $0285
adr.PADDL	= $0270
.var PADDL	= adr.PADDL .word
PADDL0	= $0270
PADDL1	= $0271
PADDL2	= $0272
PADDL3	= $0273
PADDL4	= $0274
PADDL5	= $0275
PADDL6	= $0276
PADDL7	= $0277
adr.PTRIG	= $027C
.var PTRIG	= adr.PTRIG .word
PTRIG0	= $027C
PTRIG1	= $027D
PTRIG2	= $027E
PTRIG3	= $027F
PTRIG4	= $0280
PTRIG5	= $0281
PTRIG6	= $0282
PTRIG7	= $0283
TRIG0	= $D010
TRIG1	= $D011
POT0	= $D200
ALLPOT	= $D208
POTGO	= $D20B

.endl							; UNIT JOYSTICK

.local	START_LEVEL					; PROCEDURE

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DEATH_SOUND					; PROCEDURE

; ------------------------------------------------------------

A	= DATAORIGIN+$00E7

@VarData	= A
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BALL_BLOCK_SOUND				; PROCEDURE

; ------------------------------------------------------------

A	= DATAORIGIN+$00E9
B	= DATAORIGIN+$00EB

@VarData	= A
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SQRT32						; FUNCTION

; optimize OK (arkanoid_vbxe.pas), line = 90

	lda V
	sta R
	lda V+1
	sta R+1
	lda V+2
	sta R+2
	lda V+3
	sta R+3

; optimize OK (arkanoid_vbxe.pas), line = 91

	lda #$00
	sta Q
	sta Q+1
	sta Q+2
	sta Q+3

; optimize OK (arkanoid_vbxe.pas), line = 92

	sta B
	sta B+1
	sta B+2
	lda #$40

; --- WhileProlog
	jmp l_0513
l_0514

; optimize OK (arkanoid_vbxe.pas), line = 94

	lda B
	sta :STACKORIGIN+9
	lda B+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda B+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda B+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lsr :STACKORIGIN+STACKWIDTH*3+9
	ror :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*3+9
	ror :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta B
	lda :STACKORIGIN+STACKWIDTH+9
	sta B+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	sta B+2
	lda :STACKORIGIN+STACKWIDTH*3+9
l_0513
	sta B+3
	cmp R+3
	bne @+
	lda B+2
	cmp R+2
	bne @+
	lda B+1
	cmp R+1
	bne @+
	lda B
	cmp R
@
	beq @+
	jcs l_0514
@

; --- WhileProlog
	jmp l_0528
l_0529

; optimize OK (arkanoid_vbxe.pas), line = 97

	lda Q
	add B
	sta T
	lda Q+1
	adc B+1
	sta T+1
	lda Q+2
	adc B+2
	sta T+2
	lda Q+3
	adc B+3
	sta T+3

; optimize OK (arkanoid_vbxe.pas), line = 99

	lsr Q+3
	ror Q+2
	ror Q+1
	ror Q

; optimize OK (arkanoid_vbxe.pas), line = 101

	lda R+3
	cmp T+3
	bne @+
	lda R+2
	cmp T+2
	bne @+
	lda R+1
	cmp T+1
	bne @+
	lda R
	cmp T
@
	jcc l_0549

; optimize OK (arkanoid_vbxe.pas), line = 102

	lda R
	sbc T
	sta R
	lda R+1
	sbc T+1
	sta R+1
	lda R+2
	sbc T+2
	sta R+2
	lda R+3
	sbc T+3
	sta R+3

; optimize OK (arkanoid_vbxe.pas), line = 103

	lda Q
	add B
	sta Q
	lda Q+1
	adc B+1
	sta Q+1
	lda Q+2
	adc B+2
	sta Q+2
	lda Q+3
	adc B+3
	sta Q+3
l_0549

; optimize OK (arkanoid_vbxe.pas), line = 106

	lda B
	sta :STACKORIGIN+9
	lda B+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda B+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda B+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lsr :STACKORIGIN+STACKWIDTH*3+9
	ror :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*3+9
	ror :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta B
	lda :STACKORIGIN+STACKWIDTH+9
	sta B+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	sta B+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	sta B+3
l_0528

; optimize OK (arkanoid_vbxe.pas), line = 96

	lda B+3
	cmp #$00
	bne @+
	lda B+2
	cmp #$00
	bne @+
	lda B+1
	cmp #$00
	bne @+
	lda B
	cmp #$00
@
	beq @+
	jcs l_0529
@

; optimize OK (arkanoid_vbxe.pas), line = 110

	lda Q
	sta RESULT
	lda Q+1
	sta RESULT+1
@exit

; ------------------------------------------------------------

V	= DATAORIGIN+$00ED
RESULT	= DATAORIGIN+$00F1
B	= DATAORIGIN+$00F3
Q	= DATAORIGIN+$00F7
R	= DATAORIGIN+$00FB
T	= DATAORIGIN+$00FF

@VarData	= V
@VarDataSize	= 20

	rts						; ret
.endl

.local	MOUSECOORDS					; PROCEDURE

; optimize OK (service.pas), line = 298

	lda ATARI.PORTA
	and #$0F
	sta A

; optimize OK (service.pas), line = 300

	sta @CASETMP_0007
	cmp #$0B
	jne l_058B
@

; optimize OK (service.pas), line = 301

	mwy X :bp2
	ldy #$00
	lda (:bp2),y
	iny
	cmp #$0B
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jmi l_059C
	mwy X :bp2
	ldy #$00
	lda (:bp2),y
	sub #$04
	sta (:bp2),y
	iny
	lda (:bp2),y
	sbc #$00
	sta (:bp2),y
l_059C
	jmp a_0007
l_058B
	cmp #$07
	jne l_05A7

; optimize OK (service.pas), line = 302

	mwy X :bp2
	ldy #$00
	lda (:bp2),y
	iny
	cmp #$D8
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jpl l_05B8
	mwy X :bp2
	ldy #$00
	lda (:bp2),y
	add #$04
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y
l_05B8
l_05A7
a_0007

; ------------------------------------------------------------

X	= DATAORIGIN+$0208
A	= DATAORIGIN+$020A
@CASETMP_0007	= DATAORIGIN+$020B

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MOUSECLICK					; FUNCTION

; optimize OK (service.pas), line = 312

?volatile:
	lda JOYSTICK.TRIG0
	eor #$01
	sta RESULT
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$020C

	rts						; ret
.endl

.local	BLITBOX						; PROCEDURE

; -------------------  ASM Block 00000141  -------------------

	  fxs FX_MEMS #$80
	
; optimize OK (service.pas), line = 325

	lda SRC+2
	sta BLT.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 326

	lda SRC+1
	sta BLT.SRC_ADR.BYTE1

; optimize OK (service.pas), line = 327

	lda SRC
	sta BLT.SRC_ADR.BYTE0

; optimize OK (service.pas), line = 329

	lda DST+2
	sta BLT.DST_ADR.BYTE2

; optimize OK (service.pas), line = 330

	lda DST+1
	sta BLT.DST_ADR.BYTE1

; optimize OK (service.pas), line = 331

	lda DST
	sta BLT.DST_ADR.BYTE0

; optimize OK (service.pas), line = 333

	lda #$01
	sta BLT.SRC_STEP_X

; optimize OK (service.pas), line = 334

	sta BLT.DST_STEP_X

; optimize OK (service.pas), line = 336

	lda #$40
	sta BLT.DST_STEP_Y
	lda #$01
	sta BLT.DST_STEP_Y+1

; optimize OK (service.pas), line = 337

	lda #$40
	sta BLT.SRC_STEP_Y
	lda #$01
	sta BLT.SRC_STEP_Y+1

; optimize OK (service.pas), line = 339

	lda W
	sub #$01
	sta BLT.BLT_WIDTH
	lda W+1
	sbc #$00
	sta BLT.BLT_WIDTH+1

; optimize OK (service.pas), line = 340

	ldy H
	dey
	sty BLT.BLT_HEIGHT

; optimize OK (service.pas), line = 342

	lda #$FF
	sta BLT.BLT_AND_MASK

; optimize OK (service.pas), line = 344

	lda #$00
	sta BLT.BLT_ZOOM

; optimize OK (service.pas), line = 346

	sta BLT.BLT_CONTROL

; -------------------  ASM Block 00000142  -------------------

	  fxs FX_MEMS #$00
	
; optimize OK (service.pas), line = 352

	lda BLT
	sta VBXE.RUNBCB.A
	lda BLT+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; ------------------------------------------------------------

SRC	= DATAORIGIN+$020D
DST	= DATAORIGIN+$0211
W	= DATAORIGIN+$0215
H	= DATAORIGIN+$0217

@VarData	= SRC
@VarDataSize	= 11

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BLITZERO					; PROCEDURE

; -------------------  ASM Block 00000143  -------------------

	  fxs FX_MEMS #$80
	
; optimize OK (service.pas), line = 368

	lda SRC+2
	sta BLT.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 369

	lda SRC+1
	sta BLT.SRC_ADR.BYTE1

; optimize OK (service.pas), line = 370

	lda SRC
	sta BLT.SRC_ADR.BYTE0

; optimize OK (service.pas), line = 372

	lda DST+2
	sta BLT.DST_ADR.BYTE2

; optimize OK (service.pas), line = 373

	lda DST+1
	sta BLT.DST_ADR.BYTE1

; optimize OK (service.pas), line = 374

	lda DST
	sta BLT.DST_ADR.BYTE0

; optimize OK (service.pas), line = 376

	lda #$01
	sta BLT.SRC_STEP_X

; optimize OK (service.pas), line = 377

	sta BLT.DST_STEP_X

; optimize OK (service.pas), line = 379

	sta BLT.BLT_CONTROL

; optimize OK (service.pas), line = 381

	lda #$40
	sta BLT.DST_STEP_Y
	lda #$01
	sta BLT.DST_STEP_Y+1

; optimize OK (service.pas), line = 382

	lda W
	sta BLT.SRC_STEP_Y
	lda W+1
	sta BLT.SRC_STEP_Y+1

; optimize OK (service.pas), line = 384

	ldy H
	dey
	sty BLT.BLT_HEIGHT

; optimize OK (service.pas), line = 386

	lda W
	sub #$01
	sta BLT.BLT_WIDTH
	lda W+1
	sbc #$00
	sta BLT.BLT_WIDTH+1

; optimize OK (service.pas), line = 388

	lda #$FF
	sta BLT.BLT_AND_MASK

; -------------------  ASM Block 00000144  -------------------

	  fxs FX_MEMS #$00
	
; optimize OK (service.pas), line = 395

	lda BLT
	sta VBXE.RUNBCB.A
	lda BLT+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; ------------------------------------------------------------

SRC	= DATAORIGIN+$0218
DST	= DATAORIGIN+$021C
W	= DATAORIGIN+$0220
H	= DATAORIGIN+$0222

@VarData	= SRC
@VarDataSize	= 11

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BLITTMP						; PROCEDURE

; optimize OK (service.pas), line = 407

	lda DST
	sta VBXE_RAM.POSITION
	lda DST+1
	sta VBXE_RAM.POSITION+1
	lda DST+2
	sta VBXE_RAM.POSITION+2
	lda DST+3
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 409

	lda TMP
	sta VBXE.TVBXEMEMORYSTREAM.WRITEBUFFER.BUFFER
	lda TMP+1
	sta VBXE.TVBXEMEMORYSTREAM.WRITEBUFFER.BUFFER+1
	lda SIZE
	sta VBXE.TVBXEMEMORYSTREAM.WRITEBUFFER.COUNT
	lda #$00
	sta VBXE.TVBXEMEMORYSTREAM.WRITEBUFFER.COUNT+1
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.WRITEBUFFER

; ------------------------------------------------------------

DST	= DATAORIGIN+$0223
SIZE	= DATAORIGIN+$0227

@VarData	= DST
@VarDataSize	= 5

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BLITROW						; PROCEDURE

; -------------------  ASM Block 00000145  -------------------

	  fxs FX_MEMS #$80
	
; optimize OK (service.pas), line = 425

	lda SRC+2
	sta BLT.SRC_ADR.BYTE2

; optimize OK (service.pas), line = 426

	lda SRC+1
	sta BLT.SRC_ADR.BYTE1

; optimize OK (service.pas), line = 427

	lda SRC
	sta BLT.SRC_ADR.BYTE0

; optimize OK (service.pas), line = 429

	lda DST+2
	sta BLT.DST_ADR.BYTE2

; optimize OK (service.pas), line = 430

	lda DST+1
	sta BLT.DST_ADR.BYTE1

; optimize OK (service.pas), line = 431

	lda DST
	sta BLT.DST_ADR.BYTE0

; optimize OK (service.pas), line = 433

	lda #$01
	sta BLT.SRC_STEP_X

; optimize OK (service.pas), line = 434

	sta BLT.DST_STEP_X

; optimize OK (service.pas), line = 436

	lda #$00
	sta BLT.SRC_STEP_Y
	sta BLT.SRC_STEP_Y+1

; optimize OK (service.pas), line = 437

	sta BLT.DST_STEP_Y
	sta BLT.DST_STEP_Y+1

; optimize OK (service.pas), line = 439

	sta BLT.BLT_HEIGHT

; optimize OK (service.pas), line = 440

	sta BLT.BLT_CONTROL

; optimize OK (service.pas), line = 442

	lda SIZE
	sub #$01
	sta BLT.BLT_WIDTH
	lda SIZE+1
	sbc #$00
	sta BLT.BLT_WIDTH+1

; optimize OK (service.pas), line = 444

	lda #$FF
	sta BLT.BLT_AND_MASK

; -------------------  ASM Block 00000146  -------------------

	  fxs FX_MEMS #$00
	
; optimize OK (service.pas), line = 450

	lda BLT
	sta VBXE.RUNBCB.A
	lda BLT+1
	sta VBXE.RUNBCB.A+1
	jsr VBXE.RUNBCB

; ------------------------------------------------------------

SRC	= DATAORIGIN+$0228
DST	= DATAORIGIN+$022C
SIZE	= DATAORIGIN+$0230

@VarData	= SRC
@VarDataSize	= 10

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PUTBYTE						; PROCEDURE

; optimize OK (service.pas), line = 477

	lda DST
	sta VBXE_RAM.POSITION
	lda DST+1
	sta VBXE_RAM.POSITION+1
	lda DST+2
	sta VBXE_RAM.POSITION+2
	lda DST+3
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 478

	lda V
	sta VBXE.TVBXEMEMORYSTREAM.WRITEBYTE.B
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.WRITEBYTE

; ------------------------------------------------------------

DST	= DATAORIGIN+$0232
V	= DATAORIGIN+$0236

@VarData	= DST
@VarDataSize	= 5

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	GETBYTE						; FUNCTION

; optimize OK (service.pas), line = 488

	lda SRC
	sta VBXE_RAM.POSITION
	lda SRC+1
	sta VBXE_RAM.POSITION+1
	lda SRC+2
	sta VBXE_RAM.POSITION+2
	lda SRC+3
	sta VBXE_RAM.POSITION+3

; optimize FAIL ('VBXE.TVBXEMEMORYSTREAM.READBYTE', service.pas), line = 489

	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.READBYTE
	lda VBXE.TVBXEMEMORYSTREAM.READBYTE.RESULT
	sta RESULT
@exit

; ------------------------------------------------------------

SRC	= DATAORIGIN+$0237
RESULT	= DATAORIGIN+$023B

@VarData	= SRC
@VarDataSize	= 4

	rts						; ret
.endl

.local	NOSOUND						; PROCEDURE

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MYDELAY						; PROCEDURE

; ------------------------------------------------------------

A	= DATAORIGIN+$023C

@VarData	= A
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MAX						; FUNCTION

; optimize OK (service.pas), line = 615

	lda B
	cmp A
	lda B+1
	sbc A+1
	svc
	eor #$80
	jpl l_071F
	lda A
	sta RESULT
	lda A+1
	jmp l_072E
l_071F

; optimize OK (service.pas), line = 616

	lda B
	sta RESULT
	lda B+1
l_072E
	sta RESULT+1
@exit

; ------------------------------------------------------------

A	= DATAORIGIN+$023E
B	= DATAORIGIN+$0240
RESULT	= DATAORIGIN+$0242

@VarData	= A
@VarDataSize	= 4

	rts						; ret
.endl

.local	MIN						; FUNCTION

; optimize OK (service.pas), line = 622

	lda A
	cmp B
	lda A+1
	sbc B+1
	svc
	eor #$80
	jpl l_0749
	lda A
	sta RESULT
	lda A+1
	jmp l_0758
l_0749

; optimize OK (service.pas), line = 623

	lda B
	sta RESULT
	lda B+1
l_0758
	sta RESULT+1
@exit

; ------------------------------------------------------------

A	= DATAORIGIN+$0244
B	= DATAORIGIN+$0246
RESULT	= DATAORIGIN+$0248

@VarData	= A
@VarDataSize	= 4

	rts						; ret
.endl

.local	FATAL_ERROR					; PROCEDURE
	sta ERR_TYPE

; optimize OK (service.pas), line = 632

	sta STATUS

; -------------------  ASM Block 00000147  -------------------

      sta $100
      
      kk: lda $d20a
      sta $d01a
      jmp kk
    
    
; ------------------------------------------------------------

ERR_TYPE	= DATAORIGIN+$024A

@VarData	= ERR_TYPE
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	INITROWARRAY					; PROCEDURE

; optimize OK (service.pas), line = 680

	lda #$00
	sta HLP
	sta HLP+1

; optimize OK (service.pas), line = 682

	sta Y

l_0778
; --- ForToDoCondition
	ldy Y
	cpy #$C8
	jcc l_0798

; optimize OK (service.pas), line = 685

	lda #$00
	sta adr.ROW,y
	lda #$FA
	jmp l_07A9
l_0798

; optimize OK (service.pas), line = 687

	ldy Y
	lda HLP
	sta adr.ROW,y
	lda HLP+1
l_07A9
	sta adr.ROW+256,y

; optimize OK (service.pas), line = 689

	lda HLP
	add #$40
	sta HLP
	lda HLP+1
	adc #$01
	sta HLP+1

; --- ForToDoEpilog
	inc Y
	jne l_0778
l_0786

; ------------------------------------------------------------

Y	= DATAORIGIN+$024B

@VarData	= Y
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	INITSVGA					; PROCEDURE

; optimize OK (service.pas), line = 705

	lda GRAPH.GRAPHRESULT
	cmp #$01
	jeq l_07CD

; optimize FAIL ('@print', service.pas), line = 706

	@printSTRING #CODEORIGIN+$0000
	@printEOL
	lda #$00
	jmp @halt
l_07CD

; optimize OK (service.pas), line = 710

	lda #$1F
	jsr VBXE.SETHORIZONTALRES.@010180000

; optimize FAIL ('VBXE.COLORMAPOFF', service.pas), line = 711

	jsr VBXE.COLORMAPOFF

; optimize OK (service.pas), line = 713

	lda #$07
	jsr VBXE.VBXECONTROL

; optimize OK (service.pas), line = 715

	lda #$14
	jsr VBXE.SETTOPBORDER

; optimize OK (service.pas), line = 716

	lda #$C8
	jsr VBXE.SETXDLHEIGHT

; optimize OK (service.pas), line = 718

	lda #$00
	sta VBXE_RAM.POSITION
	lda #$50
	sta VBXE_RAM.POSITION+1
	lda #$00
	sta VBXE_RAM.POSITION+2
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 719

	sta VBXE_RAM.SIZE
	lda #$FA
	sta VBXE_RAM.SIZE+1
	lda #$00
	sta VBXE_RAM.SIZE+2
	sta VBXE_RAM.SIZE+3

; optimize FAIL ('VBXE.TVBXEMEMORYSTREAM.CLEAR', service.pas), line = 720

	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.CLEAR

; optimize OK (service.pas), line = 722

	lda #$00
	sta ATARI.DMACTL

; -------------------  ASM Block 00000148  -------------------

	  fxs FX_MEMS #$80
	
; optimize OK (service.pas), line = 728

	lda BLT
	sta :bp2
	lda BLT+1
	sta :bp2+1
	lda #$00
	ldy #$14
	sta:rpl (:bp2),y-

; -------------------  ASM Block 00000149  -------------------

	  fxs FX_MEMS #$00
	
@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SHINE_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 772

	lda SHINEREC.XB
	sta XB
	lda #$00
	sta XB+1

; optimize OK (service.pas), line = 773

	lda SHINEREC.YB
	sta YB
	lda #$00
	sta YB+1

; optimize OK (service.pas), line = 775

	lda YB
	asl @
	asl @
	asl @
	asl @
	add XB
	sta I

; optimize OK (service.pas), line = 777

	tay
	lda adr.WALL,y
	cmp #$09
	jcc l_0820

; optimize OK (service.pas), line = 779

	lda SHINEREC.FRAME
	lsr @
	sta FRAME
	lda #$00
	sta FRAME+1

; optimize OK (service.pas), line = 780

	lda adr.WALL,y
	cmp #$0A
	jeq l_0840
	lda FRAME
	add #$05
	sta FRAME
	scc
	inc FRAME+1
l_0840

; optimize OK (service.pas), line = 782

	lda XB
	sta :STACKORIGIN+10
	lda XB+1
	sta :STACKORIGIN+STACKWIDTH+10
	asl :STACKORIGIN+10
	rol :STACKORIGIN+STACKWIDTH+10
	asl :STACKORIGIN+10
	rol :STACKORIGIN+STACKWIDTH+10
	asl :STACKORIGIN+10
	rol :STACKORIGIN+STACKWIDTH+10
	asl :STACKORIGIN+10
	rol :STACKORIGIN+STACKWIDTH+10
	lda #$09
	add :STACKORIGIN+10
	sta XF
	lda #$00
	adc :STACKORIGIN+STACKWIDTH+10
	sta XF+1

; optimize OK (service.pas), line = 783

	lda YB
	sta :STACKORIGIN+10
	lda YB+1
	sta :STACKORIGIN+STACKWIDTH+10
	asl :STACKORIGIN+10
	rol :STACKORIGIN+STACKWIDTH+10
	asl :STACKORIGIN+10
	rol :STACKORIGIN+STACKWIDTH+10
	asl :STACKORIGIN+10
	rol :STACKORIGIN+STACKWIDTH+10
	lda #$16
	add :STACKORIGIN+10
	sta YF
	lda #$00
	adc :STACKORIGIN+STACKWIDTH+10
	sta YF+1

; optimize OK (service.pas), line = 784

	lda FRAME
	sta :STACKORIGIN+9
	lda FRAME+1
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	sta FR+1
	lda :STACKORIGIN+9
	sta FR

; optimize OK (service.pas), line = 786

	lda #$00
	sta Y

l_0870
; --- ForToDoCondition
	lda Y
	cmp #$08
	jcs l_087E

; optimize OK (service.pas), line = 788

	sta :STACKORIGIN+9
	lda #$00
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	sta OG+1
	lda :STACKORIGIN+9
	sta OG

; optimize OK (service.pas), line = 791

	lda XF
	sta :STACKORIGIN+10
	lda #$50
	add XF+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda YF
	add Y
	tay
	lda :STACKORIGIN+10
	add adr.ROW,y
	sta BLITROW.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256,y
	sta BLITROW.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta BLITROW.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta BLITROW.DST+3
	lda SHINEWALL.OFS
	add FR
	sta :STACKORIGIN+11
	lda SHINEWALL.OFS+1
	adc FR+1
	sta :STACKORIGIN+STACKWIDTH+11
	lda SHINEWALL.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+11
	lda SHINEWALL.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+11
	lda :STACKORIGIN+11
	add OG
	sta BLITROW.SRC
	lda :STACKORIGIN+STACKWIDTH+11
	adc OG+1
	sta BLITROW.SRC+1
	lda :STACKORIGIN+STACKWIDTH*2+11
	adc #$00
	sta BLITROW.SRC+2
	lda :STACKORIGIN+STACKWIDTH*3+11
	adc #$00
	sta BLITROW.SRC+3
	lda #$10
	sta BLITROW.SIZE
	lda #$00
	sta BLITROW.SIZE+1
	jsr BLITROW

; --- ForToDoEpilog
	inc Y
	jne l_0870
l_087E
l_0820

; optimize FAIL (0, service.pas), line = 795

	inc SHINEREC.FRAME

; optimize OK (service.pas), line = 796

	lda SHINEREC.FRAME
	cmp #$0A
	jne l_08C5
	lda #$00
	sta SHINEREC.ACTIVE
l_08C5

; ------------------------------------------------------------

XB	= DATAORIGIN+$024C
YB	= DATAORIGIN+$024E
FRAME	= DATAORIGIN+$0250
XF	= DATAORIGIN+$0252
YF	= DATAORIGIN+$0254
FR	= DATAORIGIN+$0256
OG	= DATAORIGIN+$0258
Y	= DATAORIGIN+$025A
I	= DATAORIGIN+$025B

@VarData	= XB
@VarDataSize	= 16

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	UNSHINE_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 805

	lda #$09
	sta SHINEREC.FRAME

; optimize FAIL ('SHINE_BLOCK', service.pas), line = 806

	jsr SHINE_BLOCK

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SHINE						; PROCEDURE

; optimize OK (service.pas), line = 813

	lda SHINEREC.ACTIVE
	jeq l_08E5
	jsr UNSHINE_BLOCK
l_08E5

; optimize OK (service.pas), line = 815

	lda XB
	sta SHINEREC.XB

; optimize OK (service.pas), line = 816

	lda YB
	sta SHINEREC.YB

; optimize OK (service.pas), line = 817

	lda #$00
	sta SHINEREC.FRAME

; optimize OK (service.pas), line = 818

	lda #$01
	sta SHINEREC.ACTIVE

; optimize OK (service.pas), line = 819

	lda YB
	asl @
	asl @
	asl @
	asl @
	add XB
	tay
	lda adr.WALL,y
	sta SHINEREC.BLOCK

; ------------------------------------------------------------

XB	= DATAORIGIN+$025C
YB	= DATAORIGIN+$025D

@VarData	= XB
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CHECKSHINE					; PROCEDURE

; optimize OK (service.pas), line = 825

	lda SHINEREC.ACTIVE
	cmp #$01
	jne l_0926
	jsr SHINE_BLOCK
l_0926

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	RANDOM_LETTER_DROP				; FUNCTION

; --- RepeatUntilProlog
l_092F

; optimize OK (service.pas), line = 833

	lda #$64
	jsr SYSTEM.RANDOM.@010180000
	lda SYSTEM.RANDOM.@010180000.RESULT
	sta RN
	lda #$00
	sta RN+1

; optimize OK (service.pas), line = 834

	lda #$00
	sta SUM
	sta SUM+1

; optimize OK (service.pas), line = 835

	sta LETTER
	sta LETTER+1

; --- RepeatUntilProlog
l_093D

; optimize FAIL (0, service.pas), line = 840

	inc LETTER
	sne
	inc LETTER+1

; optimize OK (service.pas), line = 841

	ldy LETTER
	lda adr.LETTER_DIS,y
	add SUM
	sta SUM
	lda SUM+1
	adc #$00
	sta SUM+1

; optimize OK (service.pas), line = 844

	lda RN+1
	cmp SUM+1
	bne @+
	lda RN
	cmp SUM
@
	jcs l_093D

; optimize OK (service.pas), line = 848

	lda LETTER
	sub #$01
	sta :STACKORIGIN+9
	lda LETTER+1
	sbc #$00
	cmp LETT.LAST+1
	bne @+
	lda :STACKORIGIN+9
	cmp LETT.LAST
@
	jeq l_092F

; optimize OK (service.pas), line = 850

	lda LETTER
	sub #$01
	sta RESULT
	lda LETTER+1
	sbc #$00
	sta RESULT+1
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$025E
RN	= DATAORIGIN+$0260
SUM	= DATAORIGIN+$0262
LETTER	= DATAORIGIN+$0264

@VarData	= RN
@VarDataSize	= 6

	rts						; ret
.endl

.local	PUT_LETTER					; PROCEDURE

; optimize OK (service.pas), line = 859

	lda #$00
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda LETT.TYP+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda LETT.TYP
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	rol :STACKORIGIN+STACKWIDTH*2+9
	asl @
	rol :STACKORIGIN+STACKWIDTH+9
	rol :STACKORIGIN+STACKWIDTH*2+9
	sta :STACKORIGIN+9
	lda :STACKORIGIN+STACKWIDTH+9
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :STACKORIGIN+9
	sta :STACKORIGIN+STACKWIDTH+9
	lda LETT.FRAME
	sta :STACKORIGIN+10
	lda #$00
	asl :STACKORIGIN+10
	rol @
	asl :STACKORIGIN+10
	rol @
	asl :STACKORIGIN+10
	rol @
	asl :STACKORIGIN+10
	rol @
	add :STACKORIGIN+STACKWIDTH+9
	sta FL+1
	lda :STACKORIGIN+10
	sta FL

; optimize OK (service.pas), line = 861

	lda #$00
	sta YL

l_098D
; --- ForToDoCondition
	lda YL
	cmp #$08
	jcs l_099B

; optimize OK (service.pas), line = 863

	sta :STACKORIGIN+9
	lda #$00
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	sta FW+1
	lda :STACKORIGIN+9
	sta FW

; optimize OK (service.pas), line = 865

	lda LETT.Y
	add YL
	tay
	lda LETT.X
	add adr.ROW,y
	sta BLITZERO.DST
	lda #$50
	adc adr.ROW+256,y
	sta BLITZERO.DST+1
	lda #$00
	adc #$00
	sta BLITZERO.DST+2
	lda #$00
	adc #$00
	sta BLITZERO.DST+3
	lda LETTERS.OFS
	add FW
	sta :STACKORIGIN+12
	lda LETTERS.OFS+1
	adc FW+1
	sta :STACKORIGIN+STACKWIDTH+12
	lda LETTERS.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+12
	lda LETTERS.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+12
	lda :STACKORIGIN+12
	add FL
	sta BLITZERO.SRC
	lda :STACKORIGIN+STACKWIDTH+12
	adc FL+1
	sta BLITZERO.SRC+1
	lda :STACKORIGIN+STACKWIDTH*2+12
	adc #$00
	sta BLITZERO.SRC+2
	lda :STACKORIGIN+STACKWIDTH*3+12
	adc #$00
	sta BLITZERO.SRC+3
	lda #$10
	sta BLITZERO.W
	lda #$00
	sta BLITZERO.W+1
	lda #$01
	sta BLITZERO.H
	jsr BLITZERO

; --- ForToDoEpilog
	inc YL
	jne l_098D
l_099B

; ------------------------------------------------------------

FL	= DATAORIGIN+$0266
FW	= DATAORIGIN+$0268
YL	= DATAORIGIN+$026A

@VarData	= FL
@VarDataSize	= 5

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_LETTER					; PROCEDURE

; optimize OK (service.pas), line = 877

	ldy LETT.Y
	lda LETT.X
	add adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 879

	lda LETT.Y
	cmp #$C8
	jcs l_09F1

; optimize OK (service.pas), line = 880

	lda HLP
	sta BLITBOX.DST
	lda #$50
	add HLP+1
	sta BLITBOX.DST+1
	lda #$00
	adc #$00
	sta BLITBOX.DST+2
	lda #$00
	adc #$00
	sta BLITBOX.DST+3
	lda PLAYSCREEN.OFS
	add HLP
	sta BLITBOX.SRC
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITBOX.SRC+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITBOX.SRC+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITBOX.SRC+3
	lda #$10
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda #$08
	sta BLITBOX.H
	jsr BLITBOX
l_09F1

; ------------------------------------------------------------

YL	= DATAORIGIN+$026B

@VarData	= YL
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DISABLE_LETTER					; PROCEDURE

; optimize FAIL ('REMOVE_LETTER', service.pas), line = 898

	jsr REMOVE_LETTER

; optimize OK (service.pas), line = 899

	lda #$00
	sta LETT.ACTIVE

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	START_LETTER					; PROCEDURE

; optimize OK (service.pas), line = 905

	lda LETT.ACTIVE
	jeq l_0A1C
	jsr DISABLE_LETTER
l_0A1C

; optimize OK (service.pas), line = 907

	lda XL
	sta LETT.X

; optimize OK (service.pas), line = 908

	lda YL
	sta LETT.Y

; optimize OK (service.pas), line = 909

	lda LETTER
	sta LETT.TYP
	lda LETTER+1
	sta LETT.TYP+1

; optimize OK (service.pas), line = 910

	lda #$00
	sta LETT.FRAME

; optimize OK (service.pas), line = 911

	sta LETT.SUBFRAME

; optimize OK (service.pas), line = 912

	lda #$01
	sta LETT.ACTIVE

; ------------------------------------------------------------

XL	= DATAORIGIN+$026C
YL	= DATAORIGIN+$026E
LETTER	= DATAORIGIN+$0270

@VarData	= XL
@VarDataSize	= 6

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CHECK_LETTER					; PROCEDURE

; optimize OK (service.pas), line = 918

	lda LETT.ACTIVE
	jeq l_0A4B

; optimize FAIL ('REMOVE_LETTER', service.pas), line = 920

	jsr REMOVE_LETTER

; optimize FAIL (0, service.pas), line = 921

	inc LETT.Y

; optimize OK (service.pas), line = 922

	lda LETT.Y
	cmp #$C8
	jcc l_0A63
; optimize FAIL ('DISABLE_LETTER', service.pas), line = 923
	jmp l_0A6E
l_0A63

; optimize FAIL ('PUT_LETTER', service.pas), line = 925

	jsr PUT_LETTER

; optimize FAIL (0, service.pas), line = 926

	inc LETT.SUBFRAME

; optimize OK (service.pas), line = 927

	lda LETT.SUBFRAME
	cmp #$05
	jne l_0A85

; optimize OK (service.pas), line = 929

	lda #$00
	sta LETT.SUBFRAME

; optimize FAIL (0, service.pas), line = 930

	inc LETT.FRAME
l_0A85

; optimize OK (service.pas), line = 933

	lda LETT.FRAME
	cmp #$08
	jne l_0AA2
	lda #$00
	sta LETT.FRAME
l_0AA2

; optimize OK (service.pas), line = 935

	lda LETT.X
	add #$10
	sta :STACKORIGIN+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	cmp :STACKORIGIN+STACKWIDTH+10
	bne @+
	lda VAUS.X
	cmp :STACKORIGIN+10
@
	jcs l_0AFB
@
	lda VAUS.X
	add VAUS.WIDTH
	sta :STACKORIGIN+10
	lda #$00
	adc #$00
	cmp #$00
	bne @+
	lda :STACKORIGIN+10
	cmp LETT.X
@
	jcc l_0AFB
	jeq l_0AFB
@
	lda LETT.Y
	add #$08
	sta :STACKORIGIN+11
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+11
	lda #$00
	cmp :STACKORIGIN+STACKWIDTH+11
	bne @+
	lda VAUS.Y
	cmp :STACKORIGIN+11
@
	jcs l_0AFB
@
	lda VAUS.Y
	add VAUS.HEIGHT
	sta :STACKORIGIN+10
	lda #$00
	adc #$00
	cmp #$00
	bne @+
	lda :STACKORIGIN+10
	cmp LETT.Y
@
	jcc l_0AFB
	jeq l_0AFB
@

; optimize OK (service.pas), line = 938

	lda #$64
	sta BALL_BLOCK_SOUND.A
	lda #$00
	sta BALL_BLOCK_SOUND.A+1
	lda #$0A
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND

; optimize OK (service.pas), line = 939

	ldy LETT.TYP
	iny
	sty VAUS.LETTER

; optimize OK (service.pas), line = 940

	lda CUR_PLAYER
	asl @
	asl @
	tay
	lda adr.SCORE.PLAYER,y
	add #$E8
	sta adr.SCORE.PLAYER,y
	lda adr.SCORE.PLAYER+1,y
	adc #$03
	sta adr.SCORE.PLAYER+1,y
	lda adr.SCORE.PLAYER+2,y
	adc #$00
	sta adr.SCORE.PLAYER+2,y
	lda adr.SCORE.PLAYER+3,y
	adc #$00
	sta adr.SCORE.PLAYER+3,y
l_0A6E

; optimize FAIL ('DISABLE_LETTER', service.pas), line = 941

	jsr DISABLE_LETTER
l_0AFB

; optimize OK (service.pas), line = 945

	lda #$00
	sta LETT.INCOMING
	sta LETT.INCOMING+1
	jmp l_0B1C
l_0A4B

; optimize OK (service.pas), line = 947

	lda LETT.INCOMING
	cmp #$E9
	lda LETT.INCOMING+1
	sbc #$03
	svc
	eor #$80
	jmi l_0B2D

; optimize OK (service.pas), line = 948

	lda LETT.NEXTX
	sta START_LETTER.XL
	lda LETT.NEXTX+1
	sta START_LETTER.XL+1
	lda LETT.NEXTY
	sta START_LETTER.YL
	lda LETT.NEXTY+1
	sta START_LETTER.YL+1
	lda LETT.NEXTTYPE
	sta START_LETTER.LETTER
	lda LETT.NEXTTYPE+1
	sta START_LETTER.LETTER+1
	jsr START_LETTER
l_0B1C
l_0B2D

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SHOWBTMPICTURE					; PROCEDURE

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta :bp2
	lda :STACKORIGIN+STACKWIDTH,x
	sta :bp2+1
	ldy #$07
	mva:rpl (:bp2),y adr.BTM,y-
	dex
@main

; optimize OK (service.pas), line = 958

	lda BTM.OFS
	sta BLITBOX.SRC
	lda BTM.OFS+1
	sta BLITBOX.SRC+1
	lda BTM.OFS+2
	sta BLITBOX.SRC+2
	lda BTM.OFS+3
	sta BLITBOX.SRC+3
	lda #$00
	sta BLITBOX.DST
	lda #$50
	sta BLITBOX.DST+1
	lda #$00
	sta BLITBOX.DST+2
	sta BLITBOX.DST+3
	lda BTM.WIDTH
	sta BLITBOX.W
	lda BTM.WIDTH+1
	sta BLITBOX.W+1
	lda BTM.HEIGHT
	sta BLITBOX.H
	jsr BLITBOX

; ------------------------------------------------------------

adr.BTM	= DATAORIGIN+$0272	; [8] RECORD
.var BTM	= adr.BTM .word
BTM.WIDTH	= DATAORIGIN+$0272
BTM.HEIGHT	= DATAORIGIN+$0274
BTM.OFS	= DATAORIGIN+$0276

@VarData	= BTM.WIDTH
@VarDataSize	= 8

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLACE_BALL					; PROCEDURE

; optimize OK (service.pas), line = 979

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sub #$03
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	sub #$03
	tay
	lda :STACKORIGIN+9
	add adr.ROW,y
	sta HLP
	lda :STACKORIGIN+STACKWIDTH+9
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 981

	lda HLP
	sta BLITZERO.DST
	lda #$50
	add HLP+1
	sta BLITZERO.DST+1
	lda #$00
	adc #$00
	sta BLITZERO.DST+2
	lda #$00
	adc #$00
	sta BLITZERO.DST+3
	lda BALLDATA.OFS
	sta BLITZERO.SRC
	lda BALLDATA.OFS+1
	sta BLITZERO.SRC+1
	lda BALLDATA.OFS+2
	sta BLITZERO.SRC+2
	lda BALLDATA.OFS+3
	sta BLITZERO.SRC+3
	lda #$05
	sta BLITZERO.W
	lda #$00
	sta BLITZERO.W+1
	lda #$05
	sta BLITZERO.H
	jsr BLITZERO

; ------------------------------------------------------------

BALL	= DATAORIGIN+$027A
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B

@VarData	= BALL
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_BALL					; PROCEDURE

; optimize OK (service.pas), line = 1008

	mwy BALL :bp2
	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	sub #$03
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	sub #$03
	tay
	lda :STACKORIGIN+9
	add adr.ROW,y
	sta HLP
	lda :STACKORIGIN+STACKWIDTH+9
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 1010

	lda HLP
	sta BLITBOX.DST
	lda #$50
	add HLP+1
	sta BLITBOX.DST+1
	lda #$00
	adc #$00
	sta BLITBOX.DST+2
	lda #$00
	adc #$00
	sta BLITBOX.DST+3
	lda PLAYSCREEN.OFS
	add HLP
	sta BLITBOX.SRC
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITBOX.SRC+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITBOX.SRC+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITBOX.SRC+3
	lda #$05
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda #$05
	sta BLITBOX.H
	jsr BLITBOX

; ------------------------------------------------------------

BALL	= DATAORIGIN+$027E
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B

@VarData	= BALL
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	WAIT_VBL					; PROCEDURE

; optimize FAIL ('SYSTEM.PAUSE.@00', service.pas), line = 1044

	jsr SYSTEM.PAUSE.@00

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SET_BALL					; PROCEDURE

; optimize OK (service.pas), line = 1056

	mwy BALL :bp2
	ldy #BALL.OLDX-DATAORIGIN+$01
	lda (:bp2),y
	cmp #$FF
	bne @+
	dey
	lda (:bp2),y
	cmp #$FF
@
	jeq l_0BADs
	ldy #BALL.OLDY-DATAORIGIN+$01
	lda (:bp2),y
	cmp #$FF
	bne @+
	dey
	lda (:bp2),y
	cmp #$FF
@
	jeq l_0BADs
	lda:sne #$01
l_0BADs	lda #$00
	sta B0

; optimize OK (service.pas), line = 1057

	mwy BALL :bp2
	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	ldy #BALL.X-DATAORIGIN+$01
	cmp (:bp2),y
	bne @+
	dey
	lda :STACKORIGIN+9
	cmp (:bp2),y
@
	bne @+
	jmp *+6
@\	jmp l_0BC5s
	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+10
	iny
	lda (:bp2),y
	ldy #BALL.Y-DATAORIGIN+$01
	cmp (:bp2),y
	bne @+
	dey
	lda :STACKORIGIN+10
	cmp (:bp2),y
@
	bne @+
	jmp *+6
@\	jmp l_0BC5s
	lda:seq #$00
l_0BC5s	lda #$01
	sta B1

; optimize OK (service.pas), line = 1059

	lda B0
	and B1
	jeq l_0BD7

; optimize OK (service.pas), line = 1060

	lda BALL
	sta REMOVE_BALL.BALL
	lda BALL+1
	sta REMOVE_BALL.BALL+1
	jsr REMOVE_BALL
l_0BD7

; optimize OK (service.pas), line = 1062

	lda BALL
	sta PLACE_BALL.BALL
	lda BALL+1
	sta PLACE_BALL.BALL+1
	jsr PLACE_BALL

; optimize OK (service.pas), line = 1064

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.OLDX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1065

	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.OLDY-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; ------------------------------------------------------------

BALL	= DATAORIGIN+$0282
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B
B0	= DATAORIGIN+$0286
B1	= DATAORIGIN+$0287

@VarData	= BALL
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SET_BALL_SPEED					; PROCEDURE

; optimize OK (service.pas), line = 1078

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda (:bp2),y
	sta SX
	iny
	lda (:bp2),y
	sta SX+1

; optimize OK (service.pas), line = 1079

	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta SY
	iny
	lda (:bp2),y
	sta SY+1

; optimize OK (service.pas), line = 1081

	lda SX
	sta SYSTEM.ABS.@010184000.X
	lda SX+1
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	lda SYSTEM.ABS.@010184000.RESULT
	sta A
	lda SYSTEM.ABS.@010184000.RESULT+1
	sta A+1

; optimize OK (service.pas), line = 1082

	lda SY
	sta SYSTEM.ABS.@010184000.X
	lda SY+1
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	lda SYSTEM.ABS.@010184000.RESULT
	sta B
	lda SYSTEM.ABS.@010184000.RESULT+1
	sta B+1

; optimize OK (service.pas), line = 1084

	lda A
	sta :ecx
	sta :eax
	lda A+1
	sta :ecx+1
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	sta :STACKORIGIN+9
	lda :eax+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda :eax+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :eax+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda B
	sta :ecx
	sta :eax
	lda B+1
	sta :ecx+1
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :STACKORIGIN+9
	add :eax
	sta I
	lda :STACKORIGIN+STACKWIDTH+9
	adc :eax+1
	sta I+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc :eax+2
	sta I+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc :eax+3
	sta I+3

; optimize OK (service.pas), line = 1086

	lda I
	sta SQRT32.V
	lda I+1
	sta SQRT32.V+1
	lda I+2
	sta SQRT32.V+2
	lda I+3
	sta SQRT32.V+3
	jsr SQRT32
	lda SQRT32.RESULT
	sta HLP
	lda SQRT32.RESULT+1
	sta HLP+1

; optimize OK (service.pas), line = 1088

	lda HLP
	sta :FPMAN0
	lda HLP+1
	sta :FPMAN1
	lda #$00
	sta :FPMAN2
	sta :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta :STACKORIGIN+10
	lda :FPMAN1
	sta :STACKORIGIN+STACKWIDTH+10
	lda :FPMAN2
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda :FPMAN3
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda SPEED
	sta :FPMAN0
	ldy #$00
	lda SPEED+1
	spl
	dey
	sta :FPMAN1
	sty :FPMAN2
	sty :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda :STACKORIGIN+10
	sta :FP2MAN0
	lda :STACKORIGIN+STACKWIDTH+10
	sta :FP2MAN1
	lda :STACKORIGIN+STACKWIDTH*2+10
	sta :FP2MAN2
	lda :STACKORIGIN+STACKWIDTH*3+10
	sta :FP2MAN3
	jsr @FDIV
	lda :FPMAN0
	sta VM
	lda :FPMAN1
	sta VM+1
	lda :FPMAN2
	sta VM+2
	lda :FPMAN3
	sta VM+3

; optimize OK (service.pas), line = 1093

	lda SX
	sta :FPMAN0
	ldy #$00
	lda SX+1
	spl
	dey
	sta :FPMAN1
	sty :FPMAN2
	sty :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda VM
	sta :FP2MAN0
	lda VM+1
	sta :FP2MAN1
	lda VM+2
	sta :FP2MAN2
	lda VM+3
	sta :FP2MAN3
	jsr @FMUL
	jsr @F2I
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :FPMAN0
	sta (:bp2),y
	iny
	lda :FPMAN1
	sta (:bp2),y

; optimize OK (service.pas), line = 1094

	lda SY
	sta :FPMAN0
	ldy #$00
	lda SY+1
	spl
	dey
	sta :FPMAN1
	sty :FPMAN2
	sty :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda VM
	sta :FP2MAN0
	lda VM+1
	sta :FP2MAN1
	lda VM+2
	sta :FP2MAN2
	lda VM+3
	sta :FP2MAN3
	jsr @FMUL
	jsr @F2I
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda :FPMAN0
	sta (:bp2),y
	iny
	lda :FPMAN1
	sta (:bp2),y

; ------------------------------------------------------------

BALL	= DATAORIGIN+$0288
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B
SPEED	= DATAORIGIN+$028C
SX	= DATAORIGIN+$028E
SY	= DATAORIGIN+$0290
VM	= DATAORIGIN+$0292
I	= DATAORIGIN+$0296
A	= DATAORIGIN+$029A
B	= DATAORIGIN+$029C

@VarData	= BALL
@VarDataSize	= 20

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SET_BALL_DIRECTION				; PROCEDURE

; optimize OK (service.pas), line = 1102

	lda ANGLE
	sta :FPMAN0
	ldy #$00
	lda ANGLE+1
	spl
	dey
	sta :FPMAN1
	sty :FPMAN2
	sty :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda #$35
	sta :FP2MAN0
	lda #$FA
	sta :FP2MAN1
	lda #$8E
	sta :FP2MAN2
	lda #$3C
	sta :FP2MAN3
	jsr @FMUL
	lda :FPMAN0
	sta W
	lda :FPMAN1
	sta W+1
	lda :FPMAN2
	sta W+2
	lda :FPMAN3
	sta W+3

; optimize FAIL (1, service.pas), line = 1104

	inx
	mva #$00 :STACKORIGIN,x
	mva #$01 :STACKORIGIN+STACKWIDTH,x
	lda W
	sta SYSTEM.COS.@01018F000.X
	lda W+1
	sta SYSTEM.COS.@01018F000.X+1
	lda W+2
	sta SYSTEM.COS.@01018F000.X+2
	lda W+3
	sta SYSTEM.COS.@01018F000.X+3
	jsr SYSTEM.COS.@01018F000
	inx
	mva SYSTEM.COS.@01018F000.RESULT :STACKORIGIN,x
	mva SYSTEM.COS.@01018F000.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	mva SYSTEM.COS.@01018F000.RESULT+2 :STACKORIGIN+STACKWIDTH*2,x
	mva SYSTEM.COS.@01018F000.RESULT+3 :STACKORIGIN+STACKWIDTH*3,x
	mva #$00 :STACKORIGIN-1+STACKWIDTH*2,x
	sta :STACKORIGIN-1+STACKWIDTH*3,x
	lda :STACKORIGIN-1,x
	sta :FPMAN0
	lda :STACKORIGIN-1+STACKWIDTH,x
	sta :FPMAN1
	lda :STACKORIGIN-1+STACKWIDTH*2,x
	sta :FPMAN2
	lda :STACKORIGIN-1+STACKWIDTH*3,x
	sta :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta :STACKORIGIN-1,x
	lda :FPMAN1
	sta :STACKORIGIN-1+STACKWIDTH,x
	lda :FPMAN2
	sta :STACKORIGIN-1+STACKWIDTH*2,x
	lda :FPMAN3
	sta :STACKORIGIN-1+STACKWIDTH*3,x
	lda :STACKORIGIN,x
	sta :FP2MAN0
	lda :STACKORIGIN+STACKWIDTH,x
	sta :FP2MAN1
	lda :STACKORIGIN+STACKWIDTH*2,x
	sta :FP2MAN2
	lda :STACKORIGIN+STACKWIDTH*3,x
	sta :FP2MAN3
	lda :STACKORIGIN-1,x
	sta :FP1MAN0
	lda :STACKORIGIN-1+STACKWIDTH,x
	sta :FP1MAN1
	lda :STACKORIGIN-1+STACKWIDTH*2,x
	sta :FP1MAN2
	lda :STACKORIGIN-1+STACKWIDTH*3,x
	sta :FP1MAN3
	jsr @FMUL
	dex
	lda :FPMAN0
	sta :FPMAN0
	lda :FPMAN1
	sta :FPMAN1
	lda :FPMAN2
	sta :FPMAN2
	lda :FPMAN3
	sta :FPMAN3
	jsr @F2I
	lda :FPMAN0
	sta :STACKORIGIN,x
	lda :FPMAN1
	sta :STACKORIGIN+STACKWIDTH,x
	lda :FPMAN2
	sta :STACKORIGIN+STACKWIDTH*2,x
	lda :FPMAN3
	sta :STACKORIGIN+STACKWIDTH*3,x
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :STACKORIGIN,x
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH,x
	sta (:bp2),y

; optimize FAIL (1, service.pas), line = 1105

	mva #$00 :STACKORIGIN,x
	mva #$01 :STACKORIGIN+STACKWIDTH,x
	lda W
	sta SYSTEM.SIN.@01018F000.X
	lda W+1
	sta SYSTEM.SIN.@01018F000.X+1
	lda W+2
	sta SYSTEM.SIN.@01018F000.X+2
	lda W+3
	sta SYSTEM.SIN.@01018F000.X+3
	jsr SYSTEM.SIN.@01018F000
	inx
	mva SYSTEM.SIN.@01018F000.RESULT :STACKORIGIN,x
	mva SYSTEM.SIN.@01018F000.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	mva SYSTEM.SIN.@01018F000.RESULT+2 :STACKORIGIN+STACKWIDTH*2,x
	mva SYSTEM.SIN.@01018F000.RESULT+3 :STACKORIGIN+STACKWIDTH*3,x
	mva #$00 :STACKORIGIN-1+STACKWIDTH*2,x
	sta :STACKORIGIN-1+STACKWIDTH*3,x
	lda :STACKORIGIN-1,x
	sta :FPMAN0
	lda :STACKORIGIN-1+STACKWIDTH,x
	sta :FPMAN1
	lda :STACKORIGIN-1+STACKWIDTH*2,x
	sta :FPMAN2
	lda :STACKORIGIN-1+STACKWIDTH*3,x
	sta :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta :STACKORIGIN-1,x
	lda :FPMAN1
	sta :STACKORIGIN-1+STACKWIDTH,x
	lda :FPMAN2
	sta :STACKORIGIN-1+STACKWIDTH*2,x
	lda :FPMAN3
	sta :STACKORIGIN-1+STACKWIDTH*3,x
	lda :STACKORIGIN,x
	sta :FP2MAN0
	lda :STACKORIGIN+STACKWIDTH,x
	sta :FP2MAN1
	lda :STACKORIGIN+STACKWIDTH*2,x
	sta :FP2MAN2
	lda :STACKORIGIN+STACKWIDTH*3,x
	sta :FP2MAN3
	lda :STACKORIGIN-1,x
	sta :FP1MAN0
	lda :STACKORIGIN-1+STACKWIDTH,x
	sta :FP1MAN1
	lda :STACKORIGIN-1+STACKWIDTH*2,x
	sta :FP1MAN2
	lda :STACKORIGIN-1+STACKWIDTH*3,x
	sta :FP1MAN3
	jsr @FMUL
	dex
	lda :FPMAN0
	sta :FPMAN0
	lda :FPMAN1
	sta :FPMAN1
	lda :FPMAN2
	sta :FPMAN2
	lda :FPMAN3
	sta :FPMAN3
	jsr @F2I
	lda :FPMAN0
	sta :STACKORIGIN,x
	lda :FPMAN1
	sta :STACKORIGIN+STACKWIDTH,x
	lda :FPMAN2
	sta :STACKORIGIN+STACKWIDTH*2,x
	lda :FPMAN3
	sta :STACKORIGIN+STACKWIDTH*3,x
	lda #$00
	sub :STACKORIGIN,x
	sta :STACKORIGIN,x
	lda #$00
	sbc :STACKORIGIN+STACKWIDTH,x
	sta :STACKORIGIN+STACKWIDTH,x
	lda #$00
	sbc :STACKORIGIN+STACKWIDTH*2,x
	sta :STACKORIGIN+STACKWIDTH*2,x
	lda #$00
	sbc :STACKORIGIN+STACKWIDTH*3,x
	sta :STACKORIGIN+STACKWIDTH*3,x
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda :STACKORIGIN,x
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH,x
	sta (:bp2),y
	dex

; ------------------------------------------------------------

BALL	= DATAORIGIN+$029E
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B
ANGLE	= DATAORIGIN+$02A2
W	= DATAORIGIN+$02A4

@VarData	= BALL
@VarDataSize	= 8

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	GET_BALL_DIRECTION				; FUNCTION

; optimize OK (service.pas), line = 1113

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN+$01
	lda (:bp2),y
	dey
	ora (:bp2),y
	jne l_0C70
	inx
	mva #$5A :STACKORIGIN,x
	inx
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	mva (:bp2),y :STACKORIGIN,x
	iny
	mva (:bp2),y :STACKORIGIN+STACKWIDTH,x
	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta SYSTEM.ABS.@010184000.X
	iny
	lda (:bp2),y
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	inx
	lda SYSTEM.ABS.@010184000.RESULT
	sta @SMALLINT.DIV.B
	lda SYSTEM.ABS.@010184000.RESULT+1
	sta @SMALLINT.DIV.B+1
	lda :STACKORIGIN-1,x
	sta @SMALLINT.DIV.A
	lda :STACKORIGIN-1+STACKWIDTH,x
	sta @SMALLINT.DIV.A+1
	jsr @SMALLINT.DIV
	lda :eax
	sta :STACKORIGIN-1,x
	lda :eax+1
	sta :STACKORIGIN-1+STACKWIDTH,x
	dex
	mva #$00 :STACKORIGIN-1+STACKWIDTH,x
	jsr mulSMALLINT
	dex
	lda #$00
	sub :STACKORIGIN,x
	sta :STACKORIGIN,x
	lda #$00
	sbc :STACKORIGIN+STACKWIDTH,x
	sta :STACKORIGIN+STACKWIDTH,x
	lda #$00
	sbc :STACKORIGIN+STACKWIDTH*2,x
	sta :STACKORIGIN+STACKWIDTH*2,x
	lda #$00
	sbc :STACKORIGIN+STACKWIDTH*3,x
	sta :STACKORIGIN+STACKWIDTH*3,x
	lda :STACKORIGIN,x
	sta W
	lda :STACKORIGIN+STACKWIDTH,x
	sta W+1
	dex
	jmp l_0C8C
l_0C70

; optimize OK (service.pas), line = 1119

	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDX-DATAORIGIN
	lda (:bp2),y
	sta :FPMAN0
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+10
	spl
	dey
	sta :FPMAN1
	sty :FPMAN2
	sty :FPMAN3
	jsr @I2F
	lda :FPMAN0
	sta :STACKORIGIN+10
	lda :FPMAN1
	sta :STACKORIGIN+STACKWIDTH+10
	lda :FPMAN2
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda :FPMAN3
	sta :STACKORIGIN+STACKWIDTH*3+10
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+9
	spl
	dey
	sta :FPMAN1
	sty :FPMAN2
	sty :FPMAN3
	lda :STACKORIGIN+9
	sta :FPMAN0
	jsr @I2F
	lda :FPMAN0
	sta :FP1MAN0
	lda :FPMAN1
	sta :FP1MAN1
	lda :FPMAN2
	sta :FP1MAN2
	lda :FPMAN3
	sta :FP1MAN3
	lda :STACKORIGIN+10
	sta :FP2MAN0
	lda :STACKORIGIN+STACKWIDTH+10
	sta :FP2MAN1
	lda :STACKORIGIN+STACKWIDTH*2+10
	sta :FP2MAN2
	lda :STACKORIGIN+STACKWIDTH*3+10
	sta :FP2MAN3
	jsr @FDIV
	lda :FPMAN0
	sta F_HLP
	lda :FPMAN1
	sta F_HLP+1
	lda :FPMAN2
	sta F_HLP+2
	lda :FPMAN3
	eor #$80
	sta F_HLP+3

; optimize OK (service.pas), line = 1121

	lda F_HLP
	sta SYSTEM.ARCTAN.@01018F000.VALUE
	lda F_HLP+1
	sta SYSTEM.ARCTAN.@01018F000.VALUE+1
	lda F_HLP+2
	sta SYSTEM.ARCTAN.@01018F000.VALUE+2
	lda F_HLP+3
	sta SYSTEM.ARCTAN.@01018F000.VALUE+3
	jsr SYSTEM.ARCTAN.@01018F000
	inx
	inx
	lda #$00
	sta :FP2MAN0
	lda #$00
	sta :FP2MAN1
	lda #$34
	sta :FP2MAN2
	lda #$43
	sta :FP2MAN3
	lda SYSTEM.ARCTAN.@01018F000.RESULT
	sta :FP1MAN0
	lda SYSTEM.ARCTAN.@01018F000.RESULT+1
	sta :FP1MAN1
	lda SYSTEM.ARCTAN.@01018F000.RESULT+2
	sta :FP1MAN2
	lda SYSTEM.ARCTAN.@01018F000.RESULT+3
	sta :FP1MAN3
	jsr @FMUL
	lda :FPMAN0
	sta :STACKORIGIN-1,x
	lda :FPMAN1
	sta :STACKORIGIN-1+STACKWIDTH,x
	lda :FPMAN2
	sta :STACKORIGIN-1+STACKWIDTH*2,x
	lda :FPMAN3
	sta :STACKORIGIN-1+STACKWIDTH*3,x
	lda #$DB
	sta :FP2MAN0
	lda #$0F
	sta :FP2MAN1
	lda #$49
	sta :FP2MAN2
	lda #$40
	sta :FP2MAN3
	lda :STACKORIGIN-1,x
	sta :FP1MAN0
	lda :STACKORIGIN-1+STACKWIDTH,x
	sta :FP1MAN1
	lda :STACKORIGIN-1+STACKWIDTH*2,x
	sta :FP1MAN2
	lda :STACKORIGIN-1+STACKWIDTH*3,x
	sta :FP1MAN3
	jsr @FDIV
	dex
	lda :FPMAN0
	sta F_HLP
	lda :FPMAN1
	sta F_HLP+1
	lda :FPMAN2
	sta F_HLP+2
	lda :FPMAN3
	sta F_HLP+3
	dex

; optimize OK (service.pas), line = 1123

	lda F_HLP
	sta :FPMAN0
	lda F_HLP+1
	sta :FPMAN1
	lda F_HLP+2
	sta :FPMAN2
	lda F_HLP+3
	sta :FPMAN3
	jsr @F2I
	lda :FPMAN0
	sta W
	lda :FPMAN1
	sta W+1

; optimize OK (service.pas), line = 1125

	mwy BALL :bp2
	ldy #$00
	lda (:bp2),y
	jpl l_0CBB
	lda W
	add #$B4
	sta W
	scc
	inc W+1
l_0CBB

; optimize OK (service.pas), line = 1127

	lda W
	add #$68
	sta W
	lda W+1
	adc #$01
	sta W+1

; optimize OK (service.pas), line = 1128

	lda #$68
	sta @SMALLINT.MOD.B
	lda #$01
	sta @SMALLINT.MOD.B+1
	lda W
	sta @SMALLINT.MOD.A
	lda W+1
	sta @SMALLINT.MOD.A+1
	jsr @SMALLINT.MOD
	lda @SMALLINT.MOD.RESULT
	sta W
	lda @SMALLINT.MOD.RESULT+1
	sta W+1
l_0C8C

; optimize OK (service.pas), line = 1131

	lda W
	sta RESULT
	lda W+1
	sta RESULT+1
@exit

; ------------------------------------------------------------

BALL	= DATAORIGIN+$02A8
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B
RESULT	= DATAORIGIN+$02AC
W	= DATAORIGIN+$02AE

@VarData	= BALL
@VarDataSize	= 4

	rts						; ret
.endl

.local	START_BALL					; PROCEDURE

; optimize OK (service.pas), line = 1140

	mwy BALL :bp2
	ldy #BALL.ONVAUS-DATAORIGIN
	lda VAUS.X
	add (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	adc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.X-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1146

	ldy #BALL.Y-DATAORIGIN
	lda VAUS.Y
	sub #$03
	sta (:bp2),y
	iny
	lda #$00
	sbc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1151

	ldy #BALL.FINEX-DATAORIGIN
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (service.pas), line = 1152

	ldy #BALL.FINEY-DATAORIGIN
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (service.pas), line = 1154

	ldy #BALL.INPLAY-DATAORIGIN
	lda #$01
	sta (:bp2),y

; optimize OK (service.pas), line = 1156

	ldy #BALL.SBD-DATAORIGIN
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (service.pas), line = 1157

	ldy #BALL.BRWHIT-DATAORIGIN
	sta (:bp2),y

; ------------------------------------------------------------

BALL	= DATAORIGIN+$02B0
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B

@VarData	= BALL
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BALL_SPEED					; FUNCTION

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta :bp2
	lda :STACKORIGIN+STACKWIDTH,x
	sta :bp2+1
	ldy #$1B
	mva:rpl (:bp2),y adr.BALL,y-
	dex
@main

; optimize OK (service.pas), line = 1168

	lda BALL.SPEEDX
	sta SYSTEM.ABS.@010184000.X
	lda BALL.SPEEDX+1
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	lda SYSTEM.ABS.@010184000.RESULT
	sta A
	lda SYSTEM.ABS.@010184000.RESULT+1
	sta A+1

; optimize OK (service.pas), line = 1169

	lda BALL.SPEEDY
	sta SYSTEM.ABS.@010184000.X
	lda BALL.SPEEDY+1
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	lda SYSTEM.ABS.@010184000.RESULT
	sta B
	lda SYSTEM.ABS.@010184000.RESULT+1
	sta B+1

; optimize OK (service.pas), line = 1171

	lda A
	sta :ecx
	sta :eax
	lda A+1
	sta :ecx+1
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	sta :STACKORIGIN+9
	lda :eax+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda :eax+2
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :eax+3
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda B
	sta :ecx
	sta :eax
	lda B+1
	sta :ecx+1
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :STACKORIGIN+9
	add :eax
	sta I
	lda :STACKORIGIN+STACKWIDTH+9
	adc :eax+1
	sta I+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc :eax+2
	sta I+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc :eax+3
	sta I+3

; optimize OK (service.pas), line = 1173

	lda I
	sta SQRT32.V
	lda I+1
	sta SQRT32.V+1
	lda I+2
	sta SQRT32.V+2
	lda I+3
	sta SQRT32.V+3
	jsr SQRT32
	lda SQRT32.RESULT
	sta RESULT
	lda SQRT32.RESULT+1
	sta RESULT+1
@exit

; ------------------------------------------------------------

adr.BALL	= DATAORIGIN+$02B4	; [28] RECORD
.var BALL	= adr.BALL .word
BALL.X	= DATAORIGIN+$02B4
BALL.Y	= DATAORIGIN+$02B6
BALL.FINEX	= DATAORIGIN+$02B8
BALL.FINEY	= DATAORIGIN+$02BA
BALL.OLDX	= DATAORIGIN+$02BC
BALL.OLDY	= DATAORIGIN+$02BE
BALL.SPEED	= DATAORIGIN+$02C0
BALL.FINESPEED	= DATAORIGIN+$02C2
BALL.SPEEDX	= DATAORIGIN+$02C4
BALL.SPEEDY	= DATAORIGIN+$02C6
BALL.SBD	= DATAORIGIN+$02C8
BALL.BRWHIT	= DATAORIGIN+$02CA
BALL.INPLAY	= DATAORIGIN+$02CB
BALL.LAUNCH	= DATAORIGIN+$02CC
BALL.ONVAUS	= DATAORIGIN+$02CD
BALL.STM	= DATAORIGIN+$02CF
RESULT	= DATAORIGIN+$02D0
I	= DATAORIGIN+$02D2
A	= DATAORIGIN+$02D6
B	= DATAORIGIN+$02D8

@VarData	= BALL.X
@VarDataSize	= 36

	rts						; ret
.endl

.local	MOVE_BALL					; PROCEDURE

; optimize OK (service.pas), line = 1191

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	iny
	sta :STACKORIGIN+STACKWIDTH+9
	lda #$00
	ldy #BALL.FINEX-DATAORIGIN
	add (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	adc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :STACKORIGIN+9
	add (:bp2),y
	sta X
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	adc (:bp2),y
	sta X+1

; optimize OK (service.pas), line = 1192

	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	iny
	sta :STACKORIGIN+STACKWIDTH+9
	lda #$00
	ldy #BALL.FINEY-DATAORIGIN
	add (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	adc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDY-DATAORIGIN
	lda :STACKORIGIN+9
	add (:bp2),y
	sta Y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	adc (:bp2),y
	sta Y+1

; optimize OK (service.pas), line = 1194

	ldy #BALL.X-DATAORIGIN
	lda X+1
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1195

	ldy #BALL.Y-DATAORIGIN
	lda Y+1
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1197

	ldy #BALL.FINEX-DATAORIGIN
	lda X
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1198

	ldy #BALL.FINEY-DATAORIGIN
	lda Y
	sta (:bp2),y
	iny
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1203

	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	iny
	cmp #$D9
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jmi l_0D86

; optimize OK (service.pas), line = 1205

	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1206

	ldy #BALL.X-DATAORIGIN
	lda #$B0
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$01
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.X-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1207

	ldy #BALL.FINEX-DATAORIGIN
	lda #$FF
	eor (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.FINEX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1208

	lda #$F0
	sta BALL_BLOCK_SOUND.A
	lda #$00
	sta BALL_BLOCK_SOUND.A+1
	lda #$05
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND
l_0D86

; optimize OK (service.pas), line = 1213

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	iny
	cmp #$0A
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jpl l_0DBB

; optimize OK (service.pas), line = 1215

	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1216

	ldy #BALL.X-DATAORIGIN
	lda #$14
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.X-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1217

	ldy #BALL.FINEX-DATAORIGIN
	lda #$FF
	eor (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.FINEX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1218

	lda #$F0
	sta BALL_BLOCK_SOUND.A
	lda #$00
	sta BALL_BLOCK_SOUND.A+1
	lda #$05
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND
l_0DBB

; optimize OK (service.pas), line = 1223

	mwy BALL :bp2
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	iny
	cmp #$0C
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jpl l_0DF0

; optimize OK (service.pas), line = 1225

	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDY-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1226

	ldy #BALL.Y-DATAORIGIN
	lda #$18
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.Y-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1227

	ldy #BALL.FINEY-DATAORIGIN
	lda #$FF
	eor (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.FINEY-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1228

	lda #$F0
	sta BALL_BLOCK_SOUND.A
	lda #$00
	sta BALL_BLOCK_SOUND.A+1
	lda #$05
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND
l_0DF0

; optimize OK (service.pas), line = 1236

	mwy BALL :bp2
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	add #$03
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #1
	lda :STACKORIGIN+9
	cmp #$B9
	lda :STACKORIGIN+STACKWIDTH+9
	sbc #$00
	svc
	eor #$80
	bpl @+
	dey
@
	tya
	sta B0

; optimize OK (service.pas), line = 1237

	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #1
	lda :STACKORIGIN+STACKWIDTH+9
	bmi @+
	ora :STACKORIGIN+9
	sne
@
	dey
@
	tya
	sta B1

; optimize OK (service.pas), line = 1238

	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #1
	lda :STACKORIGIN+9
	cmp #$B9
	lda :STACKORIGIN+STACKWIDTH+9
	sbc #$00
	svc
	eor #$80
	bmi @+
	dey
@
	tya
	sta B2

; optimize OK (service.pas), line = 1241

	lda B0
	and B1
	and B2
	jeq l_0E51

; optimize OK (service.pas), line = 1245

	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda VAUS.X
	sub #$03
	sta :STACKORIGIN+10
	lda #$00
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda :STACKORIGIN+10
	cmp :STACKORIGIN+9
	lda :STACKORIGIN+STACKWIDTH+10
	sbc (:bp2),y
	svc
	eor #$80
	jpl l_0E80
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+10
	iny
	lda VAUS.X
	add VAUS.WIDTH
	sta :STACKORIGIN+11
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+11
	lda :STACKORIGIN+11
	add #$03
	sta :STACKORIGIN+11
	lda :STACKORIGIN+STACKWIDTH+11
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+11
	lda :STACKORIGIN+10
	cmp :STACKORIGIN+11
	lda (:bp2),y
	sbc :STACKORIGIN+STACKWIDTH+11
	svc
	eor #$80
	jpl l_0E80

; optimize OK (service.pas), line = 1248

	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDY-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1250

	lda VAUS.LETTER
	cmp #$06
	jne l_0EA4
	ldy #BALL.LAUNCH-DATAORIGIN
	lda (:bp2),y
	jne l_0EA4

; optimize OK (service.pas), line = 1252

	ldy #BALL.STM-DATAORIGIN
	sta (:bp2),y

; optimize OK (service.pas), line = 1253

	ldy #BALL.LAUNCH-DATAORIGIN
	lda #$01
	sta (:bp2),y

; optimize OK (service.pas), line = 1254

	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sub VAUS.X
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.ONVAUS-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y
l_0EA4

; optimize OK (service.pas), line = 1257

	lda #$2C
	sta BALL_BLOCK_SOUND.A
	lda #$01
	sta BALL_BLOCK_SOUND.A+1
	lda #$06
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND

; optimize OK (service.pas), line = 1261

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda VAUS.X
	add #$0A
	sta :STACKORIGIN+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda :STACKORIGIN+9
	cmp :STACKORIGIN+10
	lda (:bp2),y
	sbc :STACKORIGIN+STACKWIDTH+10
	svc
	eor #$80
	jpl l_0ED4

; optimize OK (service.pas), line = 1264

	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1268

	lda BALL
	sta GET_BALL_DIRECTION.BALL
	lda BALL+1
	sta GET_BALL_DIRECTION.BALL+1
	jsr GET_BALL_DIRECTION
	inx
	mva GET_BALL_DIRECTION.RESULT :STACKORIGIN,x
	mva GET_BALL_DIRECTION.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	lda #$1E
	jsr SYSTEM.RANDOM.@010180000
	lda :STACKORIGIN,x
	add SYSTEM.RANDOM.@010180000.RESULT
	sta ANGLE
	lda :STACKORIGIN+STACKWIDTH,x
	adc #$00
	sta ANGLE+1
	dex

; optimize OK (service.pas), line = 1276

	lda #$A0
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda ANGLE
	sta MIN.B
	lda ANGLE+1
	sta MIN.B+1
	jsr MIN
	lda #$78
	sta MAX.A
	lda #$00
	sta MAX.A+1
	lda MIN.RESULT
	sta MAX.B
	lda MIN.RESULT+1
	sta MAX.B+1
	jsr MAX
	lda BALL
	sta SET_BALL_DIRECTION.BALL
	lda BALL+1
	sta SET_BALL_DIRECTION.BALL+1
	lda MAX.RESULT
	sta SET_BALL_DIRECTION.ANGLE
	lda MAX.RESULT+1
	sta SET_BALL_DIRECTION.ANGLE+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 1281

	mwy BALL :bp2
	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED
	iny
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED+1
	lda BALL
	sta SET_BALL_SPEED.BALL
	lda BALL+1
	sta SET_BALL_SPEED.BALL+1
	jsr SET_BALL_SPEED
l_0ED4

; optimize OK (service.pas), line = 1287

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda VAUS.X
	add VAUS.WIDTH
	sta :STACKORIGIN+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda :STACKORIGIN+10
	sub #$0A
	sta :STACKORIGIN+10
	lda :STACKORIGIN+STACKWIDTH+10
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda :STACKORIGIN+10
	cmp :STACKORIGIN+9
	lda :STACKORIGIN+STACKWIDTH+10
	sbc (:bp2),y
	svc
	eor #$80
	jpl l_0F15

; optimize OK (service.pas), line = 1289

	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 1290

	lda BALL
	sta GET_BALL_DIRECTION.BALL
	lda BALL+1
	sta GET_BALL_DIRECTION.BALL+1
	jsr GET_BALL_DIRECTION
	inx
	mva GET_BALL_DIRECTION.RESULT :STACKORIGIN,x
	mva GET_BALL_DIRECTION.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	lda #$1E
	jsr SYSTEM.RANDOM.@010180000
	lda :STACKORIGIN,x
	sub SYSTEM.RANDOM.@010180000.RESULT
	sta ANGLE
	lda :STACKORIGIN+STACKWIDTH,x
	sbc #$00
	sta ANGLE+1
	dex

; optimize OK (service.pas), line = 1291

	lda #$14
	sta MAX.A
	lda #$00
	sta MAX.A+1
	lda ANGLE
	sta MAX.B
	lda ANGLE+1
	sta MAX.B+1
	jsr MAX
	lda #$3C
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda MAX.RESULT
	sta MIN.B
	lda MAX.RESULT+1
	sta MIN.B+1
	jsr MIN
	lda BALL
	sta SET_BALL_DIRECTION.BALL
	lda BALL+1
	sta SET_BALL_DIRECTION.BALL+1
	lda MIN.RESULT
	sta SET_BALL_DIRECTION.ANGLE
	lda MIN.RESULT+1
	sta SET_BALL_DIRECTION.ANGLE+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 1292

	mwy BALL :bp2
	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED
	iny
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED+1
	lda BALL
	sta SET_BALL_SPEED.BALL
	lda BALL+1
	sta SET_BALL_SPEED.BALL+1
	jsr SET_BALL_SPEED
l_0F15
l_0E80
l_0E51

; optimize OK (service.pas), line = 1304

	mwy BALL :bp2
	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #1
	lda :STACKORIGIN+9
	cmp #$B9
	lda :STACKORIGIN+STACKWIDTH+9
	sbc #$00
	svc
	eor #$80
	bpl @+
	dey
@
	sty :STACKORIGIN+9
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+10
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #1
	lda :STACKORIGIN+10
	cmp #$C9
	lda :STACKORIGIN+STACKWIDTH+10
	sbc #$00
	svc
	eor #$80
	bpl @+
	dey
@
	tya
	and :STACKORIGIN+9
	sta :STACKORIGIN+9
	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+10
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #1
	lda :STACKORIGIN+STACKWIDTH+10
	bmi @+
	ora :STACKORIGIN+10
	sne
@
	dey
@
	tya
	and :STACKORIGIN+9
	jeq l_0F64

; optimize OK (service.pas), line = 1306

	ldy #BALL.INPLAY-DATAORIGIN
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1308

	lda BALL
	sta REMOVE_BALL.BALL
	lda BALL+1
	sta REMOVE_BALL.BALL+1
	jsr REMOVE_BALL
l_0F64

; ------------------------------------------------------------

BALL	= DATAORIGIN+$02DA
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B
B0	= DATAORIGIN+$02DE
B1	= DATAORIGIN+$02DF
B2	= DATAORIGIN+$02E0
X	= DATAORIGIN+$02E1
Y	= DATAORIGIN+$02E3
ANGLE	= DATAORIGIN+$02E5

@VarData	= BALL
@VarDataSize	= 11

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MODIFY_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 1315

	lda VAUS.WIDTH
	sta VAUS.OLDLEN
	lda #$00
	sta VAUS.OLDLEN+1

; optimize OK (service.pas), line = 1316

	lda PLAYVAUS.WIDTH
	sta VAUS.WIDTH

; optimize OK (service.pas), line = 1317

	lda PLAYVAUS.HEIGHT
	sta VAUS.HEIGHT

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SET_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 1322

	lda #$5F
	sta VAUS.X

; optimize OK (service.pas), line = 1323

	lda #$B8
	sta VAUS.Y

; optimize OK (service.pas), line = 1325

	lda #$FF
	sta VAUS.OLDX
	sta VAUS.OLDX+1

; optimize OK (service.pas), line = 1326

	sta VAUS.OLDY
	sta VAUS.OLDY+1

; optimize OK (service.pas), line = 1327

	lda #$00
	sta VAUS.IFLASH

; optimize OK (service.pas), line = 1331

	sta VAUS.FLASH

; optimize OK (service.pas), line = 1335

	lda PLAYVAUS.WIDTH
	sta VAUS.WIDTH

; optimize OK (service.pas), line = 1336

	lda PLAYVAUS.HEIGHT
	sta VAUS.HEIGHT

; optimize OK (service.pas), line = 1337

	lda VAUS.WIDTH
	sta VAUS.OLDLEN
	lda #$00
	sta VAUS.OLDLEN+1

; optimize OK (service.pas), line = 1338

	lda #$FF
	sta VAUS.LETTER

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	START_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 1347

	lda #$5F
	sta VAUS.X

; optimize OK (service.pas), line = 1348

	lda #$B8
	sta VAUS.Y

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 1362

	ldy VAUS.OLDY
	lda VAUS.OLDX
	add adr.ROW,y
	sta HLP
	lda VAUS.OLDX+1
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 1364

	lda HLP
	sta BLITBOX.DST
	lda #$50
	add HLP+1
	sta BLITBOX.DST+1
	lda #$00
	adc #$00
	sta BLITBOX.DST+2
	lda #$00
	adc #$00
	sta BLITBOX.DST+3
	lda PLAYSCREEN.OFS
	add HLP
	sta BLITBOX.SRC
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITBOX.SRC+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITBOX.SRC+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITBOX.SRC+3
	lda VAUS.OLDLEN
	sta BLITBOX.W
	lda VAUS.OLDLEN+1
	sta BLITBOX.W+1
	lda VAUS.HEIGHT
	sta BLITBOX.H
	jsr BLITBOX

; optimize OK (service.pas), line = 1372

	lda VAUS.WIDTH
	sta VAUS.OLDLEN
	lda #$00
	sta VAUS.OLDLEN+1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLACE_VAUS					; PROCEDURE

; optimize FAIL (0, service.pas), line = 1381

	inc VAUS.IFLASH

; optimize OK (service.pas), line = 1383

	lda VAUS.IFLASH
	cmp #$0B
	jcc l_1000

; optimize FAIL (0, service.pas), line = 1385

	inc VAUS.FLASH

; optimize OK (service.pas), line = 1386

	lda #$00
	sta VAUS.IFLASH
l_1000

; optimize OK (service.pas), line = 1389

	lda VAUS.FLASH
	cmp #$0B
	jcc l_101D
	lda #$00
	sta VAUS.FLASH
l_101D

; optimize OK (service.pas), line = 1399

	lda #$00
	sta HLP
	sta HLP+1

; optimize OK (service.pas), line = 1401

	sta Y
	ldy VAUS.HEIGHT
	dey
	sty @FORTMP_1034_0

l_1037
; --- ForToDoCondition
	lda @FORTMP_1034_0::#$00
	cmp Y
	jcc l_1045

; optimize OK (service.pas), line = 1407

	lda Y
	add VAUS.Y
	tay
	lda VAUS.X
	add adr.ROW,y
	sta BLITZERO.DST
	lda #$50
	adc adr.ROW+256,y
	sta BLITZERO.DST+1
	lda #$00
	adc #$00
	sta BLITZERO.DST+2
	lda #$00
	adc #$00
	sta BLITZERO.DST+3
	lda PLAYVAUS.OFS
	add HLP
	sta BLITZERO.SRC
	lda PLAYVAUS.OFS+1
	adc HLP+1
	sta BLITZERO.SRC+1
	lda PLAYVAUS.OFS+2
	adc #$00
	sta BLITZERO.SRC+2
	lda PLAYVAUS.OFS+3
	adc #$00
	sta BLITZERO.SRC+3
	lda VAUS.WIDTH
	sta BLITZERO.W
	lda #$00
	sta BLITZERO.W+1
	lda #$01
	sta BLITZERO.H
	jsr BLITZERO

; optimize OK (service.pas), line = 1409

	lda Y
	cmp #$02
	jcc l_1089
	lda VAUS.HEIGHT
	sbc #$02
	sta :STACKORIGIN+11
	lda #$00
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+11
	lda Y
	cmp :STACKORIGIN+11
	lda #$00
	sbc :STACKORIGIN+STACKWIDTH+11
	svc
	eor #$80
	jpl l_1089

; optimize OK (service.pas), line = 1412

	ldy VAUS.FLASH
	lda adr.FLASH,y
	sta PUTBYTE.V
	lda Y
	add VAUS.Y
	tay
	lda VAUS.X
	add adr.ROW,y
	sta PUTBYTE.DST
	lda #$50
	adc adr.ROW+256,y
	sta PUTBYTE.DST+1
	lda #$00
	adc #$00
	sta PUTBYTE.DST+2
	lda #$00
	adc #$00
	sta PUTBYTE.DST+3
	jsr PUTBYTE

; optimize OK (service.pas), line = 1415

	ldy VAUS.FLASH
	lda adr.FLASH,y
	sta PUTBYTE.V
	lda VAUS.X
	add VAUS.WIDTH
	sta :STACKORIGIN+10
	lda #$50
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+10
	sub #$01
	sta :STACKORIGIN+10
	lda :STACKORIGIN+STACKWIDTH+10
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda :STACKORIGIN+STACKWIDTH*2+10
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda :STACKORIGIN+STACKWIDTH*3+10
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda Y
	add VAUS.Y
	tay
	lda :STACKORIGIN+10
	add adr.ROW,y
	sta PUTBYTE.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256,y
	sta PUTBYTE.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta PUTBYTE.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta PUTBYTE.DST+3
	jsr PUTBYTE
l_1089

; optimize OK (service.pas), line = 1418

	lda HLP
	add VAUS.WIDTH
	sta HLP
	scc
	inc HLP+1

; --- ForToDoEpilog
	inc Y
	jne l_1037
l_1045

; ------------------------------------------------------------

Y	= DATAORIGIN+$02E7

@VarData	= Y
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MOVE_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 1429

	ldy #1
	lda VAUS.OLDX+1
	cmp #$FF
	bne @+
	lda VAUS.OLDX
	cmp #$FF
@
	bne @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda VAUS.OLDX+1
	cmp #$00
	bne @+
	lda VAUS.OLDX
	cmp VAUS.X
@
	bne @+
	dey
@
	tya
	and :STACKORIGIN+9
	sta :STACKORIGIN+9
	ldy #1
	lda #$00
	cmp VAUS.OLDLEN+1
	bne @+
	lda VAUS.WIDTH
	cmp VAUS.OLDLEN
@
	bne @+
	dey
@
	tya
	ora :STACKORIGIN+9
	jeq l_1105

; optimize FAIL ('REMOVE_VAUS', service.pas), line = 1430

	jsr REMOVE_VAUS
l_1105

; optimize OK (service.pas), line = 1432

	lda VAUS.X
	sta VAUS.OLDX
	lda #$00
	sta VAUS.OLDX+1

; optimize OK (service.pas), line = 1433

	lda VAUS.Y
	sta VAUS.OLDY
	lda #$00
	sta VAUS.OLDY+1

; optimize OK (service.pas), line = 1440

	lda #$D8
	sub VAUS.WIDTH
	sta MIN.B
	lda #$00
	sbc #$00
	sta MIN.B+1
	lda X
	sta MIN.A
	lda X+1
	sta MIN.A+1
	jsr MIN
	lda #$0A
	sta MAX.A
	lda #$00
	sta MAX.A+1
	lda MIN.RESULT
	sta MAX.B
	lda MIN.RESULT+1
	sta MAX.B+1
	jsr MAX
	lda MAX.RESULT
	sta VAUS.X

; optimize OK (service.pas), line = 1441

	lda #$C8
	sub VAUS.HEIGHT
	sta MIN.B
	lda #$00
	sbc #$00
	sta MIN.B+1
	lda Y
	sta MIN.A
	lda Y+1
	sta MIN.A+1
	jsr MIN
	lda #$0C
	sta MAX.A
	lda #$00
	sta MAX.A+1
	lda MIN.RESULT
	sta MAX.B
	lda MIN.RESULT+1
	sta MAX.B+1
	jsr MAX
	lda MAX.RESULT
	sta VAUS.Y

; optimize FAIL ('PLACE_VAUS', service.pas), line = 1443

	jsr PLACE_VAUS

; ------------------------------------------------------------

X	= DATAORIGIN+$02E9
Y	= DATAORIGIN+$02EB

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 1458

	lda XA
	sta :STACKORIGIN+9
	lda #$00
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add #$09
	sta XS
	lda :STACKORIGIN+STACKWIDTH+9
	adc #$00
	sta XS+1

; optimize OK (service.pas), line = 1459

	lda YA
	sta :STACKORIGIN+9
	lda #$00
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add #$16
	sta YS
	lda :STACKORIGIN+STACKWIDTH+9
	adc #$00
	sta YS+1

; optimize OK (service.pas), line = 1461

	lda #$00
	sta Y

l_115D
; --- ForToDoCondition
	lda Y
	cmp #$08
	jcs l_116B

; optimize OK (service.pas), line = 1463

	lda YS
	adc Y
	tay
	lda adr.MODY,y
	sta :eax
	lda #$00
	sta :eax+1
	lda PATTERN.WIDTH
	sta :ecx
	lda PATTERN.WIDTH+1
	sta :ecx+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX_AL
	eif
	lda :eax
	sta YH
	lda :eax+1
	sta YH+1

; optimize OK (service.pas), line = 1471

	lda Y
	add YS
	tay
	lda XS
	add adr.ROW,y
	sta HLP
	lda XS+1
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 1473

	lda #$00
	sta I

; optimize OK (service.pas), line = 1475

	lda PLAYSCREEN.OFS
	add HLP
	sta VBXE_RAM.POSITION
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta VBXE_RAM.POSITION+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta VBXE_RAM.POSITION+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 1476

	lda SCANLINE
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER
	lda SCANLINE+1
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER+1
	lda #$10
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT
	lda #$00
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT+1
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.READBUFFER

; optimize OK (service.pas), line = 1478

	lda PATTERN.OFS
	add YH
	sta VBXE_RAM.POSITION
	lda PATTERN.OFS+1
	adc YH+1
	sta VBXE_RAM.POSITION+1
	lda PATTERN.OFS+2
	adc #$00
	sta VBXE_RAM.POSITION+2
	lda PATTERN.OFS+3
	adc #$00
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 1479

	lda <adr.SCANLINE+$80
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER
	lda >adr.SCANLINE+$80
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER+1
	lda #$28
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT
	lda #$00
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT+1
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.READBUFFER

; optimize OK (service.pas), line = 1481

	lda #$00
	sta X

l_11B6
; --- ForToDoCondition
	lda X
	cmp #$10
	jcs l_11C4

; optimize OK (service.pas), line = 1482

	adc XS
	sta :STACKORIGIN+9
	lda #$00
	adc XS+1
	cmp #$00
	bne @+
	lda :STACKORIGIN+9
	cmp #$D8
@
	jcs l_11DB

; optimize OK (service.pas), line = 1489

	ldy X
	lda adr.SCANLINE,y
	and #$80
	sta SHADOW

; optimize OK (service.pas), line = 1494

	lda X
	add XS
	tay
	lda adr.MODX,y
	add #$80
	tay
	lda adr.SCANLINE,y
	and #$7F
	ora SHADOW
	sta CL

; optimize OK (service.pas), line = 1496

	ldy I
	sta adr.TMP,y

; optimize FAIL (0, service.pas), line = 1497

	inc I
l_11DB

; --- ForToDoEpilog
	inc X
	jne l_11B6
l_11C4

; optimize OK (service.pas), line = 1509

	lda HLP
	sta BLITTMP.DST
	lda #$50
	add HLP+1
	sta BLITTMP.DST+1
	lda #$00
	adc #$00
	sta BLITTMP.DST+2
	lda #$00
	adc #$00
	sta BLITTMP.DST+3
	lda I
	sta BLITTMP.SIZE
	jsr BLITTMP

; optimize OK (service.pas), line = 1511

	lda PLAYSCREEN.OFS
	add HLP
	sta BLITROW.DST
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITROW.DST+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITROW.DST+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITROW.DST+3
	lda HLP
	sta BLITROW.SRC
	lda #$50
	add HLP+1
	sta BLITROW.SRC+1
	lda #$00
	adc #$00
	sta BLITROW.SRC+2
	lda #$00
	adc #$00
	sta BLITROW.SRC+3
	lda I
	sta BLITROW.SIZE
	lda #$00
	sta BLITROW.SIZE+1
	jsr BLITROW

; --- ForToDoEpilog
	inc Y
	jne l_115D
l_116B

; optimize OK (service.pas), line = 1521

	lda YS
	add #$04
	sta Y
	lda YS
	add #$0C
	sta @FORTMP_124B_0

l_124E
; --- ForToDoCondition
	lda @FORTMP_124B_0::#$00
	cmp Y
	jcc l_125C

; optimize OK (service.pas), line = 1523

	ldy Y
	lda adr.ROW,y
	add XS
	sta HLP
	lda adr.ROW+256,y
	adc XS+1
	sta HLP+1

; optimize OK (service.pas), line = 1525

	lda PLAYSCREEN.OFS
	add HLP
	sta VBXE_RAM.POSITION
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta VBXE_RAM.POSITION+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta VBXE_RAM.POSITION+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 1526

	lda TMP
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER
	lda TMP+1
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER+1
	lda #$20
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT
	lda #$00
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT+1
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.READBUFFER

; optimize OK (service.pas), line = 1528

	lda XS
	add #$08
	sta X
	lda XS
	add #$18
	sta @FORTMP_1286_0

l_1289
; --- ForToDoCondition
	lda @FORTMP_1286_0::#$00
	cmp X
	jcc l_1297

; optimize OK (service.pas), line = 1544

	lda X
	cmp #$D8
	jcs l_12A9

; optimize OK (service.pas), line = 1549

	sub XS
	sta :STACKORIGIN+9
	lda X
	sub XS
	tay
	lda adr.TMP,y
	ora #$80
	ldy :STACKORIGIN+9
	sta adr.TMP,y
l_12A9

; --- ForToDoEpilog
	inc X
	jne l_1289
l_1297

; optimize OK (service.pas), line = 1566

	lda HLP
	sta BLITTMP.DST
	lda #$50
	add HLP+1
	sta BLITTMP.DST+1
	lda #$00
	adc #$00
	sta BLITTMP.DST+2
	lda #$00
	adc #$00
	sta BLITTMP.DST+3
	lda #$20
	sta BLITTMP.SIZE
	jsr BLITTMP

; optimize OK (service.pas), line = 1568

	lda PLAYSCREEN.OFS
	add HLP
	sta BLITROW.DST
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITROW.DST+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITROW.DST+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITROW.DST+3
	lda HLP
	sta BLITROW.SRC
	lda #$50
	add HLP+1
	sta BLITROW.SRC+1
	lda #$00
	adc #$00
	sta BLITROW.SRC+2
	lda #$00
	adc #$00
	sta BLITROW.SRC+3
	lda #$20
	sta BLITROW.SIZE
	lda #$00
	sta BLITROW.SIZE+1
	jsr BLITROW

; --- ForToDoEpilog
	inc Y
	jne l_124E
l_125C

; ------------------------------------------------------------

XA	= DATAORIGIN+$02ED
YA	= DATAORIGIN+$02EE
X	= DATAORIGIN+$02EF
Y	= DATAORIGIN+$02F0
I	= DATAORIGIN+$02F1
XS	= DATAORIGIN+$02F2
YS	= DATAORIGIN+$02F4
YH	= DATAORIGIN+$02F6
CL	= DATAORIGIN+$02F8
SHADOW	= DATAORIGIN+$02F9

@VarData	= XA
@VarDataSize	= 13

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLACE_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 1585

	lda XA
	sta :STACKORIGIN+9
	lda #$00
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add #$09
	sta XS
	lda :STACKORIGIN+STACKWIDTH+9
	adc #$00
	sta XS+1

; optimize OK (service.pas), line = 1586

	lda YA
	sta :STACKORIGIN+9
	lda #$00
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	asl :STACKORIGIN+9
	rol @
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add #$16
	sta YS
	lda :STACKORIGIN+STACKWIDTH+9
	adc #$00
	sta YS+1

; optimize OK (service.pas), line = 1588

	lda #$00
	sta Y

l_130F
; --- ForToDoCondition
	lda Y
	cmp #$08
	jcs l_131D

; optimize OK (service.pas), line = 1590

	lda YS
	adc Y
	tay
	lda XS
	add adr.ROW,y
	sta HLP
	lda XS+1
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 1592

	lda PLAYSCREEN.OFS
	add HLP
	sta VBXE_RAM.POSITION
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta VBXE_RAM.POSITION+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta VBXE_RAM.POSITION+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 1593

	lda SCANLINE
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER
	lda SCANLINE+1
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER+1
	lda #$10
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT
	lda #$00
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT+1
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.READBUFFER

; optimize OK (service.pas), line = 1595

	lda #$00
	sta X

l_1345
; --- ForToDoCondition
	ldy X
	cpy #$10
	jcs l_1353

; optimize OK (service.pas), line = 1601

	lda adr.SCANLINE,y
	and #$80
	sta SHADOW

; optimize OK (service.pas), line = 1603

	lda Y
	cmp #$07
	jcs l_137E
	lda X
	cmp #$0F
	jcs l_137E

; optimize OK (service.pas), line = 1608

	lda BLOCK
	sub #$01
	sta :STACKORIGIN+9
	lda #$00
	sbc #$00
	lda :STACKORIGIN+9
	and #$0F
	tay
	lda adr.COLORBLOCK,y
	and #$7F
	ora SHADOW
	sta CL

; optimize OK (service.pas), line = 1610

	ldy X
	jmp l_13AC
l_137E

; optimize OK (service.pas), line = 1623

	ldy X
	lda SHADOW
l_13AC
	sta adr.TMP,y

; --- ForToDoEpilog
	inc X
	jne l_1345
l_1353

; optimize OK (service.pas), line = 1634

	lda HLP
	sta BLITTMP.DST
	lda #$50
	add HLP+1
	sta BLITTMP.DST+1
	lda #$00
	adc #$00
	sta BLITTMP.DST+2
	lda #$00
	adc #$00
	sta BLITTMP.DST+3
	lda #$10
	sta BLITTMP.SIZE
	jsr BLITTMP

; optimize OK (service.pas), line = 1636

	lda PLAYSCREEN.OFS
	add HLP
	sta BLITROW.DST
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITROW.DST+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITROW.DST+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITROW.DST+3
	lda HLP
	sta BLITROW.SRC
	lda #$50
	add HLP+1
	sta BLITROW.SRC+1
	lda #$00
	adc #$00
	sta BLITROW.SRC+2
	lda #$00
	adc #$00
	sta BLITROW.SRC+3
	lda #$10
	sta BLITROW.SIZE
	lda #$00
	sta BLITROW.SIZE+1
	jsr BLITROW

; --- ForToDoEpilog
	inc Y
	jne l_130F
l_131D

; optimize OK (service.pas), line = 1642

	lda YS
	add #$04
	sta Y
	lda YS
	add #$0C
	sta @FORTMP_13E5_0

l_13E8
; --- ForToDoCondition
	lda @FORTMP_13E5_0::#$00
	cmp Y
	jcc l_13F6

; optimize OK (service.pas), line = 1646

	ldy Y
	lda adr.ROW,y
	add XS
	sta HLP
	lda adr.ROW+256,y
	adc XS+1
	sta HLP+1

; optimize OK (service.pas), line = 1648

	lda PLAYSCREEN.OFS
	add HLP
	sta VBXE_RAM.POSITION
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta VBXE_RAM.POSITION+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta VBXE_RAM.POSITION+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 1649

	lda TMP
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER
	lda TMP+1
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER+1
	lda #$20
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT
	lda #$00
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT+1
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.READBUFFER

; optimize OK (service.pas), line = 1651

	lda XS
	add #$08
	sta X
	lda XS
	add #$18
	sta @FORTMP_1420_0

l_1423
; --- ForToDoCondition
	lda @FORTMP_1420_0::#$00
	cmp X
	jcc l_1431

; optimize OK (service.pas), line = 1652

	lda X
	cmp #$D8
	jcs l_1443

; optimize OK (service.pas), line = 1661

	sub XS
	sta :STACKORIGIN+9
	lda X
	sub XS
	tay
	lda adr.TMP,y
	and #$7F
	ldy :STACKORIGIN+9
	sta adr.TMP,y
l_1443

; --- ForToDoEpilog
	inc X
	jne l_1423
l_1431

; optimize OK (service.pas), line = 1677

	lda HLP
	sta BLITTMP.DST
	lda #$50
	add HLP+1
	sta BLITTMP.DST+1
	lda #$00
	adc #$00
	sta BLITTMP.DST+2
	lda #$00
	adc #$00
	sta BLITTMP.DST+3
	lda #$20
	sta BLITTMP.SIZE
	jsr BLITTMP

; optimize OK (service.pas), line = 1679

	lda PLAYSCREEN.OFS
	add HLP
	sta BLITROW.DST
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITROW.DST+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITROW.DST+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITROW.DST+3
	lda HLP
	sta BLITROW.SRC
	lda #$50
	add HLP+1
	sta BLITROW.SRC+1
	lda #$00
	adc #$00
	sta BLITROW.SRC+2
	lda #$00
	adc #$00
	sta BLITROW.SRC+3
	lda #$20
	sta BLITROW.SIZE
	lda #$00
	sta BLITROW.SIZE+1
	jsr BLITROW

; --- ForToDoEpilog
	inc Y
	jne l_13E8
l_13F6

; optimize OK (service.pas), line = 1684

	lda BLOCK
	cmp #$09
	jcc l_1492

; optimize OK (service.pas), line = 1686

	lda #$00
	sta CL2

; optimize OK (service.pas), line = 1687

	lda BLOCK
	and #$0F
	cmp #$09
	jne l_14AD

; optimize OK (service.pas), line = 1689

	lda #$CA
	sta CL2

; optimize OK (service.pas), line = 1690

	lda YA
	asl @
	asl @
	asl @
	asl @
	add XA
	tay
	lda #$19
	sta adr.WALL,y
	jmp l_14CC
l_14AD

; optimize OK (service.pas), line = 1696

	lda BLOCK
	cmp #$0A
	jne l_14DE
	lda #$C9
	sta CL2
l_14CC
l_14DE

; optimize OK (service.pas), line = 1700

	lda #$00
	sta Y

l_14EE
; --- ForToDoCondition
	lda Y
	cmp #$07
	jcs l_14FC

; optimize OK (service.pas), line = 1703

	adc YS
	tay
	lda XS
	add adr.ROW,y
	sta HLP
	lda XS+1
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 1708

	lda PLAYSCREEN.OFS
	add HLP
	sta GETBYTE.SRC
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta GETBYTE.SRC+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta GETBYTE.SRC+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta GETBYTE.SRC+3
	jsr GETBYTE
	lda GETBYTE.RESULT
	and #$80
	sta CL

; optimize OK (service.pas), line = 1710

	lda CL2
	and #$7F
	ora CL
	sta CL2

; optimize OK (service.pas), line = 1714

	lda HLP
	sta PUTBYTE.DST
	lda #$50
	add HLP+1
	sta PUTBYTE.DST+1
	lda #$00
	adc #$00
	sta PUTBYTE.DST+2
	lda #$00
	adc #$00
	sta PUTBYTE.DST+3
	lda CL2
	sta PUTBYTE.V
	jsr PUTBYTE

; optimize OK (service.pas), line = 1718

	lda PLAYSCREEN.OFS
	add HLP
	sta PUTBYTE.DST
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta PUTBYTE.DST+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta PUTBYTE.DST+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta PUTBYTE.DST+3
	lda CL2
	sta PUTBYTE.V
	jsr PUTBYTE

; --- ForToDoEpilog
	inc Y
	jne l_14EE
l_14FC

; optimize OK (service.pas), line = 1721

	ldy YS
	lda XS
	add adr.ROW,y
	sta HLP
	lda XS+1
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 1723

	lda PLAYSCREEN.OFS
	add HLP
	sta VBXE_RAM.POSITION
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta VBXE_RAM.POSITION+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta VBXE_RAM.POSITION+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 1724

	lda SCANLINE
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER
	lda SCANLINE+1
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER+1
	lda #$0F
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT
	lda #$00
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT+1
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.READBUFFER

; optimize OK (service.pas), line = 1727

	lda #$00
	tay

l_1567
; --- ForToDoCondition
	cpy #$0F
	jcs l_1575

; optimize OK (service.pas), line = 1733

	lda adr.SCANLINE,y
	and #$80
	sta CL

; optimize OK (service.pas), line = 1735

	lda CL2
	and #$7F
	ora CL
	sta adr.TMP,y

; --- ForToDoEpilog
	iny
	jne l_1567
l_1575
	sty X

; optimize OK (service.pas), line = 1744

	lda HLP
	sta BLITTMP.DST
	lda #$50
	add HLP+1
	sta BLITTMP.DST+1
	lda #$00
	adc #$00
	sta BLITTMP.DST+2
	lda #$00
	adc #$00
	sta BLITTMP.DST+3
	lda #$0F
	sta BLITTMP.SIZE
	jsr BLITTMP

; optimize OK (service.pas), line = 1746

	lda PLAYSCREEN.OFS
	add HLP
	sta BLITROW.DST
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITROW.DST+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITROW.DST+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITROW.DST+3
	lda HLP
	sta BLITROW.SRC
	lda #$50
	add HLP+1
	sta BLITROW.SRC+1
	lda #$00
	adc #$00
	sta BLITROW.SRC+2
	lda #$00
	adc #$00
	sta BLITROW.SRC+3
	lda #$0F
	sta BLITROW.SIZE
	lda #$00
	sta BLITROW.SIZE+1
	jsr BLITROW
l_1492

; ------------------------------------------------------------

XA	= DATAORIGIN+$02FC
YA	= DATAORIGIN+$02FD
BLOCK	= DATAORIGIN+$02FE
X	= DATAORIGIN+$02FF
Y	= DATAORIGIN+$0300
I	= DATAORIGIN+$0301
XS	= DATAORIGIN+$0302
YS	= DATAORIGIN+$0304
CL	= DATAORIGIN+$0306
CL2	= DATAORIGIN+$0307
SHADOW	= DATAORIGIN+$0308

@VarData	= XA
@VarDataSize	= 13

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PUT_WALL					; PROCEDURE

; optimize OK (service.pas), line = 1758

	lda #$00
	sta Y

l_15BF
; --- ForToDoCondition
	lda Y
	cmp #$0F
	jcs l_15CD

; optimize OK (service.pas), line = 1759

	lda #$00
	sta X

l_15D6
; --- ForToDoCondition
	lda X
	cmp #$0D
	jcs l_15E4

; optimize OK (service.pas), line = 1760

	lda Y
	asl @
	asl @
	asl @
	asl @
	add X
	tay
	lda adr.WALL,y
	jeq l_1603
	lda Y
	asl @
	asl @
	asl @
	asl @
	add X
	tay
	lda adr.WALL,y
	sta PLACE_BLOCK.BLOCK
	lda X
	sta PLACE_BLOCK.XA
	lda Y
	sta PLACE_BLOCK.YA
	jsr PLACE_BLOCK
l_1603

; --- ForToDoEpilog
	inc X
	jne l_15D6
l_15E4

; --- ForToDoEpilog
	inc Y
	jne l_15BF
l_15CD

; ------------------------------------------------------------

X	= DATAORIGIN+$030B
Y	= DATAORIGIN+$030C

@VarData	= X
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SET_WALL					; PROCEDURE

; optimize OK (service.pas), line = 1769

	lda #$00
	sta REMAIN_BLK

; optimize OK (service.pas), line = 1770

	ldy CUR_PLAYER
	lda adr.SCORE.WALL_N,y
	sta WL

; optimize OK (service.pas), line = 1773

	lda #$00
	sta Y

l_1641
; --- ForToDoCondition
	lda Y
	cmp #$0F
	jcs l_164F

; optimize OK (service.pas), line = 1774

	lda #$00
	sta X

l_1658
; --- ForToDoCondition
	lda X
	cmp #$0D
	jcs l_1666

; optimize OK (service.pas), line = 1777

	lda Y
	asl @
	asl @
	asl @
	asl @
	add X
	tay
	lda adr.WALL,y
	jeq l_169E
	lda Y
	asl @
	asl @
	asl @
	asl @
	add X
	tay
	lda adr.WALL,y
	cmp #$0A
	jeq l_169E
	inc REMAIN_BLK
l_169E

; --- ForToDoEpilog
	inc X
	jne l_1658
l_1666

; --- ForToDoEpilog
	inc Y
	jne l_1641
l_164F

; optimize OK (service.pas), line = 1779

	lda WL
	sub #$01
	sta @SMALLINT.MOD.A
	lda #$00
	sbc #$00
	sta @SMALLINT.MOD.A+1
	lda #$04
	sta @SMALLINT.MOD.B
	lda #$00
	sta @SMALLINT.MOD.B+1
	jsr @SMALLINT.MOD
	lda @SMALLINT.MOD.RESULT
	sta WL

; optimize OK (service.pas), line = 1781

	sta @CASETMP_0008
	cmp #$00
	jne l_16C8
@

; optimize OK (service.pas), line = 1782

	:8 mva adr.PATTERN0+# adr.PATTERN+#
	jmp a_0008
l_16C8
	cmp #$01
	jne l_16D1

; optimize OK (service.pas), line = 1783

	:8 mva adr.PATTERN1+# adr.PATTERN+#
	jmp a_0008
l_16D1
	cmp #$02
	jne l_16DA

; optimize OK (service.pas), line = 1784

	:8 mva adr.PATTERN2+# adr.PATTERN+#
	jmp a_0008
l_16DA
	cmp #$03
	jne l_16E3

; optimize OK (service.pas), line = 1785

	:8 mva adr.PATTERN3+# adr.PATTERN+#
	jmp a_0008
l_16E3
	cmp #$04
	jne l_16EC

; optimize OK (service.pas), line = 1786

	:8 mva adr.PATTERN4+# adr.PATTERN+#
l_16EC
a_0008

; ------------------------------------------------------------

X	= DATAORIGIN+$030D
Y	= DATAORIGIN+$030E
WL	= DATAORIGIN+$030F
@CASETMP_0008	= DATAORIGIN+$0310

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SPLIT_LINE					; FUNCTION

; optimize OK (service.pas), line = 1825

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	add #$10
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1826

	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	add #$18
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1827

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	add #$10
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1828

	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	add #$18
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1830

	lda #$00
	sta COLLISION

; optimize OK (service.pas), line = 1832

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+9
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta XP1
	lda :STACKORIGIN+STACKWIDTH+9
	sta XP1+1

; optimize OK (service.pas), line = 1833

	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+9
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta YP1
	lda :STACKORIGIN+STACKWIDTH+9
	sta YP1+1

; optimize OK (service.pas), line = 1834

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+9
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta XP2
	lda :STACKORIGIN+STACKWIDTH+9
	sta XP2+1

; optimize OK (service.pas), line = 1835

	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+9
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta YP2
	lda :STACKORIGIN+STACKWIDTH+9
	sta YP2+1

; optimize OK (service.pas), line = 1837

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	sta XK
	iny
	lda (:bp2),y
	sta XK+1

; optimize OK (service.pas), line = 1838

	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	sta YK
	iny
	lda (:bp2),y
	sta YK+1

; optimize OK (service.pas), line = 1839

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	sta XJ
	iny
	lda (:bp2),y
	sta XJ+1

; optimize OK (service.pas), line = 1840

	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	sta YJ
	iny
	lda (:bp2),y
	sta YJ+1

; optimize OK (service.pas), line = 1842

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	sta XH
	iny
	lda (:bp2),y
	sta XH+1

; optimize OK (service.pas), line = 1843

	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	sta YH
	iny
	lda (:bp2),y
	sta YH+1

; optimize OK (service.pas), line = 1844

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	sta XN
	iny
	lda (:bp2),y
	sta XN+1

; optimize OK (service.pas), line = 1845

	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	sta YN
	iny
	lda (:bp2),y
	sta YN+1

; optimize OK (service.pas), line = 1852

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	sta :STACKORIGIN+10
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+9
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	sty :STACKORIGIN+STACKWIDTH*3+9
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+10
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+10
	sty :STACKORIGIN+STACKWIDTH*2+10
	sty :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+9
	sub :STACKORIGIN+10
	sta SYSTEM.ABS.@010185000.X
	lda :STACKORIGIN+STACKWIDTH+9
	sbc :STACKORIGIN+STACKWIDTH+10
	sta SYSTEM.ABS.@010185000.X+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	sbc :STACKORIGIN+STACKWIDTH*2+10
	sta SYSTEM.ABS.@010185000.X+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	sbc :STACKORIGIN+STACKWIDTH*3+10
	sta SYSTEM.ABS.@010185000.X+3
	jsr SYSTEM.ABS.@010185000
	inx
	ldy #1
	.LOCAL
	lda SYSTEM.ABS.@010185000.RESULT+3
	sub #$00
	bne L4
	lda SYSTEM.ABS.@010185000.RESULT+2
	cmp #$00
	bne L1
	lda SYSTEM.ABS.@010185000.RESULT+1
	cmp #$00
	bne L1
	lda SYSTEM.ABS.@010185000.RESULT
	cmp #$10
L1	beq L5
	bcs L3
	lda #$FF
	bne L5
L3	lda #$01
	bne L5
L4	bvc L5
	eor #$FF
	ora #$01
L5
	.ENDL
	seq
	bpl @+
	dey
@
	sty :STACKORIGIN,x
	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	sta :STACKORIGIN+10
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+9
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	sty :STACKORIGIN+STACKWIDTH*3+9
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+10
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+10
	sty :STACKORIGIN+STACKWIDTH*2+10
	sty :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+9
	sub :STACKORIGIN+10
	sta SYSTEM.ABS.@010185000.X
	lda :STACKORIGIN+STACKWIDTH+9
	sbc :STACKORIGIN+STACKWIDTH+10
	sta SYSTEM.ABS.@010185000.X+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	sbc :STACKORIGIN+STACKWIDTH*2+10
	sta SYSTEM.ABS.@010185000.X+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	sbc :STACKORIGIN+STACKWIDTH*3+10
	sta SYSTEM.ABS.@010185000.X+3
	jsr SYSTEM.ABS.@010185000
	dex
	ldy #1
	.LOCAL
	lda SYSTEM.ABS.@010185000.RESULT+3
	sub #$00
	bne L4
	lda SYSTEM.ABS.@010185000.RESULT+2
	cmp #$00
	bne L1
	lda SYSTEM.ABS.@010185000.RESULT+1
	cmp #$00
	bne L1
	lda SYSTEM.ABS.@010185000.RESULT
	cmp #$08
L1	beq L5
	bcs L3
	lda #$FF
	bne L5
L3	lda #$01
	bne L5
L4	bvc L5
	eor #$FF
	ora #$01
L5
	.ENDL
	seq
	bpl @+
	dey
@
	tya
	ora :STACKORIGIN+1,x
	jeq l_1775

; optimize OK (service.pas), line = 1853

	lda #$01
	jsr FATAL_ERROR
l_1775

; optimize OK (service.pas), line = 1856

	lda XP1+1
	cmp XP2+1
	bne @+
	lda XP1
	cmp XP2
@
	jne l_1798x
	lda YP1+1
	cmp YP2+1
	bne @+
	lda YP1
	cmp YP2
@
	jeq l_1798
l_1798x

; optimize OK (service.pas), line = 1858

	lda YP1+1
	cmp YP2+1
	bne @+
	lda YP1
	cmp YP2
@
	jeq l_17AB

; optimize OK (service.pas), line = 1860

	lda COLLISION
	ora #$01
	sta COLLISION

; --- WhileProlog
	jmp l_17B8
l_17B9

; optimize OK (service.pas), line = 1864

	lda XH
	sta :STACKORIGIN+9
	ldy #$00
	lda XH+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	sty :STACKORIGIN+STACKWIDTH*3+9
	lda XN
	sta :STACKORIGIN+10
	ldy #$00
	lda XN+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+10
	sty :STACKORIGIN+STACKWIDTH*2+10
	sty :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+9
	add :STACKORIGIN+10
	sta :STACKORIGIN+9
	lda :STACKORIGIN+STACKWIDTH+9
	adc :STACKORIGIN+STACKWIDTH+10
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc :STACKORIGIN+STACKWIDTH*2+10
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc :STACKORIGIN+STACKWIDTH*3+10
	sta :STACKORIGIN+STACKWIDTH*3+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta X
	lda :STACKORIGIN+STACKWIDTH+9
	sta X+1

; optimize OK (service.pas), line = 1865

	lda YH
	sta :STACKORIGIN+9
	ldy #$00
	lda YH+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	sty :STACKORIGIN+STACKWIDTH*3+9
	lda YN
	sta :STACKORIGIN+10
	ldy #$00
	lda YN+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+10
	sty :STACKORIGIN+STACKWIDTH*2+10
	sty :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+9
	add :STACKORIGIN+10
	sta :STACKORIGIN+9
	lda :STACKORIGIN+STACKWIDTH+9
	adc :STACKORIGIN+STACKWIDTH+10
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc :STACKORIGIN+STACKWIDTH*2+10
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc :STACKORIGIN+STACKWIDTH*3+10
	sta :STACKORIGIN+STACKWIDTH*3+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta Y
	lda :STACKORIGIN+STACKWIDTH+9
	sta Y+1

; optimize OK (service.pas), line = 1867

	lda Y
	sta :STACKORIGIN+9
	ldy #$00
	lda Y+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta YP
	lda :STACKORIGIN+STACKWIDTH+9
	sta YP+1

; optimize OK (service.pas), line = 1869

	cmp YP1+1
	bne @+
	lda YP
	cmp YP1
@
	jne l_17F0

; optimize OK (service.pas), line = 1871

	lda X
	sta XH
	lda X+1
	sta XH+1

; optimize OK (service.pas), line = 1872

	lda Y
	sta YH
	lda Y+1
	sta YH+1
l_17F0

; optimize OK (service.pas), line = 1875

	lda YP+1
	cmp YP2+1
	bne @+
	lda YP
	cmp YP2
@
	jne l_180F

; optimize OK (service.pas), line = 1877

	lda X
	sta XN
	lda X+1
	sta XN+1

; optimize OK (service.pas), line = 1878

	lda Y
	sta YN
	lda Y+1
	sta YN+1
l_180F
l_17B8

; optimize OK (service.pas), line = 1862

	lda YN
	and #$07
	jeq l_17B9w
	lda YN
	and #$07
	cmp #$07
	jne l_17B9
l_17B9w
l_17AB

; optimize OK (service.pas), line = 1884

	lda XP1+1
	cmp XP2+1
	bne @+
	lda XP1
	cmp XP2
@
	jeq l_184E

; optimize OK (service.pas), line = 1886

	lda COLLISION
	ora #$02
	sta COLLISION

; --- WhileProlog
	jmp l_185B
l_185C

; optimize OK (service.pas), line = 1890

	lda XK
	sta :STACKORIGIN+9
	ldy #$00
	lda XK+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	sty :STACKORIGIN+STACKWIDTH*3+9
	lda XJ
	sta :STACKORIGIN+10
	ldy #$00
	lda XJ+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+10
	sty :STACKORIGIN+STACKWIDTH*2+10
	sty :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+9
	add :STACKORIGIN+10
	sta :STACKORIGIN+9
	lda :STACKORIGIN+STACKWIDTH+9
	adc :STACKORIGIN+STACKWIDTH+10
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc :STACKORIGIN+STACKWIDTH*2+10
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc :STACKORIGIN+STACKWIDTH*3+10
	sta :STACKORIGIN+STACKWIDTH*3+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta X
	lda :STACKORIGIN+STACKWIDTH+9
	sta X+1

; optimize OK (service.pas), line = 1891

	lda YK
	sta :STACKORIGIN+9
	ldy #$00
	lda YK+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	sty :STACKORIGIN+STACKWIDTH*3+9
	lda YJ
	sta :STACKORIGIN+10
	ldy #$00
	lda YJ+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+10
	sty :STACKORIGIN+STACKWIDTH*2+10
	sty :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+9
	add :STACKORIGIN+10
	sta :STACKORIGIN+9
	lda :STACKORIGIN+STACKWIDTH+9
	adc :STACKORIGIN+STACKWIDTH+10
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc :STACKORIGIN+STACKWIDTH*2+10
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc :STACKORIGIN+STACKWIDTH*3+10
	sta :STACKORIGIN+STACKWIDTH*3+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta Y
	lda :STACKORIGIN+STACKWIDTH+9
	sta Y+1

; optimize OK (service.pas), line = 1893

	lda X
	sta :STACKORIGIN+9
	ldy #$00
	lda X+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lsr :STACKORIGIN+STACKWIDTH*2+9
	ror :STACKORIGIN+STACKWIDTH+9
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta XP
	lda :STACKORIGIN+STACKWIDTH+9
	sta XP+1

; optimize OK (service.pas), line = 1895

	cmp XP1+1
	bne @+
	lda XP
	cmp XP1
@
	jne l_1893

; optimize OK (service.pas), line = 1897

	lda X
	sta XK
	lda X+1
	sta XK+1

; optimize OK (service.pas), line = 1898

	lda Y
	sta YK
	lda Y+1
	sta YK+1
l_1893

; optimize OK (service.pas), line = 1901

	lda XP+1
	cmp XP2+1
	bne @+
	lda XP
	cmp XP2
@
	jne l_18B2

; optimize OK (service.pas), line = 1903

	lda X
	sta XJ
	lda X+1
	sta XJ+1

; optimize OK (service.pas), line = 1904

	lda Y
	sta YJ
	lda Y+1
	sta YJ+1
l_18B2
l_185B

; optimize OK (service.pas), line = 1888

	lda XJ
	and #$0F
	jeq l_185Cw
	lda XJ
	and #$0F
	cmp #$0F
	jne l_185C
l_185Cw
l_184E

; optimize OK (service.pas), line = 1915

	lda COLLISION
	cmp #$01
	jne l_18F1
; optimize OK (service.pas), line = 1917
; optimize OK (service.pas), line = 1918
	jmp l_1905
l_18F1

; optimize OK (service.pas), line = 1920

	lda COLLISION
	cmp #$02
	jne l_1917

; optimize OK (service.pas), line = 1922

	mwy X2 :bp2
	ldy #$00
	lda XJ
	sta (:bp2),y
	iny
	lda XJ+1
	sta (:bp2),y

; optimize OK (service.pas), line = 1923

	mwy Y2 :bp2
	ldy #$00
	lda YJ
	sta (:bp2),y
	iny
	lda YJ+1
	jmp l_192B
l_1917

; optimize OK (service.pas), line = 1925

	lda COLLISION
	cmp #$03
	jne l_193D

; optimize OK (service.pas), line = 1927

	mwy X1 :bp2
	ldy #$00
	lda XJ
	sta (:bp2),y
	iny
	lda XJ+1
	sta (:bp2),y

; optimize OK (service.pas), line = 1928

	mwy Y1 :bp2
	ldy #$00
	lda YJ
	sta (:bp2),y
	iny
	lda YJ+1
	sta (:bp2),y
l_1905

; optimize OK (service.pas), line = 1929

	mwy X2 :bp2
	ldy #$00
	lda XN
	sta (:bp2),y
	iny
	lda XN+1
	sta (:bp2),y

; optimize OK (service.pas), line = 1930

	mwy Y2 :bp2
	ldy #$00
	lda YN
	sta (:bp2),y
	iny
	lda YN+1
l_192B
	sta (:bp2),y
l_193D
	jmp l_195D
l_1798

; optimize OK (service.pas), line = 1935

	lda #$02
	jsr FATAL_ERROR
l_195D

; optimize OK (service.pas), line = 1938

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	sub #$10
	sta (:bp2),y
	iny
	lda (:bp2),y
	sbc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1939

	mwy Y1 :bp2
	ldy #$00
	lda (:bp2),y
	sub #$18
	sta (:bp2),y
	iny
	lda (:bp2),y
	sbc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1940

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	sub #$10
	sta (:bp2),y
	iny
	lda (:bp2),y
	sbc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1941

	mwy Y2 :bp2
	ldy #$00
	lda (:bp2),y
	sub #$18
	sta (:bp2),y
	iny
	lda (:bp2),y
	sbc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1944

	mwy X1 :bp2
	ldy #$00
	lda (:bp2),y
	sta MAX.B
	iny
	lda (:bp2),y
	sta MAX.B+1
	lda #$00
	sta MAX.A
	sta MAX.A+1
	jsr MAX
	lda #$CF
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda MAX.RESULT
	sta MIN.B
	lda MAX.RESULT+1
	sta MIN.B+1
	jsr MIN
	mwy X1 :bp2
	ldy #$00
	lda MIN.RESULT
	sta (:bp2),y
	iny
	lda MIN.RESULT+1
	sta (:bp2),y

; optimize OK (service.pas), line = 1945

	mwy X2 :bp2
	ldy #$00
	lda (:bp2),y
	sta MAX.B
	iny
	lda (:bp2),y
	sta MAX.B+1
	lda #$00
	sta MAX.A
	sta MAX.A+1
	jsr MAX
	lda #$CF
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda MAX.RESULT
	sta MIN.B
	lda MAX.RESULT+1
	sta MIN.B+1
	jsr MIN
	mwy X2 :bp2
	ldy #$00
	lda MIN.RESULT
	sta (:bp2),y
	iny
	lda MIN.RESULT+1
	sta (:bp2),y

; optimize OK (service.pas), line = 1952

	lda COLLISION
	sta RESULT
@exit

; ------------------------------------------------------------

X1	= DATAORIGIN+$0311
Y1	= DATAORIGIN+$0313
X2	= DATAORIGIN+$0315
Y2	= DATAORIGIN+$0317
RESULT	= DATAORIGIN+$0319
X	= DATAORIGIN+$031A
Y	= DATAORIGIN+$031C
XK	= DATAORIGIN+$031E
YK	= DATAORIGIN+$0320
XJ	= DATAORIGIN+$0322
YJ	= DATAORIGIN+$0324
XH	= DATAORIGIN+$0326
YH	= DATAORIGIN+$0328
XN	= DATAORIGIN+$032A
YN	= DATAORIGIN+$032C
XP1	= DATAORIGIN+$032E
YP1	= DATAORIGIN+$0330
XP2	= DATAORIGIN+$0332
YP2	= DATAORIGIN+$0334
XP	= DATAORIGIN+$0336
YP	= DATAORIGIN+$0338
COLLISION	= DATAORIGIN+$033A

@VarData	= X1
@VarDataSize	= 41

	rts						; ret
.endl

.local	SHOOT_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 1963

	lda XB+1
	jmi l_19B1
	lda XB
	cmp #$0D
	lda XB+1
	sbc #$00
	svc
	eor #$80
	jpl l_19B1
	lda YB+1
	jmi l_19B1
	lda YB
	cmp #$0F
	lda YB+1
	sbc #$00
	svc
	eor #$80
	jpl l_19B1

; optimize OK (service.pas), line = 1966

	lda YB
	asl @
	asl @
	asl @
	asl @
	add XB
	sta I

; optimize OK (service.pas), line = 1968

	tay
	lda adr.WALL,y
	jeq l_19D5

; optimize OK (service.pas), line = 1970

	cmp #$0A
	jcs l_19EB

; optimize OK (service.pas), line = 1972

	lda XB
	sta REMOVE_BLOCK.XA
	lda YB
	sta REMOVE_BLOCK.YA
	jsr REMOVE_BLOCK

; optimize FAIL (0, service.pas), line = 1973

	dec REMAIN_BLK

; optimize OK (service.pas), line = 1977

	lda CUR_PLAYER
	asl @
	asl @
	sta :STACKORIGIN+9
	ldy I
	lda adr.WALL,y
	asl @
	tay
	lda adr.SCORE_WALL,y
	sta :STACKORIGIN+10
	lda adr.SCORE_WALL+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy :STACKORIGIN+9
	lda adr.SCORE.PLAYER,y
	add :STACKORIGIN+10
	sta adr.SCORE.PLAYER,y
	lda adr.SCORE.PLAYER+1,y
	adc :STACKORIGIN+STACKWIDTH+10
	sta adr.SCORE.PLAYER+1,y
	lda adr.SCORE.PLAYER+2,y
	adc #$00
	sta adr.SCORE.PLAYER+2,y
	lda adr.SCORE.PLAYER+3,y
	adc #$00
	sta adr.SCORE.PLAYER+3,y

; optimize OK (service.pas), line = 1979

	lda #$2C
	sta SYSTEM.RANDOM.@010184000.RANGE
	lda #$01
	sta SYSTEM.RANDOM.@010184000.RANGE+1
	jsr SYSTEM.RANDOM.@010184000
	lda LETT.INCOMING
	add SYSTEM.RANDOM.@010184000.RESULT
	sta LETT.INCOMING
	lda LETT.INCOMING+1
	adc SYSTEM.RANDOM.@010184000.RESULT+1
	sta LETT.INCOMING+1

; optimize OK (service.pas), line = 1981

	lda XB
	sta :STACKORIGIN+9
	ldy #$00
	lda XB+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	sty :STACKORIGIN+STACKWIDTH*3+9
	asl :STACKORIGIN+9
	rol :STACKORIGIN+STACKWIDTH+9
	rol :STACKORIGIN+STACKWIDTH*2+9
	rol :STACKORIGIN+STACKWIDTH*3+9
	asl :STACKORIGIN+9
	rol :STACKORIGIN+STACKWIDTH+9
	asl :STACKORIGIN+9
	rol :STACKORIGIN+STACKWIDTH+9
	asl :STACKORIGIN+9
	rol :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add #$09
	sta LETT.NEXTX
	lda :STACKORIGIN+STACKWIDTH+9
	adc #$00
	sta LETT.NEXTX+1

; optimize OK (service.pas), line = 1982

	lda YB
	sta :STACKORIGIN+9
	ldy #$00
	lda YB+1
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	sty :STACKORIGIN+STACKWIDTH*3+9
	lda :STACKORIGIN+9
	add #$01
	sta :STACKORIGIN+9
	lda :STACKORIGIN+STACKWIDTH+9
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+9
	asl :STACKORIGIN+9
	rol :STACKORIGIN+STACKWIDTH+9
	asl :STACKORIGIN+9
	rol :STACKORIGIN+STACKWIDTH+9
	asl :STACKORIGIN+9
	rol :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	add #$16
	sta LETT.NEXTY
	lda :STACKORIGIN+STACKWIDTH+9
	adc #$00
	sta LETT.NEXTY+1

; optimize FAIL ('RANDOM_LETTER_DROP', service.pas), line = 1983

	jsr RANDOM_LETTER_DROP
	lda RANDOM_LETTER_DROP.RESULT
	sta LETT.NEXTTYPE
	lda RANDOM_LETTER_DROP.RESULT+1
	sta LETT.NEXTTYPE+1

; optimize OK (service.pas), line = 1985

	ldy I
	lda #$00
	sta adr.WALL,y

; optimize OK (service.pas), line = 1986

	lda #$B8
	sta BALL_BLOCK_SOUND.A
	lda #$01
	sta BALL_BLOCK_SOUND.A+1
	lda #$03
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND

; optimize OK (service.pas), line = 1987

	mwy BALL :bp2
	ldy #BALL.SBD-DATAORIGIN
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (service.pas), line = 1988

	ldy #BALL.BRWHIT-DATAORIGIN
	sta (:bp2),y
	jmp l_1A3F
l_19EB

; optimize OK (service.pas), line = 1993

	ldy I
	lda adr.WALL,y
	and #$0F
	cmp #$09
	jne l_1A58

; optimize OK (service.pas), line = 1995

	mwy BALL :bp2
	ldy #BALL.BRWHIT-DATAORIGIN
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 1996

	ldy I
	lda adr.WALL,y
	sub #$10
	sta adr.WALL,y

; optimize OK (service.pas), line = 1998

	lda #$72
	sta BALL_BLOCK_SOUND.A
	lda #$01
	sta BALL_BLOCK_SOUND.A+1
	lda #$04
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND

; optimize OK (service.pas), line = 1999

	lda XB
	sta SHINE.XB
	lda YB
	sta SHINE.YB
	jsr SHINE
	jmp l_1A72
l_1A58

; optimize OK (service.pas), line = 2003

	mwy BALL :bp2
	ldy #BALL.BRWHIT-DATAORIGIN
	lda (:bp2),y
	add #$01
	sta (:bp2),y

; optimize OK (service.pas), line = 2004

	lda XB
	sta SHINE.XB
	lda YB
	sta SHINE.YB
	jsr SHINE

; optimize OK (service.pas), line = 2006

	lda #$C8
	sta BALL_BLOCK_SOUND.A
	lda #$00
	sta BALL_BLOCK_SOUND.A+1
	lda #$07
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND
l_1A72
l_1A3F
l_19D5
l_19B1

; ------------------------------------------------------------

XB	= DATAORIGIN+$033B
YB	= DATAORIGIN+$033D
BALL	= DATAORIGIN+$033F
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B
I	= DATAORIGIN+$0343

@VarData	= XB
@VarDataSize	= 7

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	SHOOT_BLOCK_WITH_FIRE				; PROCEDURE

; optimize OK (service.pas), line = 2017

	lda XB+1
	jmi l_1AB5
	lda XB
	cmp #$0D
	lda XB+1
	sbc #$00
	svc
	eor #$80
	jpl l_1AB5
	lda YB+1
	jmi l_1AB5
	lda YB
	cmp #$0F
	lda YB+1
	sbc #$00
	svc
	eor #$80
	jpl l_1AB5

; optimize OK (service.pas), line = 2020

	lda YB
	asl @
	asl @
	asl @
	asl @
	add XB
	sta I

; optimize OK (service.pas), line = 2022

	tay
	lda adr.WALL,y
	jeq l_1AD9

; optimize OK (service.pas), line = 2024

	cmp #$0A
	jcs l_1AEF

; optimize OK (service.pas), line = 2026

	lda XB
	sta REMOVE_BLOCK.XA
	lda YB
	sta REMOVE_BLOCK.YA
	jsr REMOVE_BLOCK

; optimize FAIL (0, service.pas), line = 2027

	dec REMAIN_BLK

; optimize OK (service.pas), line = 2028

	lda CUR_PLAYER
	asl @
	asl @
	sta :STACKORIGIN+9
	ldy I
	lda adr.WALL,y
	asl @
	tay
	lda adr.SCORE_WALL,y
	sta :STACKORIGIN+10
	lda adr.SCORE_WALL+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy :STACKORIGIN+9
	lda adr.SCORE.PLAYER,y
	add :STACKORIGIN+10
	sta adr.SCORE.PLAYER,y
	lda adr.SCORE.PLAYER+1,y
	adc :STACKORIGIN+STACKWIDTH+10
	sta adr.SCORE.PLAYER+1,y
	lda adr.SCORE.PLAYER+2,y
	adc #$00
	sta adr.SCORE.PLAYER+2,y
	lda adr.SCORE.PLAYER+3,y
	adc #$00
	sta adr.SCORE.PLAYER+3,y

; optimize OK (service.pas), line = 2029

	ldy I
	lda #$00
	sta adr.WALL,y

; optimize OK (service.pas), line = 2030

	lda #$B8
	sta BALL_BLOCK_SOUND.A
	lda #$01
	sta BALL_BLOCK_SOUND.A+1
	lda #$03
	jmp l_1B17
l_1AEF

; optimize OK (service.pas), line = 2035

	ldy I
	lda adr.WALL,y
	and #$0F
	cmp #$09
	jne l_1B30

; optimize OK (service.pas), line = 2037

	lda adr.WALL,y
	sub #$10
	sta adr.WALL,y

; optimize OK (service.pas), line = 2038

	lda #$72
	sta BALL_BLOCK_SOUND.A
	lda #$01
	sta BALL_BLOCK_SOUND.A+1
	lda #$04
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND

; optimize OK (service.pas), line = 2039

	lda XB
	sta SHINE.XB
	lda YB
	sta SHINE.YB
	jsr SHINE
	jmp l_1B46
l_1B30

; optimize OK (service.pas), line = 2043

	lda XB
	sta SHINE.XB
	lda YB
	sta SHINE.YB
	jsr SHINE

; optimize OK (service.pas), line = 2044

	lda #$C8
	sta BALL_BLOCK_SOUND.A
	lda #$00
	sta BALL_BLOCK_SOUND.A+1
	lda #$07
l_1B17
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND
l_1B46
l_1AD9
l_1AB5

; ------------------------------------------------------------

XB	= DATAORIGIN+$0344
YB	= DATAORIGIN+$0346
I	= DATAORIGIN+$0348

@VarData	= XB
@VarDataSize	= 5

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BALL_HIT_BLOCK					; PROCEDURE

; optimize OK (service.pas), line = 2078

	lda #$FF
	sta EMERGENCY

; optimize OK (service.pas), line = 2080

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda (:bp2),y
	sub #$09
	sta NX
	iny
	lda (:bp2),y
	sbc #$00
	sta NX+1

; optimize OK (service.pas), line = 2081

	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	sub #$16
	sta NY
	iny
	lda (:bp2),y
	sbc #$00
	sta NY+1

; optimize OK (service.pas), line = 2084

	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	sub #$09
	sta OX
	iny
	lda (:bp2),y
	sbc #$00
	sta OX+1

; optimize OK (service.pas), line = 2085

	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	sub #$16
	sta OY
	iny
	lda (:bp2),y
	sbc #$00
	sta OY+1

; optimize OK (service.pas), line = 2087

	lda NX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda NX
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta XB

; optimize OK (service.pas), line = 2088

	lda NY+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda NY
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta YB

; optimize OK (service.pas), line = 2092

	lda #$10
	sta :ecx
	sta :ztmp8
	lda YB
	sta :eax
	sta :ztmp10
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	bit :ztmp10
	bpl @+
	sub :ztmp8
@
	bit :ztmp8
	bpl @+
	sub :ztmp10
@
	sta :eax+1
	lda :eax
	add XB
	tay
	lda adr.WALL,y
	jeq l_1BAF

; optimize OK (service.pas), line = 2094

	lda <OX
	sta SPLIT_LINE.X1
	lda >OX
	sta SPLIT_LINE.X1+1
	lda <OY
	sta SPLIT_LINE.Y1
	lda >OY
	sta SPLIT_LINE.Y1+1
	lda <NX
	sta SPLIT_LINE.X2
	lda >NX
	sta SPLIT_LINE.X2+1
	lda <NY
	sta SPLIT_LINE.Y2
	lda >NY
	sta SPLIT_LINE.Y2+1
	jsr SPLIT_LINE
	lda SPLIT_LINE.RESULT
	sta COLLISION

; optimize OK (service.pas), line = 2100

	cmp #$03
	jne l_1BCA

; optimize OK (service.pas), line = 2102

	mwy BALL :bp2
	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	iny
	sub OX
	sub #$09
	sta LX

; optimize OK (service.pas), line = 2103

	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	iny
	sub OY
	sub #$16
	sta LY

; optimize OK (service.pas), line = 2105

	ldy #BALL.OLDX-DATAORIGIN
	lda (:bp2),y
	sub NX
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sbc NX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	sub #$09
	sta MX
	lda :STACKORIGIN+STACKWIDTH+9
	sbc #$00
	sta MX+1

; optimize OK (service.pas), line = 2106

	ldy #BALL.OLDY-DATAORIGIN
	lda (:bp2),y
	sub NY
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sbc NY+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda :STACKORIGIN+9
	sub #$16
	sta MY
	lda :STACKORIGIN+STACKWIDTH+9
	sbc #$00
	sta MY+1

; optimize OK (service.pas), line = 2108

	lda LX
	jsr SYSTEM.ABS.@010183000
	lda SYSTEM.ABS.@010183000.RESULT
	sta A
	lda LY
	jsr SYSTEM.ABS.@010183000
	lda SYSTEM.ABS.@010183000.RESULT
	sta B

; optimize OK (service.pas), line = 2110

	lda A
	sta :ecx
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta :STACKORIGIN+9
	lda :eax+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda B
	sta :ecx
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	add :STACKORIGIN+9
	sta F1
	lda :eax+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta F1+1

; optimize OK (service.pas), line = 2112

	lda MX
	sta SYSTEM.ABS.@010184000.X
	lda MX+1
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	lda SYSTEM.ABS.@010184000.RESULT
	sta A
	lda MY
	sta SYSTEM.ABS.@010184000.X
	lda MY+1
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	lda SYSTEM.ABS.@010184000.RESULT
	sta B

; optimize OK (service.pas), line = 2114

	lda A
	sta :ecx
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta :STACKORIGIN+9
	lda :eax+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda B
	sta :ecx
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	add :STACKORIGIN+9
	sta F2
	lda :eax+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta F2+1

; optimize OK (service.pas), line = 2116

	lda F1+1
	cmp F2+1
	bne @+
	lda F1
	cmp F2
@
	jcs l_1C5F

; optimize OK (service.pas), line = 2122

	lda OX+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda OX
	lsr :STACKORIGIN+STACKWIDTH+10
	ror @
	lsr :STACKORIGIN+STACKWIDTH+10
	ror @
	lsr :STACKORIGIN+STACKWIDTH+10
	ror @
	lsr :STACKORIGIN+STACKWIDTH+10
	ror @
	sta MAX.A
	lda :STACKORIGIN+STACKWIDTH+10
	sta MAX.A+1
	lda #$00
	sta MAX.B
	sta MAX.B+1
	jsr MAX
	lda #$0C
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda MAX.RESULT
	sta MIN.B
	lda MAX.RESULT+1
	sta MIN.B+1
	jsr MIN
	lda MIN.RESULT
	sta XB

; optimize OK (service.pas), line = 2123

	lda OY
	add #$18
	lsr @
	lsr @
	lsr @
	sub #$03
	sta YB

; optimize OK (service.pas), line = 2126

	lda #$10
	sta :ecx
	sta :ztmp8
	lda YB
	sta :eax
	sta :ztmp10
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	bit :ztmp10
	bpl @+
	sub :ztmp8
@
	bit :ztmp8
	bpl @+
	sub :ztmp10
@
	sta :eax+1
	lda :eax
	add XB
	tay
	lda adr.WALL,y
	jne l_1C9D

; optimize OK (service.pas), line = 2128

	lda NX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda NX
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta MAX.B
	lda #$00
	sta MAX.A
	sta MAX.A+1
	lda :STACKORIGIN+STACKWIDTH+9
	sta MAX.B+1
	jsr MAX
	lda #$0C
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda MAX.RESULT
	sta MIN.B
	lda MAX.RESULT+1
	sta MIN.B+1
	jsr MIN
	lda MIN.RESULT
	sta XB

; optimize OK (service.pas), line = 2129

	lda NY
	add #$18
	lsr @
	lsr @
	lsr @
	sub #$03
	sta YB
	jmp l_1CC5
l_1C9D

; optimize OK (service.pas), line = 2133

	lda OX
	sta NX
	lda OX+1
	sta NX+1

; optimize OK (service.pas), line = 2134

	lda OY
	sta NY
	lda OY+1
	sta NY+1
l_1CC5
	jmp l_1CD8
l_1C5F

; optimize OK (service.pas), line = 2144

	lda NX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda NX
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta MAX.B
	lda #$00
	sta MAX.A
	sta MAX.A+1
	lda :STACKORIGIN+STACKWIDTH+9
	sta MAX.B+1
	jsr MAX
	lda #$0C
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda MAX.RESULT
	sta MIN.B
	lda MAX.RESULT+1
	sta MIN.B+1
	jsr MIN
	lda MIN.RESULT
	sta XB

; optimize OK (service.pas), line = 2145

	lda NY
	add #$18
	lsr @
	lsr @
	lsr @
	sub #$03
	sta YB

; optimize OK (service.pas), line = 2147

	lda #$10
	sta :ecx
	sta :ztmp8
	lda YB
	sta :eax
	sta :ztmp10
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	bit :ztmp10
	bpl @+
	sub :ztmp8
@
	bit :ztmp8
	bpl @+
	sub :ztmp10
@
	sta :eax+1
	lda :eax
	add XB
	tay
	lda adr.WALL,y
	jne l_1D15

; optimize OK (service.pas), line = 2149

	lda OX
	sta NX
	lda OX+1
	sta NX+1

; optimize OK (service.pas), line = 2150

	lda OY
	sta NY
	lda OY+1
	sta NY+1

; optimize OK (service.pas), line = 2152

	lda NX+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda NX
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	lsr :STACKORIGIN+STACKWIDTH+9
	ror @
	sta MAX.B
	lda #$00
	sta MAX.A
	sta MAX.A+1
	lda :STACKORIGIN+STACKWIDTH+9
	sta MAX.B+1
	jsr MAX
	lda #$0C
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda MAX.RESULT
	sta MIN.B
	lda MAX.RESULT+1
	sta MIN.B+1
	jsr MIN
	lda MIN.RESULT
	sta XB

; optimize OK (service.pas), line = 2153

	lda NY
	add #$18
	lsr @
	lsr @
	lsr @
	sub #$03
	sta YB
l_1D15
l_1CD8
l_1BCA

; optimize OK (service.pas), line = 2159

	mwy BALL :bp2
	ldy #BALL.X-DATAORIGIN
	lda NX
	add #$09
	sta (:bp2),y
	iny
	lda NX+1
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 2160

	ldy #BALL.Y-DATAORIGIN
	lda NY
	add #$16
	sta (:bp2),y
	iny
	lda NY+1
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 2164

	ldy #$00
	lda YB
	spl
	dey
	sty SHOOT_BLOCK.YB+1
	sta SHOOT_BLOCK.YB
	ldy #$00
	lda XB
	spl
	dey
	sty SHOOT_BLOCK.XB+1
	sta SHOOT_BLOCK.XB
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK

; optimize OK (service.pas), line = 2166

	lda NX
	and #$0F
	sta :STACKORIGIN+9
	lda #$00
	lsr @
	ror :STACKORIGIN+9
	lda :STACKORIGIN+9
	sta X

; optimize OK (service.pas), line = 2167

	lda NY
	and #$07
	sta Y

; optimize OK (service.pas), line = 2179

	lda X
	jeq l_1DA9
	cmp #$07
	jeq l_1DA9
	lda Y
	jeq l_1DA9
	cmp #$07
	jeq l_1DA9

; optimize OK (service.pas), line = 2180

	lda #$03
	jsr FATAL_ERROR
l_1DA9

; optimize OK (service.pas), line = 2195

	lda Y
	sub X
	svc
	eor #$80
	jpl l_1DD4
	lda #$07
	sub Y
	sta :STACKORIGIN+11
	lda X
	sub :STACKORIGIN+11
	svc
	eor #$80
	jpl l_1DD4

; optimize OK (service.pas), line = 2197

	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDY-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 2198

	lda #$01
	sta EMERGENCY
l_1DD4

; optimize OK (service.pas), line = 2202

	lda #$07
	sub Y
	sub X
	svc
	eor #$80
	jpl l_1E09
	lda X
	sub Y
	svc
	eor #$80
	jpl l_1E09

; optimize OK (service.pas), line = 2204

	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDY-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 2205

	lda #$03
	sta EMERGENCY
l_1E09

; optimize OK (service.pas), line = 2209

	lda X
	sub Y
	svc
	eor #$80
	jpl l_1E3E
	lda #$07
	sub X
	sta :STACKORIGIN+11
	lda Y
	sub :STACKORIGIN+11
	svc
	eor #$80
	jpl l_1E3E

; optimize OK (service.pas), line = 2211

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 2212

	lda #$02
	sta EMERGENCY
l_1E3E

; optimize OK (service.pas), line = 2216

	lda #$07
	sub X
	sub Y
	svc
	eor #$80
	jpl l_1E73
	lda Y
	sub X
	svc
	eor #$80
	jpl l_1E73

; optimize OK (service.pas), line = 2218

	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y

; optimize OK (service.pas), line = 2219

	lda #$04
	sta EMERGENCY
l_1E73

; optimize OK (service.pas), line = 2223

	lda X
	cmp Y
	jeq l_1EA8x
	lda #$07
	sub Y
	cmp X
	jne l_1EA8
l_1EA8x

; optimize OK (service.pas), line = 2225

	lda #$00
	sta DEFLECT

; optimize OK (service.pas), line = 2226

	sta TOUCH

; optimize OK (service.pas), line = 2234

	lda X
	sub #$05
	svc
	eor #$80
	jmi l_1EC3
	lda TOUCH
	ora #$01
	sta TOUCH
l_1EC3

; optimize OK (service.pas), line = 2235

	lda Y
	sub #$05
	svc
	eor #$80
	jmi l_1EE2
	lda TOUCH
	ora #$02
	sta TOUCH
l_1EE2

; optimize OK (service.pas), line = 2244

	lda #$FF
	sta LX

l_1EF8
; --- ForToDoCondition
	lda LX
	sub #$02
	svc
	eor #$80
	asl @
	jcc l_1F06

; optimize OK (service.pas), line = 2245

	lda #$FF
	sta LY

l_1F0F
; --- ForToDoCondition
	lda LY
	sub #$02
	svc
	eor #$80
	asl @
	jcc l_1F1D

; optimize FAIL (1, service.pas), line = 2247

	inx
	mva #$00 :STACKORIGIN,x
	sta :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$0C :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva XB :STACKORIGIN,x
	inx
	mva LX :STACKORIGIN,x
	jsr @expandSHORT2SMALL1
	jsr @expandSHORT2SMALL
	jsr addAX_CX
	dex
	lda :STACKORIGIN,x
	sta MIN.A
	lda :STACKORIGIN+STACKWIDTH,x
	sta MIN.A+1
	dex
	lda :STACKORIGIN,x
	sta MIN.B
	lda :STACKORIGIN+STACKWIDTH,x
	sta MIN.B+1
	dex
	jsr MIN
	lda MIN.RESULT
	sta MAX.A
	lda MIN.RESULT+1
	sta MAX.A+1
	lda :STACKORIGIN,x
	sta MAX.B
	lda :STACKORIGIN+STACKWIDTH,x
	sta MAX.B+1
	dex
	jsr MAX
	lda MAX.RESULT
	sta MX
	lda MAX.RESULT+1
	sta MX+1

; optimize OK (service.pas), line = 2248

	ldy #$00
	lda YB
	spl
	dey
	sty :STACKORIGIN+STACKWIDTH+9
	sta :STACKORIGIN+9
	ldy #$00
	lda LY
	spl
	dey
	add :STACKORIGIN+9
	sta MY
	tya
	adc :STACKORIGIN+STACKWIDTH+9
	sta MY+1

; optimize OK (service.pas), line = 2252

	lda XB
	add LX
	jmi l_1F7Ax
	lda XB
	add LX
	sub #$0D
	svc
	eor #$80
	jpl l_1F7Ax
	lda MY
	asl @
	asl @
	asl @
	asl @
	add MX
	tay
	lda adr.WALL,y
	jeq l_1F7A
l_1F7Ax

; optimize OK (service.pas), line = 2255

	ldy #$00
	lda LX
	spl
	dey
	add #$01
	sta :eax
	scc
	iny
	sty :eax+1
	lda #$03
	sta :ecx
	lda #$00
	sta :ecx+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	ldy :eax
	lda #$01
	jmp l_1F9D
l_1F7A

; optimize OK (service.pas), line = 2257

	ldy #$00
	lda LX
	spl
	dey
	add #$01
	sta :eax
	scc
	iny
	sty :eax+1
	lda #$03
	sta :ecx
	lda #$00
	sta :ecx+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	ldy :eax
	lda #$00
l_1F9D
	sta adr.ADJW+$01,y

; --- ForToDoEpilog
	inc LY
	lda LY
	cmp #$80
	jne l_1F0F
l_1F1D

; --- ForToDoEpilog
	inc LX
	lda LX
	cmp #$80
	jne l_1EF8
l_1F06

; optimize OK (service.pas), line = 2276

	lda adr.ADJW
	sta :STACKORIGIN+9
	lda adr.ADJW+$03
	asl @
	ora :STACKORIGIN+9
	sta :STACKORIGIN+9
	lda adr.ADJW+$06
	asl @
	asl @
	ora :STACKORIGIN+9
	sta :STACKORIGIN+9
	lda adr.ADJW+$07
	asl @
	asl @
	asl @
	ora :STACKORIGIN+9
	sta :STACKORIGIN+9
	lda adr.ADJW+$08
	asl @
	asl @
	asl @
	asl @
	ora :STACKORIGIN+9
	sta :STACKORIGIN+9
	lda adr.ADJW+$05
	asl @
	asl @
	asl @
	asl @
	asl @
	ora :STACKORIGIN+9
	sta :STACKORIGIN+9
	lda adr.ADJW+$02
	asl @
	asl @
	asl @
	asl @
	asl @
	asl @
	ora :STACKORIGIN+9
	sta :STACKORIGIN+9
	lda adr.ADJW+$01
	asl @
	asl @
	asl @
	asl @
	asl @
	asl @
	asl @
	ora :STACKORIGIN+9
	sta AROUND

; optimize OK (service.pas), line = 2307

	lda TOUCH
	jne l_2046

; optimize OK (service.pas), line = 2309

	lda AROUND
	and #$83
	jne l_205D
	lda #$11
	sta DEFLECT
l_205D

; optimize OK (service.pas), line = 2310

	lda AROUND
	and #$83
	cmp #$01
	jne l_207A
	lda #$33
	sta DEFLECT
l_207A

; optimize OK (service.pas), line = 2311

	lda AROUND
	and #$83
	cmp #$02
	jne l_2097
	lda #$10
	sta DEFLECT
l_2097

; optimize OK (service.pas), line = 2312

	lda AROUND
	and #$83
	cmp #$03
	jne l_20B4
	lda #$12
	sta DEFLECT
l_20B4

; optimize OK (service.pas), line = 2313

	lda AROUND
	and #$83
	cmp #$80
	jne l_20D1
	lda #$01
	sta DEFLECT
l_20D1

; optimize OK (service.pas), line = 2314

	lda AROUND
	and #$83
	cmp #$81
	jne l_20EE
	lda #$21
	sta DEFLECT
l_20EE

; optimize OK (service.pas), line = 2315

	lda AROUND
	and #$83
	cmp #$82
	jne l_210B
	lda #$11
	sta DEFLECT
l_210B

; optimize OK (service.pas), line = 2317

	lda #$05
	sta EMERGENCY

; optimize OK (service.pas), line = 2318

	ldy #$00
	lda YB
	spl
	dey
	sub #$01
	sta SHOOT_BLOCK.YB
	tya
	sbc #$00
	sta SHOOT_BLOCK.YB+1
	ldy #$00
	lda XB
	spl
	dey
	sub #$01
	sta SHOOT_BLOCK.XB
	tya
	sbc #$00
	sta SHOOT_BLOCK.XB+1
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_2046

; optimize OK (service.pas), line = 2323

	lda TOUCH
	cmp #$01
	jne l_213B

; optimize OK (service.pas), line = 2325

	lda AROUND
	and #$0E
	jne l_2152
	lda #$21
	sta DEFLECT
l_2152

; optimize OK (service.pas), line = 2326

	lda AROUND
	and #$0E
	cmp #$02
	jne l_216F
	lda #$20
	sta DEFLECT
l_216F

; optimize OK (service.pas), line = 2327

	lda AROUND
	and #$0E
	cmp #$04
	jne l_218C
	lda #$33
	sta DEFLECT
l_218C

; optimize OK (service.pas), line = 2328

	lda AROUND
	and #$0E
	cmp #$06
	jne l_21A9
	lda #$22
	sta DEFLECT
l_21A9

; optimize OK (service.pas), line = 2329

	lda AROUND
	and #$0E
	cmp #$08
	jne l_21C6
	lda #$01
	sta DEFLECT
l_21C6

; optimize OK (service.pas), line = 2330

	lda AROUND
	and #$0E
	cmp #$0A
	jne l_21E3
	lda #$21
	sta DEFLECT
l_21E3

; optimize OK (service.pas), line = 2331

	lda AROUND
	and #$0E
	cmp #$0C
	jne l_2200
	lda #$11
	sta DEFLECT
l_2200

; optimize OK (service.pas), line = 2333

	lda #$08
	sta EMERGENCY

; optimize OK (service.pas), line = 2334

	ldy #$00
	lda YB
	spl
	dey
	sub #$01
	sta SHOOT_BLOCK.YB
	tya
	sbc #$00
	sta SHOOT_BLOCK.YB+1
	ldy #$00
	lda XB
	spl
	dey
	add #$01
	sta SHOOT_BLOCK.XB
	scc
	iny
	sty SHOOT_BLOCK.XB+1
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_213B

; optimize OK (service.pas), line = 2337

	lda TOUCH
	cmp #$02
	jne l_2230

; optimize OK (service.pas), line = 2339

	lda AROUND
	and #$E0
	jne l_2247
	lda #$12
	sta DEFLECT
l_2247

; optimize OK (service.pas), line = 2340

	lda AROUND
	and #$E0
	cmp #$20
	jne l_2264
	lda #$10
	sta DEFLECT
l_2264

; optimize OK (service.pas), line = 2341

	lda AROUND
	and #$E0
	cmp #$40
	jne l_2281
	lda #$33
	sta DEFLECT
l_2281

; optimize OK (service.pas), line = 2342

	lda AROUND
	and #$E0
	cmp #$60
	jne l_229E
	lda #$11
	sta DEFLECT
l_229E

; optimize OK (service.pas), line = 2343

	lda AROUND
	and #$E0
	cmp #$80
	jne l_22BB
	lda #$02
	sta DEFLECT
l_22BB

; optimize OK (service.pas), line = 2344

	lda AROUND
	and #$E0
	cmp #$A0
	jne l_22D8
	lda #$12
	sta DEFLECT
l_22D8

; optimize OK (service.pas), line = 2345

	lda AROUND
	and #$E0
	cmp #$C0
	jne l_22F5
	lda #$22
	sta DEFLECT
l_22F5

; optimize OK (service.pas), line = 2347

	lda #$06
	sta EMERGENCY

; optimize OK (service.pas), line = 2348

	ldy #$00
	lda YB
	spl
	dey
	add #$01
	sta SHOOT_BLOCK.YB
	scc
	iny
	sty SHOOT_BLOCK.YB+1
	ldy #$00
	lda XB
	spl
	dey
	sub #$01
	sta SHOOT_BLOCK.XB
	tya
	sbc #$00
	sta SHOOT_BLOCK.XB+1
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_2230

; optimize OK (service.pas), line = 2351

	lda TOUCH
	cmp #$03
	jne l_2325

; optimize OK (service.pas), line = 2353

	lda AROUND
	and #$38
	jne l_233C
	lda #$22
	sta DEFLECT
l_233C

; optimize OK (service.pas), line = 2354

	lda AROUND
	and #$38
	cmp #$08
	jne l_2359
	lda #$02
	sta DEFLECT
l_2359

; optimize OK (service.pas), line = 2355

	lda AROUND
	and #$38
	cmp #$10
	jne l_2376
	lda #$33
	sta DEFLECT
l_2376

; optimize OK (service.pas), line = 2356

	lda AROUND
	and #$38
	cmp #$18
	jne l_2393
	lda #$12
	sta DEFLECT
l_2393

; optimize OK (service.pas), line = 2357

	lda AROUND
	and #$38
	cmp #$20
	jne l_23B0
	lda #$20
	sta DEFLECT
l_23B0

; optimize OK (service.pas), line = 2358

	lda AROUND
	and #$38
	cmp #$28
	jne l_23CD
	lda #$22
	sta DEFLECT
l_23CD

; optimize OK (service.pas), line = 2359

	lda AROUND
	and #$38
	cmp #$30
	jne l_23EA
	lda #$21
	sta DEFLECT
l_23EA

; optimize OK (service.pas), line = 2361

	lda #$07
	sta EMERGENCY

; optimize OK (service.pas), line = 2362

	ldy #$00
	lda YB
	spl
	dey
	add #$01
	sta SHOOT_BLOCK.YB
	scc
	iny
	sty SHOOT_BLOCK.YB+1
	ldy #$00
	lda XB
	spl
	dey
	add #$01
	sta SHOOT_BLOCK.XB
	scc
	iny
	sty SHOOT_BLOCK.XB+1
	lda BALL
	sta SHOOT_BLOCK.BALL
	lda BALL+1
	sta SHOOT_BLOCK.BALL+1
	jsr SHOOT_BLOCK
l_2325

; optimize OK (service.pas), line = 2368

	lda DEFLECT
	lsr @
	lsr @
	lsr @
	lsr @
	sta MYX
	lda #$00
	sta MYX+1

; optimize OK (service.pas), line = 2369

	lda DEFLECT
	and #$0F
	sta MYY
	lda #$00
	sta MYY+1

; optimize OK (service.pas), line = 2371

	lda MYX+1
	bne @+
	lda MYX
	cmp #$01
@
	jne l_242D
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda (:bp2),y
	sta SYSTEM.ABS.@010184000.X
	iny
	lda (:bp2),y
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	inx
	mva SYSTEM.ABS.@010184000.RESULT :STACKORIGIN,x
	mva SYSTEM.ABS.@010184000.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	lda #$00
	sub :STACKORIGIN,x
	sta :STACKORIGIN,x
	lda #$00
	sbc :STACKORIGIN+STACKWIDTH,x
	sta :STACKORIGIN+STACKWIDTH,x
	lda #$00
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH*2,x
	lda #$00
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH*3,x
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :STACKORIGIN,x
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH,x
	sta (:bp2),y
	dex
l_242D

; optimize OK (service.pas), line = 2372

	lda MYX+1
	bne @+
	lda MYX
	cmp #$02
@
	jne l_244A
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda (:bp2),y
	sta SYSTEM.ABS.@010184000.X
	iny
	lda (:bp2),y
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda SYSTEM.ABS.@010184000.RESULT
	sta (:bp2),y
	iny
	lda SYSTEM.ABS.@010184000.RESULT+1
	sta (:bp2),y
l_244A

; optimize OK (service.pas), line = 2373

	lda MYX+1
	bne @+
	lda MYX
	cmp #$03
@
	jne l_2464
	mwy BALL :bp2
	ldy #BALL.SPEEDX-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDX-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y
l_2464

; optimize OK (service.pas), line = 2375

	lda MYY+1
	bne @+
	lda MYY
	cmp #$01
@
	jne l_2480
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta SYSTEM.ABS.@010184000.X
	iny
	lda (:bp2),y
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	inx
	mva SYSTEM.ABS.@010184000.RESULT :STACKORIGIN,x
	mva SYSTEM.ABS.@010184000.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	lda #$00
	sub :STACKORIGIN,x
	sta :STACKORIGIN,x
	lda #$00
	sbc :STACKORIGIN+STACKWIDTH,x
	sta :STACKORIGIN+STACKWIDTH,x
	lda #$00
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH*2,x
	lda #$00
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH*3,x
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda :STACKORIGIN,x
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH,x
	sta (:bp2),y
	dex
l_2480

; optimize OK (service.pas), line = 2376

	lda MYY+1
	bne @+
	lda MYY
	cmp #$02
@
	jne l_249D
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda (:bp2),y
	sta SYSTEM.ABS.@010184000.X
	iny
	lda (:bp2),y
	sta SYSTEM.ABS.@010184000.X+1
	jsr SYSTEM.ABS.@010184000
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda SYSTEM.ABS.@010184000.RESULT
	sta (:bp2),y
	iny
	lda SYSTEM.ABS.@010184000.RESULT+1
	sta (:bp2),y
l_249D

; optimize OK (service.pas), line = 2377

	lda MYY+1
	bne @+
	lda MYY
	cmp #$03
@
	jne l_24B7
	mwy BALL :bp2
	ldy #BALL.SPEEDY-DATAORIGIN
	lda #$00
	sub (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda #$00
	sbc (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	ldy #BALL.SPEEDY-DATAORIGIN
	lda :STACKORIGIN+9
	sta (:bp2),y
	iny
	lda :STACKORIGIN+STACKWIDTH+9
	sta (:bp2),y
l_24B7
l_1EA8
l_1BAF

; optimize OK (service.pas), line = 2387

	mwy BALL :bp2
	ldy #BALL.BRWHIT-DATAORIGIN
	lda (:bp2),y
	cmp #$65
	jcc l_24D8

; optimize OK (service.pas), line = 2390

	lda EMERGENCY
	cmp #$FF
	jne l_24EB
	lda #$04
	jsr FATAL_ERROR
l_24EB

; optimize OK (service.pas), line = 2392

	ldy EMERGENCY
	lda adr.EMERG_DEV,y
	sta MIMAX

; optimize OK (service.pas), line = 2418

	tya
	sta @CASETMP_0009
	cmp #$05
	jne l_2504
@

; optimize OK (service.pas), line = 2421

	lda adr.ADJW+$03
	jne l_251B
	lda MIMAX
	and #$0F
	sta MIMAX
l_251B

; optimize OK (service.pas), line = 2422

	lda adr.ADJW+$01
	jne l_2543
	lda MIMAX
	and #$F0
	ora #$03
	sta MIMAX
l_2543
	jmp a_0009
l_2504
	cmp #$06
	jne l_255B

; optimize OK (service.pas), line = 2426

	lda adr.ADJW+$01
	jne l_2572
	lda MIMAX
	and #$0F
	ora #$10
	sta MIMAX
l_2572

; optimize OK (service.pas), line = 2427

	lda adr.ADJW+$05
	jne l_259A
	lda MIMAX
	and #$F0
	ora #$04
	sta MIMAX
l_259A
	jmp a_0009
l_255B
	cmp #$07
	jne l_25B2

; optimize OK (service.pas), line = 2431

	lda adr.ADJW+$05
	jne l_25C9
	lda MIMAX
	and #$0F
	ora #$20
	sta MIMAX
l_25C9

; optimize OK (service.pas), line = 2432

	lda adr.ADJW+$07
	jne l_25F1
	lda MIMAX
	and #$F0
	ora #$05
	sta MIMAX
l_25F1
	jmp a_0009
l_25B2
	cmp #$08
	jne l_2609

; optimize OK (service.pas), line = 2436

	lda adr.ADJW+$07
	jne l_2620
	lda MIMAX
	and #$0F
	ora #$30
	sta MIMAX
l_2620

; optimize OK (service.pas), line = 2437

	lda adr.ADJW+$03
	jne l_2648
	lda MIMAX
	and #$F0
	ora #$06
	sta MIMAX
l_2648
l_2609
a_0009

; --- RepeatUntilProlog
l_2660

; optimize OK (service.pas), line = 2444

	lda MIMAX
	lsr @
	lsr @
	lsr @
	lsr @
	sta :ecx
	lda #$5A
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	lda :eax
	sta LX

; optimize OK (service.pas), line = 2445

	lda MIMAX
	and #$0F
	sta :ecx
	lda #$5A
	sta :eax
	.ifdef fmulinit
	fmulu_8
	els
	imulCL
	eif
	sta MX+1
	lda :eax
	sta MX

; optimize OK (service.pas), line = 2447

	ldy #$00
	lda LX
	spl
	dey
	sty :STACKORIGIN+STACKWIDTH+10
	sta :STACKORIGIN+10
	lda MX
	sub :STACKORIGIN+10
	sta SYSTEM.RANDOM.@010184000.RANGE
	lda MX+1
	sbc :STACKORIGIN+STACKWIDTH+10
	sta SYSTEM.RANDOM.@010184000.RANGE+1
	jsr SYSTEM.RANDOM.@010184000
	inx
	mva SYSTEM.RANDOM.@010184000.RESULT :STACKORIGIN,x
	mva SYSTEM.RANDOM.@010184000.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	inx
	mva LX :STACKORIGIN,x
	jsr @expandSHORT2SMALL
	jsr addAX_CX
	dex
	lda :STACKORIGIN,x
	sta ANGLE
	lda :STACKORIGIN+STACKWIDTH,x
	sta ANGLE+1
	dex

; optimize OK (service.pas), line = 2452

	lda #$5A
	sta @SMALLINT.MOD.B
	lda #$00
	sta @SMALLINT.MOD.B+1
	lda ANGLE
	sta @SMALLINT.MOD.A
	lda ANGLE+1
	sta @SMALLINT.MOD.A+1
	jsr @SMALLINT.MOD
	lda @SMALLINT.MOD.RESULT
	cmp #$1F
	lda @SMALLINT.MOD.RESULT+1
	sbc #$00
	svc
	eor #$80
	jmi l_2660
	lda #$5A
	sta @SMALLINT.MOD.B
	lda #$00
	sta @SMALLINT.MOD.B+1
	lda ANGLE
	sta @SMALLINT.MOD.A
	lda ANGLE+1
	sta @SMALLINT.MOD.A+1
	jsr @SMALLINT.MOD
	lda @SMALLINT.MOD.RESULT
	cmp #$3C
	lda @SMALLINT.MOD.RESULT+1
	sbc #$00
	svc
	eor #$80
	jpl l_2660

; optimize OK (service.pas), line = 2456

	lda #$68
	sta @SMALLINT.MOD.B
	lda #$01
	sta @SMALLINT.MOD.B+1
	lda ANGLE
	sta @SMALLINT.MOD.A
	lda ANGLE+1
	sta @SMALLINT.MOD.A+1
	jsr @SMALLINT.MOD
	lda @SMALLINT.MOD.RESULT
	sta SET_BALL_DIRECTION.ANGLE
	lda @SMALLINT.MOD.RESULT+1
	sta SET_BALL_DIRECTION.ANGLE+1
	lda BALL
	sta SET_BALL_DIRECTION.BALL
	lda BALL+1
	sta SET_BALL_DIRECTION.BALL+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 2457

	mwy BALL :bp2
	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED
	iny
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED+1
	lda BALL
	sta SET_BALL_SPEED.BALL
	lda BALL+1
	sta SET_BALL_SPEED.BALL+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 2459

	mwy BALL :bp2
	ldy #BALL.BRWHIT-DATAORIGIN
	lda #$00
	sta (:bp2),y
l_24D8

; ------------------------------------------------------------

BALL	= DATAORIGIN+$0349
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B
X	= DATAORIGIN+$034D
Y	= DATAORIGIN+$034E
LX	= DATAORIGIN+$034F
LY	= DATAORIGIN+$0350
XB	= DATAORIGIN+$0351
YB	= DATAORIGIN+$0352
OX	= DATAORIGIN+$0353
OY	= DATAORIGIN+$0355
NX	= DATAORIGIN+$0357
NY	= DATAORIGIN+$0359
MX	= DATAORIGIN+$035B
MY	= DATAORIGIN+$035D
ANGLE	= DATAORIGIN+$035F
MYX	= DATAORIGIN+$0361
MYY	= DATAORIGIN+$0363
F1	= DATAORIGIN+$0365
F2	= DATAORIGIN+$0367
A	= DATAORIGIN+$0369
B	= DATAORIGIN+$036A
EMERGENCY	= DATAORIGIN+$036B
MIMAX	= DATAORIGIN+$036C
DEFLECT	= DATAORIGIN+$036D
AROUND	= DATAORIGIN+$036E
COLLISION	= DATAORIGIN+$036F
TOUCH	= DATAORIGIN+$0370
adr.ADJW	= [DATAORIGIN+$0371] .array [3] [3]
.var ADJW	= adr.ADJW .word
@CASETMP_0009	= DATAORIGIN+$037A

@VarData	= BALL
@VarDataSize	= 42

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	FILL_PICTURE_WITH_PATTERN			; PROCEDURE

; optimize OK (service.pas), line = 2474

	lda #$00
	sta Y

l_26CE
; --- ForToDoCondition
	mwy PATT :bp2
	ldy #PATT.WIDTH-DATAORIGIN
	lda (:bp2),y
	sta @WORD.MOD.B
	iny
	lda (:bp2),y
	sta @WORD.MOD.B+1
	lda Y
	sta @WORD.MOD.A
	lda #$00
	sta @WORD.MOD.A+1
	jsr @WORD.MOD
	lda @WORD.MOD.RESULT
	ldy Y
	sta adr.MODX,y

; optimize OK (service.pas), line = 2480

	mwy PATT :bp2
	ldy #PATT.HEIGHT-DATAORIGIN
	lda (:bp2),y
	sta @WORD.MOD.B
	iny
	lda (:bp2),y
	sta @WORD.MOD.B+1
	lda Y
	sta @WORD.MOD.A
	lda #$00
	sta @WORD.MOD.A+1
	jsr @WORD.MOD
	lda @WORD.MOD.RESULT
	ldy Y
	sta adr.MODY,y

; --- ForToDoEpilog
	inc Y
	jne l_26CE
l_26DC

; optimize OK (service.pas), line = 2486

	lda #$0A
	sta Y

l_2706
; --- ForToDoCondition
	ldy Y
	cpy #$C7
	jcs l_2714

; optimize OK (service.pas), line = 2489

	lda adr.MODY,y
	sta :eax
	mwy PATT :bp2
	ldy #PATT.WIDTH-DATAORIGIN
	lda (:bp2),y
	sta :ecx
	iny
	lda (:bp2),y
	sta :ecx+1
	lda #$00
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	sta YB
	lda :eax+1
	sta YB+1

; optimize OK (service.pas), line = 2491

	ldy #PATT.OFS-DATAORIGIN
	lda (:bp2),y
	add YB
	sta VBXE_RAM.POSITION
	iny
	lda (:bp2),y
	adc YB+1
	sta VBXE_RAM.POSITION+1
	iny
	lda (:bp2),y
	adc #$00
	sta VBXE_RAM.POSITION+2
	iny
	lda (:bp2),y
	adc #$00
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 2492

	lda SCANLINE
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER
	lda SCANLINE+1
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER+1
	lda #$28
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT
	lda #$00
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT+1
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.READBUFFER

; optimize OK (service.pas), line = 2494

	lda #$00
	sta K

; optimize OK (service.pas), line = 2495

	lda #$09
	sta X

l_273C
; --- ForToDoCondition
	ldy X
	cpy #$D8
	jcs l_274A

; optimize OK (service.pas), line = 2500

	lda adr.MODX,y
	tay
	lda adr.SCANLINE,y
	sta CL

; optimize OK (service.pas), line = 2502

	lda #$80
	sta SHADOW

; optimize OK (service.pas), line = 2507

	lda Y
	cmp #$10
	jcc l_2778x
	lda X
	cmp #$12
	jcs l_2778
l_2778x
	lda #$00
	sta SHADOW
l_2778

; optimize OK (service.pas), line = 2512

	lda CL
	and #$7F
	ora SHADOW
	ldy K
	sta adr.TMP,y

; optimize FAIL (0, service.pas), line = 2514

	inc K

; --- ForToDoEpilog
	inc X
	jne l_273C
l_274A

; optimize OK (service.pas), line = 2517

	ldy Y
	lda PLAYSCREEN.OFS
	add adr.ROW,y
	sta :STACKORIGIN+10
	lda PLAYSCREEN.OFS+1
	adc adr.ROW+256,y
	sta :STACKORIGIN+STACKWIDTH+10
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+10
	add #$09
	sta BLITTMP.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc #$00
	sta BLITTMP.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta BLITTMP.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta BLITTMP.DST+3
	lda K
	sta BLITTMP.SIZE
	jsr BLITTMP

; --- ForToDoEpilog
	inc Y
	jne l_2706
l_2714

; ------------------------------------------------------------

PATT	= DATAORIGIN+$037B
PATT.WIDTH	= DATAORIGIN+$0000
PATT.HEIGHT	= DATAORIGIN+$0002
PATT.OFS	= DATAORIGIN+$0004
YB	= DATAORIGIN+$037F
X	= DATAORIGIN+$0381
Y	= DATAORIGIN+$0382
CL	= DATAORIGIN+$0383
SHADOW	= DATAORIGIN+$0384
K	= DATAORIGIN+$0385

@VarData	= PATT
@VarDataSize	= 9

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	WRITE_ROUND_LEVEL				; PROCEDURE

; ------------------------------------------------------------

X	= DATAORIGIN+$0386
Y	= DATAORIGIN+$0388

@VarData	= X
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_ROUND_LEVEL				; PROCEDURE

; optimize OK (service.pas), line = 2633

	lda adr.ROW+$81
	add #$48
	sta HLP
	lda adr.ROW+256+$81
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 2635

	lda HLP
	sta BLITBOX.DST
	lda #$50
	add HLP+1
	sta BLITBOX.DST+1
	lda #$00
	adc #$00
	sta BLITBOX.DST+2
	lda #$00
	adc #$00
	sta BLITBOX.DST+3
	lda PLAYSCREEN.OFS
	add HLP
	sta BLITBOX.SRC
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITBOX.SRC+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITBOX.SRC+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITBOX.SRC+3
	lda #$58
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda #$1F
	sta BLITBOX.H
	jsr BLITBOX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	GAME_OVER					; PROCEDURE

; ------------------------------------------------------------

X	= DATAORIGIN+$038A
Y	= DATAORIGIN+$038C
adr.SC	= [DATAORIGIN+$038E] .array [21]
.var SC	= adr.SC .word

@VarData	= X
@VarDataSize	= 25

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DESTROY_VAUS					; PROCEDURE

; optimize OK (service.pas), line = 2689

	:8 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 2690

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 2692

	lda VAUS.X
	sta MOVE_VAUS.X
	lda #$00
	sta MOVE_VAUS.X+1
	lda VAUS.Y
	sta MOVE_VAUS.Y
	lda #$00
	sta MOVE_VAUS.Y+1
	jsr MOVE_VAUS

; optimize OK (service.pas), line = 2694

	lda VAUS.X
	sub #$04
	sta A
	lda #$00
	sbc #$00
	sta A+1

; optimize OK (service.pas), line = 2695

	lda VAUS.Y
	sub #$05
	sta B
	lda #$00
	sbc #$00
	sta B+1

; optimize OK (service.pas), line = 2698

	lda #$00
	sta W

l_2805
; --- ForToDoCondition
	lda W
	cmp #$07
	jcs l_2813

; optimize OK (service.pas), line = 2700

	lda #$00
	sta Y

l_281C
; --- ForToDoCondition
	lda Y
	cmp #$10
	jcs l_282A

; optimize OK (service.pas), line = 2703

	lda EXPLOSION.WIDTH
	sta :ecx
	lda EXPLOSION.WIDTH+1
	sta :ecx+1
	lda Y
	sta :eax
	lda #$00
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX_AL
	eif
	lda :eax
	sta :STACKORIGIN+9
	lda :eax+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda EXPLOSION.WIDTH
	sta :STACKORIGIN+11
	lda EXPLOSION.WIDTH+1
	asl :STACKORIGIN+11
	rol @
	asl :STACKORIGIN+11
	rol @
	asl :STACKORIGIN+11
	rol @
	asl :STACKORIGIN+11
	rol @
	sta :ecx+1
	lda :STACKORIGIN+11
	sta :ecx
	lda W
	sta :eax
	lda #$00
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	add :STACKORIGIN+9
	sta Z
	lda :eax+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta Z+1

; optimize OK (service.pas), line = 2705

	lda Y
	add B
	tay
	lda A
	add adr.ROW,y
	sta HLP
	lda A+1
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 2707

	lda #$00
	sta X
	ldy EXPLOSION.WIDTH
	dey
	sty @FORTMP_2861_0

l_2864
; --- ForToDoCondition
	lda @FORTMP_2861_0::#$00
	cmp X
	jcc l_2872

; optimize FAIL (1, service.pas), line = 2711

	inx
	ldy #1
	lda W
	cmp #$06
	beq @+
	dey
@
	sty :STACKORIGIN,x
	lda EXPLOSION.OFS
	add X
	sta :STACKORIGIN+9
	lda EXPLOSION.OFS+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda EXPLOSION.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda EXPLOSION.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda :STACKORIGIN+9
	add Z
	sta GETBYTE.SRC
	lda :STACKORIGIN+STACKWIDTH+9
	adc Z+1
	sta GETBYTE.SRC+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc #$00
	sta GETBYTE.SRC+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc #$00
	sta GETBYTE.SRC+3
	jsr GETBYTE
	dex
	ldy #1
	lda GETBYTE.RESULT
	beq @+
	dey
@
	tya
	ora :STACKORIGIN+1,x
	jeq l_289A

; optimize FAIL (1, service.pas), line = 2715

	inx
	mva X :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	lda PLAYSCREEN.OFS
	add HLP
	sta :STACKORIGIN+9
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda :STACKORIGIN+9
	add X
	sta GETBYTE.SRC
	lda :STACKORIGIN+STACKWIDTH+9
	adc #$00
	sta GETBYTE.SRC+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc #$00
	sta GETBYTE.SRC+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc #$00
	sta GETBYTE.SRC+3
	jsr GETBYTE
	ldy :STACKORIGIN,x
	lda GETBYTE.RESULT
	sta adr.TMP,y
	dex
	jmp l_28B7
l_289A

; optimize FAIL (1, service.pas), line = 2720

	inx
	mva X :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	lda EXPLOSION.OFS
	add X
	sta :STACKORIGIN+9
	lda EXPLOSION.OFS+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda EXPLOSION.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda EXPLOSION.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda :STACKORIGIN+9
	add Z
	sta GETBYTE.SRC
	lda :STACKORIGIN+STACKWIDTH+9
	adc Z+1
	sta GETBYTE.SRC+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc #$00
	sta GETBYTE.SRC+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc #$00
	sta GETBYTE.SRC+3
	jsr GETBYTE
	ldy :STACKORIGIN,x
	lda GETBYTE.RESULT
	sta adr.TMP,y
	dex
l_28B7

; --- ForToDoEpilog
	inc X
	jne l_2864
l_2872

; optimize OK (service.pas), line = 2723

	lda HLP
	sta BLITTMP.DST
	lda #$50
	add HLP+1
	sta BLITTMP.DST+1
	lda #$00
	adc #$00
	sta BLITTMP.DST+2
	lda #$00
	adc #$00
	sta BLITTMP.DST+3
	lda EXPLOSION.WIDTH
	sta BLITTMP.SIZE
	jsr BLITTMP

; --- ForToDoEpilog
	inc Y
	jne l_281C
l_282A

; optimize OK (service.pas), line = 2726

	lda W
	sta DEATH_SOUND.A
	lda #$00
	sta DEATH_SOUND.A+1
	jsr DEATH_SOUND

; --- ForToDoEpilog
	inc W
	jne l_2805
l_2813

; optimize OK (service.pas), line = 2730

	lda #$07
	sta DEATH_SOUND.A
	lda #$00
	sta DEATH_SOUND.A+1
	jsr DEATH_SOUND

; optimize OK (service.pas), line = 2731

	lda #$96
	sta MYDELAY.A
	lda #$00
	sta MYDELAY.A+1
	jsr MYDELAY

; optimize FAIL ('DISABLE_LETTER', service.pas), line = 2732

	jsr DISABLE_LETTER

; ------------------------------------------------------------

Z	= DATAORIGIN+$03A3
A	= DATAORIGIN+$03A5
B	= DATAORIGIN+$03A7
W	= DATAORIGIN+$03A9
X	= DATAORIGIN+$03AA
Y	= DATAORIGIN+$03AB

@VarData	= Z
@VarDataSize	= 9

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CREATE_VAUS					; PROCEDURE

; optimize FAIL ('NOSOUND', service.pas), line = 2744

	jsr NOSOUND

; optimize OK (service.pas), line = 2745

	lda #$5B
	sta A
	lda #$00
	sta A+1

; optimize OK (service.pas), line = 2746

	lda #$B3
	sta B
	lda #$00
	sta B+1

; optimize OK (service.pas), line = 2748

	lda #$0B
	sta W

l_2901
; --- ForToDoCondition
	lda #$00
	sta Y

l_2918
; --- ForToDoCondition
	lda Y
	cmp #$10
	jcs l_2926

; optimize OK (service.pas), line = 2753

	lda NEWVAUS.WIDTH
	sta :ecx
	lda NEWVAUS.WIDTH+1
	sta :ecx+1
	lda Y
	sta :eax
	lda #$00
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX_AL
	eif
	lda :eax
	sta :STACKORIGIN+9
	lda :eax+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda #$10
	sta :ecx
	lda #$00
	sta :ecx+1
	lda NEWVAUS.WIDTH
	sta :eax
	lda NEWVAUS.WIDTH+1
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	sta :ecx
	lda :eax+1
	sta :ecx+1
	lda W
	sta :eax
	lda #$00
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX_AL
	eif
	lda :eax
	add :STACKORIGIN+9
	sta Z
	lda :eax+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta Z+1

; optimize OK (service.pas), line = 2755

	lda Y
	add B
	tay
	lda A
	add adr.ROW,y
	sta HLP
	lda A+1
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 2757

	lda NEWVAUS.OFS
	add Z
	sta VBXE_RAM.POSITION
	lda NEWVAUS.OFS+1
	adc Z+1
	sta VBXE_RAM.POSITION+1
	lda NEWVAUS.OFS+2
	adc #$00
	sta VBXE_RAM.POSITION+2
	lda NEWVAUS.OFS+3
	adc #$00
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 2758

	lda SCANLINE
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER
	lda SCANLINE+1
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER+1
	lda NEWVAUS.WIDTH
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT
	lda NEWVAUS.WIDTH+1
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT+1
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.READBUFFER

; optimize OK (service.pas), line = 2760

	lda PLAYSCREEN.OFS
	add HLP
	sta VBXE_RAM.POSITION
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta VBXE_RAM.POSITION+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta VBXE_RAM.POSITION+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta VBXE_RAM.POSITION+3

; optimize OK (service.pas), line = 2761

	lda <adr.SCANLINE+$80
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER
	lda >adr.SCANLINE+$80
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.BUFFER+1
	lda NEWVAUS.WIDTH
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT
	lda NEWVAUS.WIDTH+1
	sta VBXE.TVBXEMEMORYSTREAM.READBUFFER.COUNT+1
	lda VBXE_RAM
	ldy VBXE_RAM+1
	jsr VBXE.TVBXEMEMORYSTREAM.READBUFFER

; optimize OK (service.pas), line = 2763

	lda #$00
	sta X
	ldy NEWVAUS.WIDTH
	dey
	sty @FORTMP_2978_0

l_297B
; --- ForToDoCondition
	lda @FORTMP_2978_0::#$00
	cmp X
	jcc l_2989

; optimize OK (service.pas), line = 2766

	ldy X
	lda adr.SCANLINE,y
	jne l_299E

; optimize OK (service.pas), line = 2772

	lda adr.SCANLINE+$80,y
	jmp l_29B8
l_299E

; optimize OK (service.pas), line = 2779

	ldy X
	lda adr.SCANLINE,y
l_29B8
	sta adr.TMP,y

; --- ForToDoEpilog
	inc X
	jne l_297B
l_2989

; optimize OK (service.pas), line = 2782

	lda HLP
	sta BLITTMP.DST
	lda #$50
	add HLP+1
	sta BLITTMP.DST+1
	lda #$00
	adc #$00
	sta BLITTMP.DST+2
	lda #$00
	adc #$00
	sta BLITTMP.DST+3
	lda NEWVAUS.WIDTH
	sta BLITTMP.SIZE
	jsr BLITTMP

; --- ForToDoEpilog
	inc Y
	jne l_2918
l_2926

; optimize OK (service.pas), line = 2785

	lda #$01
	sta MYDELAY.A
	lda #$00
	sta MYDELAY.A+1
	jsr MYDELAY

; --- ForToDoEpilog
	dec W
	jpl l_2901
l_290F

; ------------------------------------------------------------

X	= DATAORIGIN+$03AD
Y	= DATAORIGIN+$03AE
W	= DATAORIGIN+$03AF
Z	= DATAORIGIN+$03B0
A	= DATAORIGIN+$03B2
B	= DATAORIGIN+$03B4

@VarData	= X
@VarDataSize	= 9

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PUT_DIGIT					; PROCEDURE

; optimize OK (service.pas), line = 2795

	lda #$DE
	sta A

; optimize OK (service.pas), line = 2819

	ldy NUM
	lda adr.DIGITS,y
	and #$01
	cmp #$01
	jne l_29FE
	lda #$DF
	sta A
l_29FE

; optimize OK (service.pas), line = 2820

	lda #$01
	sta X

l_2A0E
; --- ForToDoCondition
	lda X
	cmp #$05
	jcs l_2A1C

; optimize OK (service.pas), line = 2822

	lda PX
	sta :STACKORIGIN+10
	lda #$50
	add PX+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+10
	add X
	sta :STACKORIGIN+10
	lda :STACKORIGIN+STACKWIDTH+10
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	ldy PY
	lda :STACKORIGIN+10
	add adr.ROW,y
	sta PUTBYTE.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256,y
	sta PUTBYTE.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta PUTBYTE.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta PUTBYTE.DST+3
	lda A
	sta PUTBYTE.V
	jsr PUTBYTE

; --- ForToDoEpilog
	inc X
	jne l_2A0E
l_2A1C

; optimize OK (service.pas), line = 2826

	lda #$DE
	sta A

; optimize OK (service.pas), line = 2827

	ldy NUM
	lda adr.DIGITS,y
	and #$02
	cmp #$02
	jne l_2A54
	lda #$DF
	sta A
l_2A54

; optimize OK (service.pas), line = 2828

	lda #$01
	sta X

l_2A64
; --- ForToDoCondition
	lda X
	cmp #$05
	jcs l_2A72

; optimize OK (service.pas), line = 2830

	lda PX
	sta :STACKORIGIN+10
	lda #$50
	add PX+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+10
	add X
	sta :STACKORIGIN+10
	lda :STACKORIGIN+STACKWIDTH+10
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	ldy PY
	lda :STACKORIGIN+10
	add adr.ROW+$05,y
	sta PUTBYTE.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256+$05,y
	sta PUTBYTE.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta PUTBYTE.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta PUTBYTE.DST+3
	lda A
	sta PUTBYTE.V
	jsr PUTBYTE

; --- ForToDoEpilog
	inc X
	jne l_2A64
l_2A72

; optimize OK (service.pas), line = 2834

	lda #$DE
	sta A

; optimize OK (service.pas), line = 2835

	ldy NUM
	lda adr.DIGITS,y
	and #$04
	cmp #$04
	jne l_2AAE
	lda #$DF
	sta A
l_2AAE

; optimize OK (service.pas), line = 2836

	lda #$01
	sta X

l_2ABE
; --- ForToDoCondition
	lda X
	cmp #$05
	jcs l_2ACC

; optimize OK (service.pas), line = 2838

	lda PX
	sta :STACKORIGIN+10
	lda #$50
	add PX+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda :STACKORIGIN+10
	add X
	sta :STACKORIGIN+10
	lda :STACKORIGIN+STACKWIDTH+10
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	ldy PY
	lda :STACKORIGIN+10
	add adr.ROW+$0A,y
	sta PUTBYTE.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256+$0A,y
	sta PUTBYTE.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta PUTBYTE.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta PUTBYTE.DST+3
	lda A
	sta PUTBYTE.V
	jsr PUTBYTE

; --- ForToDoEpilog
	inc X
	jne l_2ABE
l_2ACC

; optimize OK (service.pas), line = 2841

	lda #$DE
	sta A

; optimize OK (service.pas), line = 2842

	ldy NUM
	lda adr.DIGITS,y
	and #$08
	cmp #$08
	jne l_2B08
	lda #$DF
	sta A
l_2B08

; optimize OK (service.pas), line = 2843

	lda #$01
	sta Y

l_2B18
; --- ForToDoCondition
	lda Y
	cmp #$05
	jcs l_2B26

; optimize OK (service.pas), line = 2845

	lda PX
	sta :STACKORIGIN+10
	lda #$50
	add PX+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda PY
	add Y
	tay
	lda :STACKORIGIN+10
	add adr.ROW,y
	sta PUTBYTE.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256,y
	sta PUTBYTE.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta PUTBYTE.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta PUTBYTE.DST+3
	lda A
	sta PUTBYTE.V
	jsr PUTBYTE

; --- ForToDoEpilog
	inc Y
	jne l_2B18
l_2B26

; optimize OK (service.pas), line = 2848

	lda #$DE
	sta A

; optimize OK (service.pas), line = 2849

	ldy NUM
	lda adr.DIGITS,y
	and #$10
	cmp #$10
	jne l_2B5E
	lda #$DF
	sta A
l_2B5E

; optimize OK (service.pas), line = 2850

	lda #$01
	sta Y

l_2B6E
; --- ForToDoCondition
	lda Y
	cmp #$05
	jcs l_2B7C

; optimize OK (service.pas), line = 2852

	lda PX
	sta :STACKORIGIN+10
	lda #$50
	add PX+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda PY
	add Y
	tay
	lda :STACKORIGIN+10
	add adr.ROW+$05,y
	sta PUTBYTE.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256+$05,y
	sta PUTBYTE.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta PUTBYTE.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta PUTBYTE.DST+3
	lda A
	sta PUTBYTE.V
	jsr PUTBYTE

; --- ForToDoEpilog
	inc Y
	jne l_2B6E
l_2B7C

; optimize OK (service.pas), line = 2855

	lda #$DE
	sta A

; optimize OK (service.pas), line = 2856

	ldy NUM
	lda adr.DIGITS,y
	and #$20
	cmp #$20
	jne l_2BB8
	lda #$DF
	sta A
l_2BB8

; optimize OK (service.pas), line = 2857

	lda #$01
	sta Y

l_2BC8
; --- ForToDoCondition
	lda Y
	cmp #$05
	jcs l_2BD6

; optimize OK (service.pas), line = 2859

	lda #$05
	adc PX
	sta :STACKORIGIN+10
	lda #$50
	adc PX+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda PY
	add Y
	tay
	lda :STACKORIGIN+10
	add adr.ROW,y
	sta PUTBYTE.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256,y
	sta PUTBYTE.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta PUTBYTE.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta PUTBYTE.DST+3
	lda A
	sta PUTBYTE.V
	jsr PUTBYTE

; --- ForToDoEpilog
	inc Y
	jne l_2BC8
l_2BD6

; optimize OK (service.pas), line = 2862

	lda #$DE
	sta A

; optimize OK (service.pas), line = 2863

	ldy NUM
	lda adr.DIGITS,y
	and #$40
	cmp #$40
	jne l_2C12
	lda #$DF
	sta A
l_2C12

; optimize OK (service.pas), line = 2864

	lda #$01
	sta Y

l_2C22
; --- ForToDoCondition
	lda Y
	cmp #$05
	jcs l_2C30

; optimize OK (service.pas), line = 2866

	lda #$05
	adc PX
	sta :STACKORIGIN+10
	lda #$50
	adc PX+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	lda PY
	add Y
	tay
	lda :STACKORIGIN+10
	add adr.ROW+$05,y
	sta PUTBYTE.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256+$05,y
	sta PUTBYTE.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta PUTBYTE.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta PUTBYTE.DST+3
	lda A
	sta PUTBYTE.V
	jsr PUTBYTE

; --- ForToDoEpilog
	inc Y
	jne l_2C22
l_2C30

; ------------------------------------------------------------

PX	= DATAORIGIN+$03B7
PY	= DATAORIGIN+$03B9
NUM	= DATAORIGIN+$03BB
X	= DATAORIGIN+$03BD
Y	= DATAORIGIN+$03BE
A	= DATAORIGIN+$03BF

@VarData	= PX
@VarDataSize	= 9

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	WRITE_SCORE					; PROCEDURE

; optimize OK (service.pas), line = 2877

	lda #$00
	sta F

; optimize OK (service.pas), line = 2882

	lda #$A0
	sta @INTEGER.DIV.B
	lda #$86
	sta @INTEGER.DIV.B+1
	lda #$01
	sta @INTEGER.DIV.B+2
	lda #$00
	sta @INTEGER.DIV.B+3
	lda SC
	sta @INTEGER.DIV.A
	lda SC+1
	sta @INTEGER.DIV.A+1
	lda SC+2
	sta @INTEGER.DIV.A+2
	lda SC+3
	sta @INTEGER.DIV.A+3
	jsr @INTEGER.DIV
	lda #$0A
	sta @INTEGER.MOD.B
	lda #$00
	sta @INTEGER.MOD.B+1
	sta @INTEGER.MOD.B+2
	sta @INTEGER.MOD.B+3
	jsr @INTEGER.MOD
	lda @INTEGER.MOD.RESULT
	sta N1
	lda @INTEGER.MOD.RESULT+1
	sta N1+1
	lda @INTEGER.MOD.RESULT+2
	sta N1+2
	lda @INTEGER.MOD.RESULT+3
	sta N1+3

; optimize OK (service.pas), line = 2883

	jmi l_2C78
	ora N1+2
	ora N1+1
	ora N1
	jeq l_2C78
	lda #$01
	sta F
l_2C78

; optimize OK (service.pas), line = 2884

	lda F
	jeq l_2C8B
	lda PX
	sta PUT_DIGIT.PX
	lda PX+1
	sta PUT_DIGIT.PX+1
	lda PY
	sta PUT_DIGIT.PY
	lda PY+1
	sta PUT_DIGIT.PY+1
	lda N1
	sta PUT_DIGIT.NUM
	lda N1+1
	jmp l_2C9B
l_2C8B

; optimize OK (service.pas), line = 2885

	lda PX
	sta PUT_DIGIT.PX
	lda PX+1
	sta PUT_DIGIT.PX+1
	lda PY
	sta PUT_DIGIT.PY
	lda PY+1
	sta PUT_DIGIT.PY+1
	lda #$0A
	sta PUT_DIGIT.NUM
	lda #$00
l_2C9B
	sta PUT_DIGIT.NUM+1
	jsr PUT_DIGIT

; optimize OK (service.pas), line = 2888

	lda #$10
	sta @INTEGER.DIV.B
	lda #$27
	sta @INTEGER.DIV.B+1
	lda #$00
	sta @INTEGER.DIV.B+2
	sta @INTEGER.DIV.B+3
	lda SC
	sta @INTEGER.DIV.A
	lda SC+1
	sta @INTEGER.DIV.A+1
	lda SC+2
	sta @INTEGER.DIV.A+2
	lda SC+3
	sta @INTEGER.DIV.A+3
	jsr @INTEGER.DIV
	lda #$0A
	sta @INTEGER.MOD.B
	lda #$00
	sta @INTEGER.MOD.B+1
	sta @INTEGER.MOD.B+2
	sta @INTEGER.MOD.B+3
	jsr @INTEGER.MOD
	lda @INTEGER.MOD.RESULT
	sta N1
	lda @INTEGER.MOD.RESULT+1
	sta N1+1
	lda @INTEGER.MOD.RESULT+2
	sta N1+2
	lda @INTEGER.MOD.RESULT+3
	sta N1+3

; optimize OK (service.pas), line = 2889

	jmi l_2CBD
	ora N1+2
	ora N1+1
	ora N1
	jeq l_2CBD
	lda #$01
	sta F
l_2CBD

; optimize OK (service.pas), line = 2890

	lda F
	jeq l_2CD0
	lda PX
	add #$07
	sta PUT_DIGIT.PX
	lda PX+1
	adc #$00
	sta PUT_DIGIT.PX+1
	lda PY
	sta PUT_DIGIT.PY
	lda PY+1
	sta PUT_DIGIT.PY+1
	lda N1
	sta PUT_DIGIT.NUM
	lda N1+1
	jmp l_2CE4
l_2CD0

; optimize OK (service.pas), line = 2891

	lda PX
	add #$07
	sta PUT_DIGIT.PX
	lda PX+1
	adc #$00
	sta PUT_DIGIT.PX+1
	lda PY
	sta PUT_DIGIT.PY
	lda PY+1
	sta PUT_DIGIT.PY+1
	lda #$0A
	sta PUT_DIGIT.NUM
	lda #$00
l_2CE4
	sta PUT_DIGIT.NUM+1
	jsr PUT_DIGIT

; optimize OK (service.pas), line = 2894

	lda #$E8
	sta @INTEGER.DIV.B
	lda #$03
	sta @INTEGER.DIV.B+1
	lda #$00
	sta @INTEGER.DIV.B+2
	sta @INTEGER.DIV.B+3
	lda SC
	sta @INTEGER.DIV.A
	lda SC+1
	sta @INTEGER.DIV.A+1
	lda SC+2
	sta @INTEGER.DIV.A+2
	lda SC+3
	sta @INTEGER.DIV.A+3
	jsr @INTEGER.DIV
	lda #$0A
	sta @INTEGER.MOD.B
	lda #$00
	sta @INTEGER.MOD.B+1
	sta @INTEGER.MOD.B+2
	sta @INTEGER.MOD.B+3
	jsr @INTEGER.MOD
	lda @INTEGER.MOD.RESULT
	sta N1
	lda @INTEGER.MOD.RESULT+1
	sta N1+1
	lda @INTEGER.MOD.RESULT+2
	sta N1+2
	lda @INTEGER.MOD.RESULT+3
	sta N1+3

; optimize OK (service.pas), line = 2895

	jmi l_2D0A
	ora N1+2
	ora N1+1
	ora N1
	jeq l_2D0A
	lda #$01
	sta F
l_2D0A

; optimize OK (service.pas), line = 2896

	lda F
	jeq l_2D1D
	lda PX
	add #$0E
	sta PUT_DIGIT.PX
	lda PX+1
	adc #$00
	sta PUT_DIGIT.PX+1
	lda PY
	sta PUT_DIGIT.PY
	lda PY+1
	sta PUT_DIGIT.PY+1
	lda N1
	sta PUT_DIGIT.NUM
	lda N1+1
	jmp l_2D31
l_2D1D

; optimize OK (service.pas), line = 2897

	lda PX
	add #$0E
	sta PUT_DIGIT.PX
	lda PX+1
	adc #$00
	sta PUT_DIGIT.PX+1
	lda PY
	sta PUT_DIGIT.PY
	lda PY+1
	sta PUT_DIGIT.PY+1
	lda #$0A
	sta PUT_DIGIT.NUM
	lda #$00
l_2D31
	sta PUT_DIGIT.NUM+1
	jsr PUT_DIGIT

; optimize OK (service.pas), line = 2900

	lda #$64
	sta @INTEGER.DIV.B
	lda #$00
	sta @INTEGER.DIV.B+1
	sta @INTEGER.DIV.B+2
	sta @INTEGER.DIV.B+3
	lda SC
	sta @INTEGER.DIV.A
	lda SC+1
	sta @INTEGER.DIV.A+1
	lda SC+2
	sta @INTEGER.DIV.A+2
	lda SC+3
	sta @INTEGER.DIV.A+3
	jsr @INTEGER.DIV
	lda #$0A
	sta @INTEGER.MOD.B
	lda #$00
	sta @INTEGER.MOD.B+1
	sta @INTEGER.MOD.B+2
	sta @INTEGER.MOD.B+3
	jsr @INTEGER.MOD
	lda @INTEGER.MOD.RESULT
	sta N1
	lda @INTEGER.MOD.RESULT+1
	sta N1+1
	lda @INTEGER.MOD.RESULT+2
	sta N1+2
	lda @INTEGER.MOD.RESULT+3
	sta N1+3

; optimize OK (service.pas), line = 2901

	jmi l_2D57
	ora N1+2
	ora N1+1
	ora N1
	jeq l_2D57
	lda #$01
	sta F
l_2D57

; optimize OK (service.pas), line = 2902

	lda F
	jeq l_2D6A
	lda PX
	add #$15
	sta PUT_DIGIT.PX
	lda PX+1
	adc #$00
	sta PUT_DIGIT.PX+1
	lda PY
	sta PUT_DIGIT.PY
	lda PY+1
	sta PUT_DIGIT.PY+1
	lda N1
	sta PUT_DIGIT.NUM
	lda N1+1
	jmp l_2D7E
l_2D6A

; optimize OK (service.pas), line = 2903

	lda PX
	add #$15
	sta PUT_DIGIT.PX
	lda PX+1
	adc #$00
	sta PUT_DIGIT.PX+1
	lda PY
	sta PUT_DIGIT.PY
	lda PY+1
	sta PUT_DIGIT.PY+1
	lda #$0A
	sta PUT_DIGIT.NUM
	lda #$00
l_2D7E
	sta PUT_DIGIT.NUM+1
	jsr PUT_DIGIT

; optimize OK (service.pas), line = 2906

	lda #$0A
	sta @INTEGER.DIV.B
	lda #$00
	sta @INTEGER.DIV.B+1
	sta @INTEGER.DIV.B+2
	sta @INTEGER.DIV.B+3
	lda SC
	sta @INTEGER.DIV.A
	lda SC+1
	sta @INTEGER.DIV.A+1
	lda SC+2
	sta @INTEGER.DIV.A+2
	lda SC+3
	sta @INTEGER.DIV.A+3
	jsr @INTEGER.DIV
	lda #$0A
	sta @INTEGER.MOD.B
	lda #$00
	sta @INTEGER.MOD.B+1
	sta @INTEGER.MOD.B+2
	sta @INTEGER.MOD.B+3
	jsr @INTEGER.MOD
	lda @INTEGER.MOD.RESULT
	sta N1
	lda @INTEGER.MOD.RESULT+1
	sta N1+1
	lda @INTEGER.MOD.RESULT+2
	sta N1+2
	lda @INTEGER.MOD.RESULT+3
	sta N1+3

; optimize OK (service.pas), line = 2907

	lda PX
	add #$1C
	sta PUT_DIGIT.PX
	lda PX+1
	adc #$00
	sta PUT_DIGIT.PX+1
	lda PY
	sta PUT_DIGIT.PY
	lda PY+1
	sta PUT_DIGIT.PY+1
	lda N1
	sta PUT_DIGIT.NUM
	lda N1+1
	sta PUT_DIGIT.NUM+1
	jsr PUT_DIGIT

; optimize OK (service.pas), line = 2911

	lda PX
	add #$23
	sta PUT_DIGIT.PX
	lda PX+1
	adc #$00
	sta PUT_DIGIT.PX+1
	lda PY
	sta PUT_DIGIT.PY
	lda PY+1
	sta PUT_DIGIT.PY+1
	lda #$00
	sta PUT_DIGIT.NUM
	sta PUT_DIGIT.NUM+1
	jsr PUT_DIGIT

; ------------------------------------------------------------

PX	= DATAORIGIN+$03C0
PY	= DATAORIGIN+$03C2
SC	= DATAORIGIN+$03C4
N1	= DATAORIGIN+$03C8
F	= DATAORIGIN+$03CC

@VarData	= PX
@VarDataSize	= 13

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLOT_LIVES					; PROCEDURE

; optimize FAIL (0, service.pas), line = 2957

	lda LIVES
	bne @+
	dec LIVES+1
@
	dec LIVES

; optimize OK (service.pas), line = 2960

	lda #$00
	sta CN

l_2DBD
; --- ForToDoCondition
	lda CN
	cmp #$08
	jcs l_2DCB

; optimize OK (service.pas), line = 2961

	lda #$00
	sta Y
	ldy MINIVAUS.HEIGHT
	dey
	sty @FORTMP_2DD6_0

l_2DD9
; --- ForToDoCondition
	lda @FORTMP_2DD6_0::#$00
	cmp Y
	jcc l_2DE7

; optimize OK (service.pas), line = 2962

	lda #$00
	sta X
	ldy MINIVAUS.WIDTH
	dey
	sty @FORTMP_2DF2_0

l_2DF5
; --- ForToDoCondition
	lda @FORTMP_2DF2_0::#$00
	cmp X
	jcc l_2E03

; optimize OK (service.pas), line = 2964

	lda X
	add #$0B
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda MINIVAUS.WIDTH
	sta :ecx
	lda MINIVAUS.WIDTH+1
	sta :ecx+1
	lda CN
	sta :eax
	lda #$00
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX_AL
	eif
	lda :eax
	add :STACKORIGIN+9
	sta XL
	lda :eax+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta XL+1

; optimize OK (service.pas), line = 2965

	lda Y
	add #$C0
	sta YL
	lda #$00
	adc #$00
	sta YL+1

; optimize OK (service.pas), line = 2967

	ldy XL
	lda adr.MODX,y
	sta XP
	lda #$00
	sta XP+1

; optimize OK (service.pas), line = 2968

	ldy YL
	lda adr.MODY,y
	sta :eax
	lda #$00
	sta :eax+1
	lda PATTERN.WIDTH
	sta :ecx
	lda PATTERN.WIDTH+1
	sta :ecx+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX_AL
	eif
	lda :eax
	sta YP
	lda :eax+1
	sta YP+1

; optimize FAIL (1, service.pas), line = 2972

	inx
	ldy #1
	lda CN
	cmp LIVES
	lda #$00
	sbc LIVES+1
	svc
	eor #$80
	bmi @+
	dey
@
	sty :STACKORIGIN,x
	lda MINIVAUS.OFS
	add X
	sta :STACKORIGIN+9
	lda MINIVAUS.OFS+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda MINIVAUS.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda MINIVAUS.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda MINIVAUS.WIDTH
	sta :ecx
	lda MINIVAUS.WIDTH+1
	sta :ecx+1
	lda Y
	sta :eax
	lda #$00
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX_AL
	eif
	lda :STACKORIGIN+9
	add :eax
	sta GETBYTE.SRC
	lda :STACKORIGIN+STACKWIDTH+9
	adc :eax+1
	sta GETBYTE.SRC+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc :eax+2
	sta GETBYTE.SRC+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc :eax+3
	sta GETBYTE.SRC+3
	jsr GETBYTE
	dex
	ldy #1
	lda GETBYTE.RESULT
	bne @+
	dey
@
	tya
	and :STACKORIGIN+1,x
	jeq l_2E66

; optimize OK (service.pas), line = 2975

	lda MINIVAUS.OFS
	add X
	sta :STACKORIGIN+9
	lda MINIVAUS.OFS+1
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+9
	lda MINIVAUS.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda MINIVAUS.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda MINIVAUS.WIDTH
	sta :ecx
	lda MINIVAUS.WIDTH+1
	sta :ecx+1
	lda Y
	sta :eax
	lda #$00
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX_AL
	eif
	lda :STACKORIGIN+9
	add :eax
	sta GETBYTE.SRC
	lda :STACKORIGIN+STACKWIDTH+9
	adc :eax+1
	sta GETBYTE.SRC+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc :eax+2
	sta GETBYTE.SRC+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc :eax+3
	sta GETBYTE.SRC+3
	jsr GETBYTE
	lda GETBYTE.RESULT
	sta CL
; optimize OK (service.pas), line = 2978
; optimize OK (service.pas), line = 2981
	jmp l_2EA8
l_2E66

; optimize OK (service.pas), line = 2990

	lda PLAYSCREEN.OFS
	add XL
	sta :STACKORIGIN+9
	lda PLAYSCREEN.OFS+1
	adc XL+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+9
	ldy YL
	lda :STACKORIGIN+9
	add adr.ROW,y
	sta GETBYTE.SRC
	lda :STACKORIGIN+STACKWIDTH+9
	adc adr.ROW+256,y
	sta GETBYTE.SRC+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc #$00
	sta GETBYTE.SRC+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc #$00
	sta GETBYTE.SRC+3
	jsr GETBYTE
	lda GETBYTE.RESULT
	and #$80
	sta SHADOW

; optimize OK (service.pas), line = 2993

	lda PATTERN.OFS
	add XP
	sta :STACKORIGIN+9
	lda PATTERN.OFS+1
	adc XP+1
	sta :STACKORIGIN+STACKWIDTH+9
	lda PATTERN.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+9
	lda PATTERN.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+9
	lda :STACKORIGIN+9
	add YP
	sta GETBYTE.SRC
	lda :STACKORIGIN+STACKWIDTH+9
	adc YP+1
	sta GETBYTE.SRC+1
	lda :STACKORIGIN+STACKWIDTH*2+9
	adc #$00
	sta GETBYTE.SRC+2
	lda :STACKORIGIN+STACKWIDTH*3+9
	adc #$00
	sta GETBYTE.SRC+3
	jsr GETBYTE
	inx
	lda GETBYTE.RESULT
	and #$7F
	ora SHADOW
	sta CL
	dex
l_2EA8

; optimize OK (service.pas), line = 2996

	lda XL
	sta :STACKORIGIN+10
	lda #$50
	add XL+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	ldy YL
	lda :STACKORIGIN+10
	add adr.ROW,y
	sta PUTBYTE.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256,y
	sta PUTBYTE.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta PUTBYTE.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta PUTBYTE.DST+3
	lda CL
	sta PUTBYTE.V
	jsr PUTBYTE

; optimize OK (service.pas), line = 2999

	lda PLAYSCREEN.OFS
	add XL
	sta :STACKORIGIN+10
	lda PLAYSCREEN.OFS+1
	adc XL+1
	sta :STACKORIGIN+STACKWIDTH+10
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*2+10
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta :STACKORIGIN+STACKWIDTH*3+10
	ldy YL
	lda :STACKORIGIN+10
	add adr.ROW,y
	sta PUTBYTE.DST
	lda :STACKORIGIN+STACKWIDTH+10
	adc adr.ROW+256,y
	sta PUTBYTE.DST+1
	lda :STACKORIGIN+STACKWIDTH*2+10
	adc #$00
	sta PUTBYTE.DST+2
	lda :STACKORIGIN+STACKWIDTH*3+10
	adc #$00
	sta PUTBYTE.DST+3
	lda CL
	sta PUTBYTE.V
	jsr PUTBYTE

; --- ForToDoEpilog
	inc X
	jne l_2DF5
l_2E03

; --- ForToDoEpilog
	inc Y
	jne l_2DD9
l_2DE7

; --- ForToDoEpilog
	inc CN
	jne l_2DBD
l_2DCB

; ------------------------------------------------------------

LIVES	= DATAORIGIN+$03CD
XLIVES	= $0B
YLIVES	= $C0
X	= DATAORIGIN+$03CF
Y	= DATAORIGIN+$03D0
CN	= DATAORIGIN+$03D1
XP	= DATAORIGIN+$03D2
YP	= DATAORIGIN+$03D4
XL	= DATAORIGIN+$03D6
YL	= DATAORIGIN+$03D8
SHADOW	= DATAORIGIN+$03DA
CL	= DATAORIGIN+$03DB

@VarData	= LIVES
@VarDataSize	= 15

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	PLACE_FIRE					; PROCEDURE

; optimize OK (service.pas), line = 3010

	ldy FIRE.Y
	lda FIRE.X
	add adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 3012

	lda HLP
	sta BLITZERO.DST
	lda #$50
	add HLP+1
	sta BLITZERO.DST+1
	lda #$00
	adc #$00
	sta BLITZERO.DST+2
	lda #$00
	adc #$00
	sta BLITZERO.DST+3
	lda SHOOTS.OFS
	sta BLITZERO.SRC
	lda SHOOTS.OFS+1
	sta BLITZERO.SRC+1
	lda SHOOTS.OFS+2
	sta BLITZERO.SRC+2
	lda SHOOTS.OFS+3
	sta BLITZERO.SRC+3
	lda SHOOTS.WIDTH
	sta BLITZERO.W
	lda SHOOTS.WIDTH+1
	sta BLITZERO.W+1
	lda SHOOTS.HEIGHT
	sta BLITZERO.H
	jsr BLITZERO

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_FIRE					; PROCEDURE

; optimize OK (service.pas), line = 3030

	ldy FIRE.Y
	lda FIRE.X
	add adr.ROW,y
	sta HLP
	lda #$00
	adc adr.ROW+256,y
	sta HLP+1

; optimize OK (service.pas), line = 3032

	lda HLP
	sta BLITBOX.DST
	lda #$50
	add HLP+1
	sta BLITBOX.DST+1
	lda #$00
	adc #$00
	sta BLITBOX.DST+2
	lda #$00
	adc #$00
	sta BLITBOX.DST+3
	lda PLAYSCREEN.OFS
	add HLP
	sta BLITBOX.SRC
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITBOX.SRC+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITBOX.SRC+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITBOX.SRC+3
	lda SHOOTS.WIDTH
	sta BLITBOX.W
	lda SHOOTS.WIDTH+1
	sta BLITBOX.W+1
	lda SHOOTS.HEIGHT
	sta BLITBOX.H
	jsr BLITBOX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CHECK_FIRE					; PROCEDURE

; optimize OK (service.pas), line = 3048

	lda FIRE.AVL
	jeq l_2F58

; optimize FAIL ('MOUSECLICK', service.pas), line = 3050

	jsr MOUSECLICK
	inx
	inx
	ldy #1
	lda MOUSECLICK.RESULT
	cmp #$01
	beq @+
	dey
@
	tya
	and FIRE.AVL
	sta :STACKORIGIN-1,x
	dex
	dex
	ldy #1
	lda FIRE.SHOT
	beq @+
	dey
@
	tya
	and :STACKORIGIN+1,x
	jeq l_2F78

; optimize OK (service.pas), line = 3052

	lda VAUS.WIDTH
	sub SHOOTS.WIDTH
	lsr @
	add VAUS.X
	sta FIRE.X

; optimize OK (service.pas), line = 3053

	lda VAUS.Y
	sub SHOOTS.HEIGHT
	sta FIRE.Y

; optimize OK (service.pas), line = 3054

	lda #$01
	sta FIRE.SHOT

; optimize OK (service.pas), line = 3055

	lda #$00
	sta FIRE.NW

; optimize OK (service.pas), line = 3056

	lda #$BC
	sta BALL_BLOCK_SOUND.A
	lda #$02
	sta BALL_BLOCK_SOUND.A+1
	lda #$05
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND
l_2F78

; optimize OK (service.pas), line = 3059

	lda FIRE.SHOT
	jeq l_2FB2

; optimize OK (service.pas), line = 3061

	lda FIRE.NW
	jeq l_2FBF
	jsr REMOVE_FIRE
l_2FBF

; optimize OK (service.pas), line = 3062

	lda #$01
	sta FIRE.NW

; optimize OK (service.pas), line = 3064

	lda FIRE.Y
	sub #$04
	sta FIRE.Y

; optimize OK (service.pas), line = 3065

	cmp #$16
	jcs l_2FDA
	lda #$00
	sta FIRE.SHOT
	jmp l_2FE8
l_2FDA

; optimize FAIL ('PLACE_FIRE', service.pas), line = 3068

	jsr PLACE_FIRE

; optimize OK (service.pas), line = 3070

	lda FIRE.Y
	sub #$16
	jmi l_300F
	lda FIRE.Y
	sub #$16
	sta :STACKORIGIN+10
	lda #$00
	sbc #$00
	sta :STACKORIGIN+STACKWIDTH+10
	lda :STACKORIGIN+10
	cmp #$78
	lda :STACKORIGIN+STACKWIDTH+10
	sbc #$00
	svc
	eor #$80
	jpl l_300F

; optimize OK (service.pas), line = 3072

	lda FIRE.X
	sub #$09
	lsr @
	lsr @
	lsr @
	lsr @
	sta X1
	lda #$00
	sta X1+1

; optimize OK (service.pas), line = 3073

	lda FIRE.Y
	sub #$16
	lsr @
	lsr @
	lsr @
	sta Y1
	lda #$00
	sta Y1+1

; optimize OK (service.pas), line = 3075

	lda FIRE.X
	add SHOOTS.WIDTH
	sub #$09
	lsr @
	lsr @
	lsr @
	lsr @
	sta X2
	lda #$00
	sta X2+1

; optimize OK (service.pas), line = 3076

	lda Y1
	sta Y2
	lda Y1+1
	sta Y2+1

; optimize OK (service.pas), line = 3078

	lda Y1
	asl @
	asl @
	asl @
	asl @
	add X1
	tay
	lda adr.WALL,y
	jne l_3078x
	lda Y2
	asl @
	asl @
	asl @
	asl @
	add X2
	tay
	lda adr.WALL,y
	jeq l_3078
l_3078x

; optimize FAIL ('REMOVE_FIRE', service.pas), line = 3080

	jsr REMOVE_FIRE

; optimize OK (service.pas), line = 3081

	lda #$00
	sta FIRE.SHOT

; optimize OK (service.pas), line = 3083

	lda X1
	sta SHOOT_BLOCK_WITH_FIRE.XB
	lda X1+1
	sta SHOOT_BLOCK_WITH_FIRE.XB+1
	lda Y1
	sta SHOOT_BLOCK_WITH_FIRE.YB
	lda Y1+1
	sta SHOOT_BLOCK_WITH_FIRE.YB+1
	jsr SHOOT_BLOCK_WITH_FIRE

; optimize OK (service.pas), line = 3084

	lda X2
	sta SHOOT_BLOCK_WITH_FIRE.XB
	lda X2+1
	sta SHOOT_BLOCK_WITH_FIRE.XB+1
	lda Y2
	sta SHOOT_BLOCK_WITH_FIRE.YB
	lda Y2+1
	sta SHOOT_BLOCK_WITH_FIRE.YB+1
	jsr SHOOT_BLOCK_WITH_FIRE
l_2FE8
l_3078
l_300F
l_2FB2
l_2F58

; ------------------------------------------------------------

X1	= DATAORIGIN+$03DE
X2	= DATAORIGIN+$03E0
Y1	= DATAORIGIN+$03E2
Y2	= DATAORIGIN+$03E4

@VarData	= X1
@VarDataSize	= 8

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	REMOVE_FLUX					; PROCEDURE

; optimize OK (service.pas), line = 3096

	lda adr.ROW+$B0
	add #$D9
	sta HLP
	lda adr.ROW+256+$B0
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 3098

	lda HLP
	sta BLITBOX.DST
	lda #$50
	add HLP+1
	sta BLITBOX.DST+1
	lda #$00
	adc #$00
	sta BLITBOX.DST+2
	lda #$00
	adc #$00
	sta BLITBOX.DST+3
	lda PLAYSCREEN.OFS
	add HLP
	sta BLITBOX.SRC
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITBOX.SRC+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITBOX.SRC+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITBOX.SRC+3
	lda #$08
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda #$14
	sta BLITBOX.H
	jsr BLITBOX

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CHECK_FLUX					; PROCEDURE

; optimize OK (service.pas), line = 3112

	lda SCRFLUXCNT
	sta FX

; optimize OK (service.pas), line = 3114

	lda SCRFLUX
	jeq l_30C3

; optimize OK (service.pas), line = 3117

	lda #$00
	sta Y

l_30CD
; --- ForToDoCondition
	ldy Y
	cpy #$14
	jcs l_30DB

; optimize OK (service.pas), line = 3119

	lda #$D9
	adc adr.ROW+$B0,y
	sta BLITROW.DST
	lda #$50
	adc adr.ROW+256+$B0,y
	sta BLITROW.DST+1
	lda #$00
	adc #$00
	sta BLITROW.DST+2
	lda #$00
	adc #$00
	sta BLITROW.DST+3
	lda Y
	add FX
	sta :STACKORIGIN+12
	lda #$00
	adc #$00
	sta :STACKORIGIN+STACKWIDTH+12
	lda #$00
	asl :STACKORIGIN+12
	rol :STACKORIGIN+STACKWIDTH+12
	rol @
	asl :STACKORIGIN+12
	rol :STACKORIGIN+STACKWIDTH+12
	rol @
	asl :STACKORIGIN+12
	rol :STACKORIGIN+STACKWIDTH+12
	rol @
	sta :STACKORIGIN+STACKWIDTH*2+12
	lda FLUX.OFS
	add :STACKORIGIN+12
	sta BLITROW.SRC
	lda FLUX.OFS+1
	adc :STACKORIGIN+STACKWIDTH+12
	sta BLITROW.SRC+1
	lda FLUX.OFS+2
	adc :STACKORIGIN+STACKWIDTH*2+12
	sta BLITROW.SRC+2
	lda FLUX.OFS+3
	adc #$00
	sta BLITROW.SRC+3
	lda #$08
	sta BLITROW.SIZE
	lda #$00
	sta BLITROW.SIZE+1
	jsr BLITROW

; --- ForToDoEpilog
	inc Y
	jne l_30CD
l_30DB

; optimize FAIL (0, service.pas), line = 3121

	inc SCRFLUXCNT

; optimize OK (service.pas), line = 3122

	lda SCRFLUXCNT
	cmp #$15
	jcc l_311A
	lda #$00
	sta SCRFLUXCNT
l_311A
l_30C3

; ------------------------------------------------------------

Y	= DATAORIGIN+$03E6
FX	= DATAORIGIN+$03E7

@VarData	= Y
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	VAUS_OUT					; PROCEDURE

; optimize FAIL ('NOSOUND', service.pas), line = 3130

	jsr NOSOUND

; optimize OK (service.pas), line = 3132

	lda CUR_PLAYER
	asl @
	asl @
	tay
	lda adr.SCORE.PLAYER,y
	add #$10
	sta adr.SCORE.PLAYER,y
	lda adr.SCORE.PLAYER+1,y
	adc #$27
	sta adr.SCORE.PLAYER+1,y
	lda adr.SCORE.PLAYER+2,y
	adc #$00
	sta adr.SCORE.PLAYER+2,y
	lda adr.SCORE.PLAYER+3,y
	adc #$00
	sta adr.SCORE.PLAYER+3,y

; optimize OK (service.pas), line = 3133

	lda #$00
	sta REMAIN_BLK

; optimize OK (service.pas), line = 3135

	lda VAUS.X
	sta Z
	lda #$00
	sta Z+1

; optimize FAIL ('WAIT_VBL', service.pas), line = 3137

	jsr WAIT_VBL

; optimize FAIL ('REMOVE_VAUS', service.pas), line = 3138

	jsr REMOVE_VAUS

; optimize FAIL ('PLACE_VAUS', service.pas), line = 3139

	jsr PLACE_VAUS

; optimize OK (service.pas), line = 3141

	lda Z
	sta X
	lda Z+1
	sta X+1
	lda Z
	add #$2C
	sta @FORTMP_3145_0
	lda Z+1
	adc #$00
	sta @FORTMP_3145_1

l_3148
; --- ForToDoCondition
	lda @FORTMP_3145_1::#$00
	cmp X+1
	bne @+
	lda @FORTMP_3145_0::#$00
	cmp X
@
	jcc l_3154

; optimize FAIL ('WAIT_VBL', service.pas), line = 3143

	jsr WAIT_VBL

; optimize OK (service.pas), line = 3145

	lda VAUS.X
	sta VAUS.OLDX
	lda #$00
	sta VAUS.OLDX+1

; optimize OK (service.pas), line = 3146

	lda X
	sta VAUS.X

; optimize FAIL ('REMOVE_VAUS', service.pas), line = 3147

	jsr REMOVE_VAUS

; optimize FAIL ('CHECK_FLUX', service.pas), line = 3148

	jsr CHECK_FLUX

; optimize FAIL ('PLACE_VAUS', service.pas), line = 3149

	jsr PLACE_VAUS

; optimize OK (service.pas), line = 3151

	ldy VAUS.Y
	lda adr.ROW,y
	add #$E1
	sta HLP
	lda adr.ROW+256,y
	adc #$00
	sta HLP+1

; optimize OK (service.pas), line = 3153

	lda HLP
	sta BLITBOX.DST
	lda #$50
	add HLP+1
	sta BLITBOX.DST+1
	lda #$00
	adc #$00
	sta BLITBOX.DST+2
	lda #$00
	adc #$00
	sta BLITBOX.DST+3
	lda PLAYSCREEN.OFS
	add HLP
	sta BLITBOX.SRC
	lda PLAYSCREEN.OFS+1
	adc HLP+1
	sta BLITBOX.SRC+1
	lda PLAYSCREEN.OFS+2
	adc #$00
	sta BLITBOX.SRC+2
	lda PLAYSCREEN.OFS+3
	adc #$00
	sta BLITBOX.SRC+3
	lda #$28
	sta BLITBOX.W
	lda #$00
	sta BLITBOX.W+1
	lda VAUS.HEIGHT
	sta BLITBOX.H
	jsr BLITBOX

; --- ForToDoEpilog
	inc X
	jne l_3148
	inc X+1
	jne l_3148
l_3154

; ------------------------------------------------------------

X	= DATAORIGIN+$03E8
Y	= DATAORIGIN+$03EA
Z	= DATAORIGIN+$03EC

@VarData	= X
@VarDataSize	= 6

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	CHECK_BONUS_TYPE				; PROCEDURE

; optimize OK (service.pas), line = 3168

	lda VAUS.LETTER
	jmi l_319B
	jeq l_319B

; optimize OK (service.pas), line = 3170

	ldy #$00
	lda VAUS.LETTER
	spl
	dey
	sub #$01
	sta LETT.LAST
	tya
	sbc #$00
	sta LETT.LAST+1

; optimize OK (service.pas), line = 3171

	mwy B2 :bp2
	ldy #B2.INPLAY-DATAORIGIN
	lda (:bp2),y
	jeq l_31B2
	lda B2
	sta REMOVE_BALL.BALL
	lda B2+1
	sta REMOVE_BALL.BALL+1
	jsr REMOVE_BALL
l_31B2

; optimize OK (service.pas), line = 3172

	mwy B3 :bp2
	ldy #B3.INPLAY-DATAORIGIN
	lda (:bp2),y
	jeq l_31C4
	lda B3
	sta REMOVE_BALL.BALL
	lda B3+1
	sta REMOVE_BALL.BALL+1
	jsr REMOVE_BALL
l_31C4

; optimize OK (service.pas), line = 3173

	mwy B2 :bp2
	ldy #B2.INPLAY-DATAORIGIN
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 3174

	mwy B3 :bp2
	ldy #B3.INPLAY-DATAORIGIN
	sta (:bp2),y

; optimize OK (service.pas), line = 3175

	sta SCRFLUX

; optimize FAIL ('REMOVE_FLUX', service.pas), line = 3176

	jsr REMOVE_FLUX

; optimize OK (service.pas), line = 3178

	lda VAUS.LETTER
	cmp #$06
	jeq l_31E9

; optimize OK (service.pas), line = 3180

	mwy B1 :bp2
	ldy #B1.LAUNCH-DATAORIGIN
	lda #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 3181

	mwy B2 :bp2
	ldy #B2.LAUNCH-DATAORIGIN
	sta (:bp2),y

; optimize OK (service.pas), line = 3182

	mwy B3 :bp2
	ldy #B3.LAUNCH-DATAORIGIN
	sta (:bp2),y
l_31E9
l_319B

; optimize OK (service.pas), line = 3186

	lda VAUS.LETTER
	sta @CASETMP_000A
	cmp #$01
	jne l_3205
@

; optimize OK (service.pas), line = 3189

	lda FIRE.SHOT
	jeq l_3211
	jsr REMOVE_FIRE
l_3211

; optimize OK (service.pas), line = 3190

	:8 mva adr.LASERS+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3191

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 3192

	lda #$00
	sta VAUS.LETTER

; optimize OK (service.pas), line = 3193

	lda #$01
	sta FIRE.AVL

; optimize OK (service.pas), line = 3194

	lda #$00
	sta FIRE.SHOT
	jmp a_000A
l_3205
	cmp #$02
	jne l_322B

; optimize OK (service.pas), line = 3198

	lda FIRE.SHOT
	jeq l_3237
	jsr REMOVE_FIRE
l_3237

; optimize OK (service.pas), line = 3199

	:8 mva adr.ENLARGED+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3200

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 3201

	lda #$00
	sta VAUS.LETTER

; optimize OK (service.pas), line = 3202

	sta FIRE.AVL
	jmp a_000A
l_322B
	cmp #$03
	jne l_324D

; optimize OK (service.pas), line = 3206

	lda FIRE.SHOT
	jeq l_3259
	jsr REMOVE_FIRE
l_3259

; optimize OK (service.pas), line = 3207

	:8 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3208

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 3209

	lda #$00
	sta VAUS.LETTER

; optimize OK (service.pas), line = 3210

	sta FIRE.AVL

; optimize OK (service.pas), line = 3211

	lda #$01
	sta SCRFLUX
	jmp a_000A
l_324D
	cmp #$04
	jne l_3273

; optimize OK (service.pas), line = 3215

	lda FIRE.SHOT
	jeq l_327F
	jsr REMOVE_FIRE
l_327F

; optimize OK (service.pas), line = 3216

	:8 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3217

	jsr MODIFY_VAUS
; optimize OK (service.pas), line = 3218
	jmp s_32BC
l_3273
	cmp #$05
	jne l_3291

; optimize OK (service.pas), line = 3222

	lda FIRE.SHOT
	jeq l_329D
	jsr REMOVE_FIRE
l_329D

; optimize OK (service.pas), line = 3223

	:8 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3224

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 3225

	lda #$00
	sta VAUS.LETTER

; optimize OK (service.pas), line = 3226

	mwy B1 :bp2
	ldy #B1.SPEED-DATAORIGIN
	lda (:bp2),y
	sub #$F4
	sta MAX.A
	iny
	lda (:bp2),y
	sbc #$01
	sta MAX.A+1
	lda #$F4
	sta MAX.B
	lda #$01
	sta MAX.B+1
	jsr MAX
	lda MAX.RESULT
	sta X
	lda MAX.RESULT+1
	sta X+1

; optimize OK (service.pas), line = 3227

	lda B1
	sta SET_BALL_SPEED.BALL
	lda B1+1
	sta SET_BALL_SPEED.BALL+1
	lda X
	sta SET_BALL_SPEED.SPEED
	lda X+1
	sta SET_BALL_SPEED.SPEED+1
	jsr SET_BALL_SPEED
s_32BC
; optimize OK (service.pas), line = 3228
	jmp s_32DA
l_3291
	cmp #$06
	jne l_32C3

; optimize OK (service.pas), line = 3232

	lda FIRE.SHOT
	jeq l_32CF
	jsr REMOVE_FIRE
l_32CF

; optimize OK (service.pas), line = 3233

	:8 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3234

	jsr MODIFY_VAUS
s_32DA
; optimize OK (service.pas), line = 3235
	jmp s_330A
l_32C3
	cmp #$07
	jne l_32E1

; optimize OK (service.pas), line = 3239

	lda FIRE.SHOT
	jeq l_32ED
	jsr REMOVE_FIRE
l_32ED

; optimize OK (service.pas), line = 3240

	:8 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize FAIL ('MODIFY_VAUS', service.pas), line = 3241

	jsr MODIFY_VAUS

; optimize OK (service.pas), line = 3242

	lda #$00
	sta VAUS.LETTER

; optimize OK (service.pas), line = 3243

	ldy CUR_PLAYER
	lda adr.SCORE.LIVES,y
	add #$01
	sta adr.SCORE.LIVES,y

; optimize OK (service.pas), line = 3244

	sta PLOT_LIVES.LIVES
	lda #$00
	sta PLOT_LIVES.LIVES+1
	jsr PLOT_LIVES

; optimize OK (service.pas), line = 3245

	lda #$D0
	sta BALL_BLOCK_SOUND.A
	lda #$07
	sta BALL_BLOCK_SOUND.A+1
	lda #$0A
	sta BALL_BLOCK_SOUND.B
	lda #$00
	sta BALL_BLOCK_SOUND.B+1
	jsr BALL_BLOCK_SOUND
s_330A

; optimize OK (service.pas), line = 3246

	lda #$00
	sta FIRE.AVL
l_32E1
a_000A

; ------------------------------------------------------------

B1	= DATAORIGIN+$03F0
B1.X	= DATAORIGIN+$0000
B1.Y	= DATAORIGIN+$0002
B1.FINEX	= DATAORIGIN+$0004
B1.FINEY	= DATAORIGIN+$0006
B1.OLDX	= DATAORIGIN+$0008
B1.OLDY	= DATAORIGIN+$000A
B1.SPEED	= DATAORIGIN+$000C
B1.FINESPEED	= DATAORIGIN+$000E
B1.SPEEDX	= DATAORIGIN+$0010
B1.SPEEDY	= DATAORIGIN+$0012
B1.SBD	= DATAORIGIN+$0014
B1.BRWHIT	= DATAORIGIN+$0016
B1.INPLAY	= DATAORIGIN+$0017
B1.LAUNCH	= DATAORIGIN+$0018
B1.ONVAUS	= DATAORIGIN+$0019
B1.STM	= DATAORIGIN+$001B
B2	= DATAORIGIN+$03F4
B2.X	= DATAORIGIN+$0000
B2.Y	= DATAORIGIN+$0002
B2.FINEX	= DATAORIGIN+$0004
B2.FINEY	= DATAORIGIN+$0006
B2.OLDX	= DATAORIGIN+$0008
B2.OLDY	= DATAORIGIN+$000A
B2.SPEED	= DATAORIGIN+$000C
B2.FINESPEED	= DATAORIGIN+$000E
B2.SPEEDX	= DATAORIGIN+$0010
B2.SPEEDY	= DATAORIGIN+$0012
B2.SBD	= DATAORIGIN+$0014
B2.BRWHIT	= DATAORIGIN+$0016
B2.INPLAY	= DATAORIGIN+$0017
B2.LAUNCH	= DATAORIGIN+$0018
B2.ONVAUS	= DATAORIGIN+$0019
B2.STM	= DATAORIGIN+$001B
B3	= DATAORIGIN+$03F8
B3.X	= DATAORIGIN+$0000
B3.Y	= DATAORIGIN+$0002
B3.FINEX	= DATAORIGIN+$0004
B3.FINEY	= DATAORIGIN+$0006
B3.OLDX	= DATAORIGIN+$0008
B3.OLDY	= DATAORIGIN+$000A
B3.SPEED	= DATAORIGIN+$000C
B3.FINESPEED	= DATAORIGIN+$000E
B3.SPEEDX	= DATAORIGIN+$0010
B3.SPEEDY	= DATAORIGIN+$0012
B3.SBD	= DATAORIGIN+$0014
B3.BRWHIT	= DATAORIGIN+$0016
B3.INPLAY	= DATAORIGIN+$0017
B3.LAUNCH	= DATAORIGIN+$0018
B3.ONVAUS	= DATAORIGIN+$0019
B3.STM	= DATAORIGIN+$001B
X	= DATAORIGIN+$03FC
@CASETMP_000A	= DATAORIGIN+$03FE

@VarData	= B1
@VarDataSize	= 9

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DEVIATE_BALL					; PROCEDURE

; --- RepeatUntilProlog
l_3318

; optimize OK (service.pas), line = 3259

	lda BALL
	sta GET_BALL_DIRECTION.BALL
	lda BALL+1
	sta GET_BALL_DIRECTION.BALL+1
	jsr GET_BALL_DIRECTION
	inx
	mva GET_BALL_DIRECTION.RESULT :STACKORIGIN,x
	mva GET_BALL_DIRECTION.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	lda #$1E
	jsr SYSTEM.RANDOM.@010180000
	inx
	mva SYSTEM.RANDOM.@010180000.RESULT :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr addAX_CX
	lda :STACKORIGIN-1,x
	sub #$0F
	sta TEMP
	lda :STACKORIGIN-1+STACKWIDTH,x
	sbc #$00
	sta TEMP+1
	dex
	dex

; optimize OK (service.pas), line = 3260

	lda #$5A
	sta @SMALLINT.MOD.B
	lda #$00
	sta @SMALLINT.MOD.B+1
	lda TEMP
	sta @SMALLINT.MOD.A
	lda TEMP+1
	sta @SMALLINT.MOD.A+1
	jsr @SMALLINT.MOD
	lda @SMALLINT.MOD.RESULT
	cmp #$1F
	lda @SMALLINT.MOD.RESULT+1
	sbc #$00
	svc
	eor #$80
	jmi l_3318
	lda #$5A
	sta @SMALLINT.MOD.B
	lda #$00
	sta @SMALLINT.MOD.B+1
	lda TEMP
	sta @SMALLINT.MOD.A
	lda TEMP+1
	sta @SMALLINT.MOD.A+1
	jsr @SMALLINT.MOD
	lda @SMALLINT.MOD.RESULT
	cmp #$3C
	lda @SMALLINT.MOD.RESULT+1
	sbc #$00
	svc
	eor #$80
	jpl l_3318

; optimize OK (service.pas), line = 3262

	lda BALL
	sta SET_BALL_DIRECTION.BALL
	lda BALL+1
	sta SET_BALL_DIRECTION.BALL+1
	lda TEMP
	sta SET_BALL_DIRECTION.ANGLE
	lda TEMP+1
	sta SET_BALL_DIRECTION.ANGLE+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 3263

	mwy BALL :bp2
	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED
	iny
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED+1
	lda BALL
	sta SET_BALL_SPEED.BALL
	lda BALL+1
	sta SET_BALL_SPEED.BALL+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 3264

	mwy BALL :bp2
	ldy #BALL.SBD-DATAORIGIN
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; ------------------------------------------------------------

BALL	= DATAORIGIN+$03FF
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B
TEMP	= DATAORIGIN+$0403

@VarData	= BALL
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BOUNCEBALL					; FUNCTION

	jmp l_3358

.local	CHECK_BALL					; PROCEDURE

; optimize OK (service.pas), line = 3294

	mwy BALL :bp2
	ldy #BALL.INPLAY-DATAORIGIN
	lda (:bp2),y
	jeq l_3367

; optimize OK (service.pas), line = 3297

	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	iny
	cmp #$16
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jmi l_3384
	ldy #BALL.Y-DATAORIGIN
	lda (:bp2),y
	iny
	cmp #$8E
	lda (:bp2),y
	sbc #$00
	svc
	eor #$80
	jpl l_3384

; optimize OK (service.pas), line = 3298

	lda BALL
	sta BALL_HIT_BLOCK.BALL
	lda BALL+1
	sta BALL_HIT_BLOCK.BALL+1
	jsr BALL_HIT_BLOCK
l_3384

; optimize OK (service.pas), line = 3300

	lda BALL
	sta SET_BALL.BALL
	lda BALL+1
	sta SET_BALL.BALL+1
	jsr SET_BALL

; optimize FAIL ('BALL_SPEED', service.pas), line = 3301

	inx
	mva BALL :STACKORIGIN,x
	mva BALL+1 :STACKORIGIN+STACKWIDTH,x
	jsr BALL_SPEED
	mwy BALL :bp2
	ldy #BALL.SPEED-DATAORIGIN
	lda BALL_SPEED.RESULT
	sta (:bp2),y
	iny
	lda BALL_SPEED.RESULT+1
	sta (:bp2),y
l_3367

; ------------------------------------------------------------

BALL	= DATAORIGIN+$0467
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B

@VarData	= BALL
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	TEST_BALL					; PROCEDURE

; optimize OK (service.pas), line = 3309

	mwy BALL :bp2
	ldy #BALL.INPLAY-DATAORIGIN
	lda (:bp2),y
	jeq l_33A5

; optimize OK (service.pas), line = 3311

	ldy #BALL.FINESPEED-DATAORIGIN
	lda (:bp2),y
	add #$01
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 3313

	ldy #BALL.FINESPEED-DATAORIGIN
	lda (:bp2),y
	sta :STACKORIGIN+9
	iny
	lda (:bp2),y
	sta :STACKORIGIN+STACKWIDTH+9
	lda LV
	asl @
	tay
	lda adr.LEVEL,y
	sta :STACKORIGIN+10
	lda adr.LEVEL+1,y
	sta :STACKORIGIN+STACKWIDTH+10
	ldy #$00
	lda :STACKORIGIN+STACKWIDTH+9
	spl
	dey
	sta :STACKORIGIN+STACKWIDTH+9
	sty :STACKORIGIN+STACKWIDTH*2+9
	sty :STACKORIGIN+STACKWIDTH*3+9
	.LOCAL
	lda :STACKORIGIN+STACKWIDTH*3+9
	sub #$00
	bne L4
	lda :STACKORIGIN+STACKWIDTH*2+9
	cmp #$00
	bne L1
	lda :STACKORIGIN+STACKWIDTH+9
	cmp :STACKORIGIN+STACKWIDTH+10
	bne L1
	lda :STACKORIGIN+9
	cmp :STACKORIGIN+10
L1	beq L5
	bcs L3
	lda #$FF
	bne L5
L3	lda #$01
	bne L5
L4	bvc L5
	eor #$FF
	ora #$01
L5
	.ENDL
	jmi l_33BB
	jeq l_33BB

; optimize OK (service.pas), line = 3315

	ldy #BALL.FINESPEED-DATAORIGIN
	lda #$00
	sta (:bp2),y
	iny
	sta (:bp2),y

; optimize OK (service.pas), line = 3318

	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	iny
	cmp #$D0
	lda (:bp2),y
	sbc #$07
	svc
	eor #$80
	jpl l_33D1

; optimize OK (service.pas), line = 3320

	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	add #$0A
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 3321

	ldy #BALL.SPEED-DATAORIGIN
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED
	iny
	lda (:bp2),y
	sta SET_BALL_SPEED.SPEED+1
	lda BALL
	sta SET_BALL_SPEED.BALL
	lda BALL+1
	sta SET_BALL_SPEED.BALL+1
	jsr SET_BALL_SPEED
l_33D1
l_33BB

; optimize OK (service.pas), line = 3325

	mwy BALL :bp2
	ldy #BALL.SBD-DATAORIGIN
	lda (:bp2),y
	add #$01
	sta (:bp2),y
	iny
	lda (:bp2),y
	adc #$00
	sta (:bp2),y

; optimize OK (service.pas), line = 3329

	ldy #BALL.SBD-DATAORIGIN+$01
	lda (:bp2),y
	cmp #$02
	bne @+
	dey
	lda (:bp2),y
	cmp #$58
@
	jcc l_33F9
@
	ldy #$00
	lda (:bp2),y
	jpl l_33F9
@

; optimize OK (service.pas), line = 3330

	lda BALL
	sta DEVIATE_BALL.BALL
	lda BALL+1
	sta DEVIATE_BALL.BALL+1
	jsr DEVIATE_BALL
l_33F9
l_33A5

; ------------------------------------------------------------

BALL	= DATAORIGIN+$046B
BALL.X	= DATAORIGIN+$0000
BALL.Y	= DATAORIGIN+$0002
BALL.FINEX	= DATAORIGIN+$0004
BALL.FINEY	= DATAORIGIN+$0006
BALL.OLDX	= DATAORIGIN+$0008
BALL.OLDY	= DATAORIGIN+$000A
BALL.SPEED	= DATAORIGIN+$000C
BALL.FINESPEED	= DATAORIGIN+$000E
BALL.SPEEDX	= DATAORIGIN+$0010
BALL.SPEEDY	= DATAORIGIN+$0012
BALL.SBD	= DATAORIGIN+$0014
BALL.BRWHIT	= DATAORIGIN+$0016
BALL.INPLAY	= DATAORIGIN+$0017
BALL.LAUNCH	= DATAORIGIN+$0018
BALL.ONVAUS	= DATAORIGIN+$0019
BALL.STM	= DATAORIGIN+$001B

@VarData	= BALL
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_3358

; optimize OK (service.pas), line = 3338

	lda #$00
	sta SCRFLUXCNT

; optimize OK (service.pas), line = 3339

	sta SCRFLUX

; optimize OK (service.pas), line = 3341

	lda #$01
	sta BALLS_IN_PLAY

; optimize OK (service.pas), line = 3343

	lda #$00
	sta FIRE.AVL

; optimize OK (service.pas), line = 3344

	:8 mva adr.NORMAL+# adr.PLAYVAUS+#

; optimize OK (service.pas), line = 3346

	lda #$FF
	sta LETT.LAST
	sta LETT.LAST+1

; optimize OK (service.pas), line = 3347

	lda #$00
	sta LETT.ACTIVE

; optimize OK (service.pas), line = 3350

	lda PATTERN
	sta FILL_PICTURE_WITH_PATTERN.PATT
	lda PATTERN+1
	sta FILL_PICTURE_WITH_PATTERN.PATT+1
	jsr FILL_PICTURE_WITH_PATTERN

; optimize FAIL ('SHOWBTMPICTURE', service.pas), line = 3353

	inx
	mva PLAYSCREEN :STACKORIGIN,x
	mva PLAYSCREEN+1 :STACKORIGIN+STACKWIDTH,x
	jsr SHOWBTMPICTURE

; optimize OK (service.pas), line = 3357

	ldy CUR_PLAYER
	lda adr.SCORE.LIVES,y
	sta PLOT_LIVES.LIVES
	lda #$00
	sta PLOT_LIVES.LIVES+1
	jsr PLOT_LIVES

; optimize OK (service.pas), line = 3363

	lda adr.SCORE.PLAYER+$04
	sta WRITE_SCORE.SC
	lda adr.SCORE.PLAYER+1+$04
	sta WRITE_SCORE.SC+1
	lda adr.SCORE.PLAYER+2+$04
	sta WRITE_SCORE.SC+2
	lda adr.SCORE.PLAYER+3+$04
	sta WRITE_SCORE.SC+3
	lda #$FD
	sta WRITE_SCORE.PX
	lda #$00
	sta WRITE_SCORE.PX+1
	lda #$3C
	sta WRITE_SCORE.PY
	lda #$00
	sta WRITE_SCORE.PY+1
	jsr WRITE_SCORE

; optimize OK (service.pas), line = 3364

	lda adr.SCORE.PLAYER+$08
	sta WRITE_SCORE.SC
	lda adr.SCORE.PLAYER+1+$08
	sta WRITE_SCORE.SC+1
	lda adr.SCORE.PLAYER+2+$08
	sta WRITE_SCORE.SC+2
	lda adr.SCORE.PLAYER+3+$08
	sta WRITE_SCORE.SC+3
	lda #$FD
	sta WRITE_SCORE.PX
	lda #$00
	sta WRITE_SCORE.PX+1
	lda #$5D
	sta WRITE_SCORE.PY
	lda #$00
	sta WRITE_SCORE.PY+1
	jsr WRITE_SCORE

; optimize OK (service.pas), line = 3365

	lda #$FD
	sta WRITE_SCORE.PX
	lda #$00
	sta WRITE_SCORE.PX+1
	lda #$80
	sta WRITE_SCORE.PY
	lda #$00
	sta WRITE_SCORE.PY+1
	lda SCORE.HISCORE
	sta WRITE_SCORE.SC
	lda SCORE.HISCORE+1
	sta WRITE_SCORE.SC+1
	lda SCORE.HISCORE+2
	sta WRITE_SCORE.SC+2
	lda SCORE.HISCORE+3
	sta WRITE_SCORE.SC+3
	jsr WRITE_SCORE

; optimize FAIL ('PUT_WALL', service.pas), line = 3368

	jsr PUT_WALL

; optimize OK (service.pas), line = 3375

	lda #$01
	sta BALL0.INPLAY

; optimize OK (service.pas), line = 3376

	sta BALL0.LAUNCH

; optimize OK (service.pas), line = 3379

	lda #$6F
	sta BALL0.X
	lda #$00
	sta BALL0.X+1

; optimize OK (service.pas), line = 3380

	lda #$B5
	sta BALL0.Y
	lda #$00
	sta BALL0.Y+1

; optimize OK (service.pas), line = 3383

	lda #$FF
	sta BALL0.OLDX
	sta BALL0.OLDX+1

; optimize OK (service.pas), line = 3384

	sta BALL0.OLDY
	sta BALL0.OLDY+1

; optimize OK (service.pas), line = 3387

	lda #$00
	sta BALL0.SBD
	sta BALL0.SBD+1

; optimize OK (service.pas), line = 3391

	lda #$10
	sta BALL0.ONVAUS
	lda #$00
	sta BALL0.ONVAUS+1

; optimize OK (service.pas), line = 3396

	sta BALL0.STM

; optimize OK (service.pas), line = 3400

	lda #$E8
	sta SYSTEM.RANDOM.@010184000.RANGE
	lda #$03
	sta SYSTEM.RANDOM.@010184000.RANGE+1
	jsr SYSTEM.RANDOM.@010184000
	lda SYSTEM.RANDOM.@010184000.RESULT
	sta LETT.INCOMING
	lda SYSTEM.RANDOM.@010184000.RESULT+1
	sta LETT.INCOMING+1

; optimize FAIL ('CREATE_VAUS', service.pas), line = 3403

	jsr CREATE_VAUS

; optimize FAIL ('WRITE_ROUND_LEVEL', service.pas), line = 3406

	jsr WRITE_ROUND_LEVEL

; optimize FAIL ('SET_VAUS', service.pas), line = 3408

	jsr SET_VAUS

; optimize FAIL ('START_VAUS', service.pas), line = 3409

	jsr START_VAUS

; optimize OK (service.pas), line = 3410

	lda VAUS.X
	sta MOVE_VAUS.X
	lda #$00
	sta MOVE_VAUS.X+1
	lda #$B8
	sta MOVE_VAUS.Y
	lda #$00
	sta MOVE_VAUS.Y+1
	jsr MOVE_VAUS

; optimize FAIL ('START_LEVEL', service.pas), line = 3411

	jsr START_LEVEL

; optimize FAIL ('START_VAUS', service.pas), line = 3412

	jsr START_VAUS

; optimize FAIL ('REMOVE_ROUND_LEVEL', service.pas), line = 3413

	jsr REMOVE_ROUND_LEVEL

; optimize OK (service.pas), line = 3414

	lda BALL0
	sta SET_BALL.BALL
	lda BALL0+1
	sta SET_BALL.BALL+1
	jsr SET_BALL

; optimize OK (service.pas), line = 3421

	lda #$0F
	jsr SYSTEM.RANDOM.@010180000
	inx
	inx
	lda SYSTEM.RANDOM.@010180000.RESULT
	add #$3C
	sta :STACKORIGIN-1,x
	lda #$00
	adc #$00
	sta :STACKORIGIN-1+STACKWIDTH,x
	lda BALL0
	sta SET_BALL_DIRECTION.BALL
	lda BALL0+1
	sta SET_BALL_DIRECTION.BALL+1
	dex
	lda :STACKORIGIN,x
	sta SET_BALL_DIRECTION.ANGLE
	lda :STACKORIGIN+STACKWIDTH,x
	sta SET_BALL_DIRECTION.ANGLE+1
	dex
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 3423

	lda BALL0
	sta SET_BALL_SPEED.BALL
	lda BALL0+1
	sta SET_BALL_SPEED.BALL+1
	lda #$F4
	sta SET_BALL_SPEED.SPEED
	lda #$01
	sta SET_BALL_SPEED.SPEED+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 3426

	lda #$00
	sta BALL0.FINESPEED
	sta BALL0.FINESPEED+1

; optimize OK (service.pas), line = 3428

	sta BALL1.INPLAY

; optimize OK (service.pas), line = 3429

	sta BALL2.INPLAY

; optimize OK (service.pas), line = 3431

	lda VAUS.X
	sta X
	lda #$00
	sta X+1

; --- WhileProlog
	jmp l_3491
l_3492

; optimize FAIL ('WAIT_VBL', service.pas), line = 3435

	jsr WAIT_VBL

; optimize OK (service.pas), line = 3444

	lda <X
	sta MOUSECOORDS.X
	lda >X
	sta MOUSECOORDS.X+1
	jsr MOUSECOORDS

; optimize OK (service.pas), line = 3449

	lda TRAINER
	jne l_34A7
	lda X
	sta MOVE_VAUS.X
	lda X+1
	sta MOVE_VAUS.X+1
	lda #$B8
	sta MOVE_VAUS.Y
	lda #$00
	sta MOVE_VAUS.Y+1
	jmp l_34B5
l_34A7

; optimize OK (service.pas), line = 3455

	lda TRAINER
	cmp #$01
	jne l_34C7

; optimize FAIL (1, service.pas), line = 3456

	inx
	mva #$B8 :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	inx
	mva #$0A :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	lda BALL0.X
	sub BALL0.ONVAUS
	sta MAX.A
	lda BALL0.X+1
	sbc BALL0.ONVAUS+1
	sta MAX.A+1
	lda :STACKORIGIN,x
	sta MAX.B
	lda :STACKORIGIN+STACKWIDTH,x
	sta MAX.B+1
	dex
	jsr MAX
	lda #$B8
	sta MIN.A
	lda #$00
	sta MIN.A+1
	lda MAX.RESULT
	sta MIN.B
	lda MAX.RESULT+1
	sta MIN.B+1
	jsr MIN
	lda MIN.RESULT
	sta MOVE_VAUS.X
	lda MIN.RESULT+1
	sta MOVE_VAUS.X+1
	lda :STACKORIGIN,x
	sta MOVE_VAUS.Y
	lda :STACKORIGIN+STACKWIDTH,x
	sta MOVE_VAUS.Y+1
	dex
l_34B5
	jsr MOVE_VAUS
l_34C7

; optimize OK (service.pas), line = 3461

	lda BALL0.LAUNCH
	cmp #$01
	jne l_34E9

; optimize FAIL (0, service.pas), line = 3463

	inc BALL0.STM

; optimize OK (service.pas), line = 3468

	lda BALL0.STM
	cmp #$FA
	jne l_3500
	lda #$00
	sta BALL0.LAUNCH
l_3500

; optimize OK (service.pas), line = 3471

	lda BALL0
	sta START_BALL.BALL
	lda BALL0+1
	sta START_BALL.BALL+1
	jsr START_BALL

; optimize FAIL ('MOUSECLICK', service.pas), line = 3474

	jsr MOUSECLICK
	lda MOUSECLICK.RESULT
	cmp #$01
	jne l_351A
	lda #$00
	sta BALL0.LAUNCH
l_351A
	jmp l_352A
l_34E9

; optimize OK (service.pas), line = 3482

	lda BALL0.INPLAY
	jeq l_3536
	lda BALL0
	sta MOVE_BALL.BALL
	lda BALL0+1
	sta MOVE_BALL.BALL+1
	jsr MOVE_BALL
l_3536

; optimize OK (service.pas), line = 3483

	lda BALL1.INPLAY
	jeq l_3548
	lda BALL1
	sta MOVE_BALL.BALL
	lda BALL1+1
	sta MOVE_BALL.BALL+1
	jsr MOVE_BALL
l_3548

; optimize OK (service.pas), line = 3484

	lda BALL2.INPLAY
	jeq l_355A
	lda BALL2
	sta MOVE_BALL.BALL
	lda BALL2+1
	sta MOVE_BALL.BALL+1
	jsr MOVE_BALL
l_355A
l_352A

; optimize OK (service.pas), line = 3492

	lda BALL0
	sta CHECK_BALL.BALL
	lda BALL0+1
	sta CHECK_BALL.BALL+1
	jsr CHECK_BALL

; optimize OK (service.pas), line = 3493

	lda BALL1
	sta CHECK_BALL.BALL
	lda BALL1+1
	sta CHECK_BALL.BALL+1
	jsr CHECK_BALL

; optimize OK (service.pas), line = 3494

	lda BALL2
	sta CHECK_BALL.BALL
	lda BALL2+1
	sta CHECK_BALL.BALL+1
	jsr CHECK_BALL

; optimize FAIL ('CHECKSHINE', service.pas), line = 3509

	jsr CHECKSHINE

; optimize FAIL ('CHECK_LETTER', service.pas), line = 3510

	jsr CHECK_LETTER

; optimize OK (service.pas), line = 3511

	lda BALL0
	sta CHECK_BONUS_TYPE.B1
	lda BALL0+1
	sta CHECK_BONUS_TYPE.B1+1
	lda BALL1
	sta CHECK_BONUS_TYPE.B2
	lda BALL1+1
	sta CHECK_BONUS_TYPE.B2+1
	lda BALL2
	sta CHECK_BONUS_TYPE.B3
	lda BALL2+1
	sta CHECK_BONUS_TYPE.B3+1
	jsr CHECK_BONUS_TYPE

; optimize FAIL ('CHECK_FIRE', service.pas), line = 3512

	jsr CHECK_FIRE

; optimize FAIL ('CHECK_FLUX', service.pas), line = 3513

	jsr CHECK_FLUX

; optimize OK (service.pas), line = 3515

	lda VAUS.X
	add VAUS.WIDTH
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	ldy #1
	cmp #$00
	bne @+
	lda :STACKORIGIN+9
	cmp #$D7
@
	beq @+
	dey
@
	tya
	and SCRFLUX
	jeq l_3592
	jsr VAUS_OUT
l_3592

; optimize OK (service.pas), line = 3517

	lda VAUS.LETTER
	cmp #$04
	jne l_35A8

; optimize OK (service.pas), line = 3519

	lda #$03
	sta BALLS_IN_PLAY

; optimize OK (service.pas), line = 3521

	mwy BALL1 :bp2
	ldy #$1B
	mva:rpl adr.BALL0,y (:bp2),y-

; optimize OK (service.pas), line = 3522

	mwy BALL2 :bp2
	ldy #$1B
	mva:rpl adr.BALL0,y (:bp2),y-

; optimize OK (service.pas), line = 3524

	lda BALL0
	sta GET_BALL_DIRECTION.BALL
	lda BALL0+1
	sta GET_BALL_DIRECTION.BALL+1
	jsr GET_BALL_DIRECTION
	inx
	inx
	lda #$5A
	sta @SMALLINT.DIV.B
	lda #$00
	sta @SMALLINT.DIV.B+1
	lda GET_BALL_DIRECTION.RESULT
	sta @SMALLINT.DIV.A
	lda GET_BALL_DIRECTION.RESULT+1
	sta @SMALLINT.DIV.A+1
	jsr @SMALLINT.DIV
	dex
	lda :eax
	sta T1
	lda :eax+1
	sta T1+1
	dex

; optimize OK (service.pas), line = 3526

	lda BALL0.SPEED
	sta T2
	lda BALL0.SPEED+1
	sta T2+1

; optimize OK (service.pas), line = 3533

	lda #$5A
	sta :ecx
	lda #$00
	sta :ecx+1
	lda T1
	sta :eax
	lda T1+1
	sta :eax+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda :eax
	sta HLP
	lda :eax+1
	sta HLP+1

; optimize OK (service.pas), line = 3535

	lda HLP
	add #$1E
	sta SET_BALL_DIRECTION.ANGLE
	lda HLP+1
	adc #$00
	sta SET_BALL_DIRECTION.ANGLE+1
	lda BALL0
	sta SET_BALL_DIRECTION.BALL
	lda BALL0+1
	sta SET_BALL_DIRECTION.BALL+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 3536

	lda HLP
	add #$2D
	sta SET_BALL_DIRECTION.ANGLE
	lda HLP+1
	adc #$00
	sta SET_BALL_DIRECTION.ANGLE+1
	lda BALL1
	sta SET_BALL_DIRECTION.BALL
	lda BALL1+1
	sta SET_BALL_DIRECTION.BALL+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 3537

	lda HLP
	add #$3C
	sta SET_BALL_DIRECTION.ANGLE
	lda HLP+1
	adc #$00
	sta SET_BALL_DIRECTION.ANGLE+1
	lda BALL2
	sta SET_BALL_DIRECTION.BALL
	lda BALL2+1
	sta SET_BALL_DIRECTION.BALL+1
	jsr SET_BALL_DIRECTION

; optimize OK (service.pas), line = 3541

	lda BALL0
	sta SET_BALL_SPEED.BALL
	lda BALL0+1
	sta SET_BALL_SPEED.BALL+1
	lda T2
	sta SET_BALL_SPEED.SPEED
	lda T2+1
	sta SET_BALL_SPEED.SPEED+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 3542

	lda BALL1
	sta SET_BALL_SPEED.BALL
	lda BALL1+1
	sta SET_BALL_SPEED.BALL+1
	lda T2
	sta SET_BALL_SPEED.SPEED
	lda T2+1
	sta SET_BALL_SPEED.SPEED+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 3543

	lda BALL2
	sta SET_BALL_SPEED.BALL
	lda BALL2+1
	sta SET_BALL_SPEED.BALL+1
	lda T2
	sta SET_BALL_SPEED.SPEED
	lda T2+1
	sta SET_BALL_SPEED.SPEED+1
	jsr SET_BALL_SPEED

; optimize OK (service.pas), line = 3545

	lda #$00
	sta VAUS.LETTER
l_35A8

; optimize OK (service.pas), line = 3549

	lda BALLS_IN_PLAY
	cmp #$02
	jcc l_360B
	lda #$00
	sta LETT.INCOMING
	sta LETT.INCOMING+1
l_360B

; optimize OK (service.pas), line = 3552

	lda CUR_PLAYER
	asl @
	asl @
	tay
	lda adr.SCORE.PLAYER,y
	sta WRITE_SCORE.SC
	lda adr.SCORE.PLAYER+1,y
	sta WRITE_SCORE.SC+1
	lda adr.SCORE.PLAYER+2,y
	sta WRITE_SCORE.SC+2
	lda adr.SCORE.PLAYER+3,y
	sta WRITE_SCORE.SC+3
	ldy CUR_PLAYER
	lda adr.POS_DIGIT,y
	sta WRITE_SCORE.PY
	lda #$FD
	sta WRITE_SCORE.PX
	lda #$00
	sta WRITE_SCORE.PX+1
	sta WRITE_SCORE.PY+1
	jsr WRITE_SCORE

; optimize OK (service.pas), line = 3555

	lda CUR_PLAYER
	asl @
	asl @
	tay
	.LOCAL
	lda adr.SCORE.PLAYER+3,y
	sub SCORE.HISCORE+3
	bne L4
	lda adr.SCORE.PLAYER+2,y
	cmp SCORE.HISCORE+2
	bne L1
	lda adr.SCORE.PLAYER+1,y
	cmp SCORE.HISCORE+1
	bne L1
	lda adr.SCORE.PLAYER,y
	cmp SCORE.HISCORE
L1	beq L5
	bcs L3
	lda #$FF
	bne L5
L3	lda #$01
	bne L5
L4	bvc L5
	eor #$FF
	ora #$01
L5
	.ENDL
	jmi l_3631
	jeq l_3631

; optimize OK (service.pas), line = 3558

	lda adr.SCORE.PLAYER,y
	sta SCORE.HISCORE
	lda adr.SCORE.PLAYER+1,y
	sta SCORE.HISCORE+1
	lda adr.SCORE.PLAYER+2,y
	sta SCORE.HISCORE+2
	lda adr.SCORE.PLAYER+3,y
	sta SCORE.HISCORE+3

; optimize OK (service.pas), line = 3560

	lda #$FD
	sta WRITE_SCORE.PX
	lda #$00
	sta WRITE_SCORE.PX+1
	lda #$80
	sta WRITE_SCORE.PY
	lda #$00
	sta WRITE_SCORE.PY+1
	lda SCORE.HISCORE
	sta WRITE_SCORE.SC
	lda SCORE.HISCORE+1
	sta WRITE_SCORE.SC+1
	lda SCORE.HISCORE+2
	sta WRITE_SCORE.SC+2
	lda SCORE.HISCORE+3
	sta WRITE_SCORE.SC+3
	jsr WRITE_SCORE
l_3631

; optimize OK (service.pas), line = 3567

	lda BALL0
	sta TEST_BALL.BALL
	lda BALL0+1
	sta TEST_BALL.BALL+1
	jsr TEST_BALL

; optimize OK (service.pas), line = 3568

	lda BALL1
	sta TEST_BALL.BALL
	lda BALL1+1
	sta TEST_BALL.BALL+1
	jsr TEST_BALL

; optimize OK (service.pas), line = 3569

	lda BALL2
	sta TEST_BALL.BALL
	lda BALL2+1
	sta TEST_BALL.BALL+1
	jsr TEST_BALL

; optimize OK (service.pas), line = 3610

	lda BALL0.INPLAY
	jne l_3657

; optimize OK (service.pas), line = 3612

	mwy BALL0 :bp2
	ldy #$1B
	mva:rpl adr.BALL1,y (:bp2),y-

; optimize OK (service.pas), line = 3613

	mwy BALL1 :bp2
	ldy #$1B
	mva:rpl adr.BALL2,y (:bp2),y-

; optimize OK (service.pas), line = 3614

	sta BALL2.INPLAY
l_3657

; optimize OK (service.pas), line = 3617

	lda #$00
	sta BALLS_IN_PLAY

; optimize OK (service.pas), line = 3619

	lda BALL0.INPLAY
	jeq l_3672
	inc BALLS_IN_PLAY
l_3672

; optimize OK (service.pas), line = 3620

	lda BALL1.INPLAY
	jeq l_3685
	inc BALLS_IN_PLAY
l_3685

; optimize OK (service.pas), line = 3621

	lda BALL2.INPLAY
	jeq l_3698
	inc BALLS_IN_PLAY
l_3698

; optimize OK (service.pas), line = 3624

	lda BALL0.INPLAY
	jne l_36AE

; optimize OK (service.pas), line = 3626

	lda #$01
	sta BALL0.LAUNCH

; optimize OK (service.pas), line = 3627

	lda BALL0
	sta REMOVE_BALL.BALL
	lda BALL0+1
	sta REMOVE_BALL.BALL+1
	jsr REMOVE_BALL

; optimize FAIL ('DESTROY_VAUS', service.pas), line = 3628

	jsr DESTROY_VAUS

; optimize OK (service.pas), line = 3629

	ldy CUR_PLAYER
	lda adr.SCORE.LIVES,y
	sub #$01
	sta adr.SCORE.LIVES,y

; optimize OK (service.pas), line = 3630

	lda WALL_P
	sta @move.dst
	lda CUR_PLAYER
	add WALL_P+1
	sta @move.dst+1
	lda WALL
	sta @move.src
	lda WALL+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move

; optimize FAIL ('NOSOUND', service.pas), line = 3638

	jsr NOSOUND
l_36AE
l_3491

; optimize OK (service.pas), line = 3433

	lda REMAIN_BLK
	jeq l_3492w
	lda BALL0.INPLAY
	jeq l_3492w
	lda SCORE.ABORTPLAY
	jeq l_3492
l_3492w

; optimize OK (service.pas), line = 3694

	lda #$00
	sta RESULT

; optimize OK (service.pas), line = 3695

	lda REMAIN_BLK
	jne l_36FC
	lda #$01
	sta RESULT
l_36FC
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$0405
X	= DATAORIGIN+$0406
Y	= DATAORIGIN+$0408
KEY	= DATAORIGIN+$040A
T1	= DATAORIGIN+$040C
T2	= DATAORIGIN+$040E
HLP	= DATAORIGIN+$0410
CN	= DATAORIGIN+$0412
adr.BALL0	= DATAORIGIN+$0413	; [28] RECORD
.var BALL0	= adr.BALL0 .word
BALL0.X	= DATAORIGIN+$0413
BALL0.Y	= DATAORIGIN+$0415
BALL0.FINEX	= DATAORIGIN+$0417
BALL0.FINEY	= DATAORIGIN+$0419
BALL0.OLDX	= DATAORIGIN+$041B
BALL0.OLDY	= DATAORIGIN+$041D
BALL0.SPEED	= DATAORIGIN+$041F
BALL0.FINESPEED	= DATAORIGIN+$0421
BALL0.SPEEDX	= DATAORIGIN+$0423
BALL0.SPEEDY	= DATAORIGIN+$0425
BALL0.SBD	= DATAORIGIN+$0427
BALL0.BRWHIT	= DATAORIGIN+$0429
BALL0.INPLAY	= DATAORIGIN+$042A
BALL0.LAUNCH	= DATAORIGIN+$042B
BALL0.ONVAUS	= DATAORIGIN+$042C
BALL0.STM	= DATAORIGIN+$042E
adr.BALL1	= DATAORIGIN+$042F	; [28] RECORD
.var BALL1	= adr.BALL1 .word
BALL1.X	= DATAORIGIN+$042F
BALL1.Y	= DATAORIGIN+$0431
BALL1.FINEX	= DATAORIGIN+$0433
BALL1.FINEY	= DATAORIGIN+$0435
BALL1.OLDX	= DATAORIGIN+$0437
BALL1.OLDY	= DATAORIGIN+$0439
BALL1.SPEED	= DATAORIGIN+$043B
BALL1.FINESPEED	= DATAORIGIN+$043D
BALL1.SPEEDX	= DATAORIGIN+$043F
BALL1.SPEEDY	= DATAORIGIN+$0441
BALL1.SBD	= DATAORIGIN+$0443
BALL1.BRWHIT	= DATAORIGIN+$0445
BALL1.INPLAY	= DATAORIGIN+$0446
BALL1.LAUNCH	= DATAORIGIN+$0447
BALL1.ONVAUS	= DATAORIGIN+$0448
BALL1.STM	= DATAORIGIN+$044A
adr.BALL2	= DATAORIGIN+$044B	; [28] RECORD
.var BALL2	= adr.BALL2 .word
BALL2.X	= DATAORIGIN+$044B
BALL2.Y	= DATAORIGIN+$044D
BALL2.FINEX	= DATAORIGIN+$044F
BALL2.FINEY	= DATAORIGIN+$0451
BALL2.OLDX	= DATAORIGIN+$0453
BALL2.OLDY	= DATAORIGIN+$0455
BALL2.SPEED	= DATAORIGIN+$0457
BALL2.FINESPEED	= DATAORIGIN+$0459
BALL2.SPEEDX	= DATAORIGIN+$045B
BALL2.SPEEDY	= DATAORIGIN+$045D
BALL2.SBD	= DATAORIGIN+$045F
BALL2.BRWHIT	= DATAORIGIN+$0461
BALL2.INPLAY	= DATAORIGIN+$0462
BALL2.LAUNCH	= DATAORIGIN+$0463
BALL2.ONVAUS	= DATAORIGIN+$0464
BALL2.STM	= DATAORIGIN+$0466

@VarData	= X
@VarDataSize	= 97

	rts						; ret
.endl

.local	CHOOSE_START_WALL				; FUNCTION

; optimize OK (service.pas), line = 3718

	lda #$01
	sta ST
	lda #$00
	sta ST+1

; optimize OK (service.pas), line = 3776

	lda ST
	sta RESULT
	lda ST+1
	sta RESULT+1
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$046F
PX	= $46
PY	= $64
DX	= $22
DY	= $23
DDX	= $13
DDY	= $0E
X	= DATAORIGIN+$0471
Y	= DATAORIGIN+$0473
ST	= DATAORIGIN+$0475
OLDX	= DATAORIGIN+$0477
OLDY	= DATAORIGIN+$0479
NEWX	= DATAORIGIN+$047B
NEWY	= DATAORIGIN+$047D

@VarData	= X
@VarDataSize	= 14

	rts						; ret
.endl

.local	SET_START_PARAMETERS				; PROCEDURE

; optimize OK (service.pas), line = 3785

	lda #$01
	sta X

l_371D
; --- ForToDoCondition
	lda X
	cmp #$03
	jcs l_372B

; optimize OK (service.pas), line = 3787

	asl @
	asl @
	tay
	lda #$00
	sta adr.SCORE.PLAYER,y
	sta adr.SCORE.PLAYER+1,y
	sta adr.SCORE.PLAYER+2,y
	sta adr.SCORE.PLAYER+3,y

; optimize OK (service.pas), line = 3788

	ldy X
	lda #$05
	sta adr.SCORE.LIVES,y

; optimize OK (service.pas), line = 3789

	lda #$01
	sta adr.SCORE.WALL_N,y

; optimize OK (service.pas), line = 3790

	lda WALL_P
	sta @move.dst
	lda X
	add WALL_P+1
	sta @move.dst+1
	lda ALL_WALLS
	sta @move.src
	lda ALL_WALLS+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move

; optimize OK (service.pas), line = 3792

	ldy X
	lda #$00
	sta adr.SCORE.ROUNDSEL,y

; --- ForToDoEpilog
	inc X
	jne l_371D
l_372B

; optimize OK (service.pas), line = 3795

	lda #$01
	sta CUR_PLAYER

; ------------------------------------------------------------

X	= DATAORIGIN+$047F

@VarData	= X
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	MAINSCREEN					; FUNCTION

; optimize FAIL ('NOSOUND', service.pas), line = 3855

	jsr NOSOUND

; optimize OK (service.pas), line = 3856

	lda #$00
	sta SCORE.ABORTPLAY

; optimize OK (service.pas), line = 3867

	lda PRESENTS.OFS
	sta BLITBOX.SRC
	lda PRESENTS.OFS+1
	sta BLITBOX.SRC+1
	lda PRESENTS.OFS+2
	sta BLITBOX.SRC+2
	lda PRESENTS.OFS+3
	sta BLITBOX.SRC+3
	lda #$00
	sta BLITBOX.DST
	lda #$50
	sta BLITBOX.DST+1
	lda #$00
	sta BLITBOX.DST+2
	sta BLITBOX.DST+3
	lda #$40
	sta BLITBOX.W
	lda #$01
	sta BLITBOX.W+1
	lda #$C8
	sta BLITBOX.H
	jsr BLITBOX

; optimize OK (service.pas), line = 3905

	lda #$01
	sta RESULT
	lda #$00
	sta RESULT+1
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$0480
X	= DATAORIGIN+$0482
Y	= DATAORIGIN+$0484
Z	= DATAORIGIN+$0486
K	= DATAORIGIN+$0488
IK	= DATAORIGIN+$048A

@VarData	= X
@VarDataSize	= 10

	rts						; ret
.endl

.local	START_GAME					; PROCEDURE

; optimize FAIL ('SET_START_PARAMETERS', service.pas), line = 3913

	jsr SET_START_PARAMETERS

; optimize OK (service.pas), line = 3914

	lda PLAYERS+1
	bne @+
	lda PLAYERS
	cmp #$01
@
	jne l_378A
	lda #$00
	sta adr.SCORE.LIVES+$02
l_378A

; optimize OK (service.pas), line = 3917

	lda #$00
	sta TRAINER

; optimize OK (service.pas), line = 3918

	lda WALL
	sta @move.dst
	lda WALL+1
	sta @move.dst+1
	lda WALL_P
	sta @move.src
	lda CUR_PLAYER
	add WALL_P+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move

; optimize FAIL ('SET_WALL', service.pas), line = 3922

	jsr SET_WALL

; optimize OK (service.pas), line = 3924

	lda PATTERN
	sta FILL_PICTURE_WITH_PATTERN.PATT
	lda PATTERN+1
	sta FILL_PICTURE_WITH_PATTERN.PATT+1
	jsr FILL_PICTURE_WITH_PATTERN

; optimize FAIL ('SHOWBTMPICTURE', service.pas), line = 3925

	inx
	mva PLAYSCREEN :STACKORIGIN,x
	mva PLAYSCREEN+1 :STACKORIGIN+STACKWIDTH,x
	jsr SHOWBTMPICTURE

; optimize OK (service.pas), line = 3932

	lda adr.SCORE.PLAYER+$04
	sta WRITE_SCORE.SC
	lda adr.SCORE.PLAYER+1+$04
	sta WRITE_SCORE.SC+1
	lda adr.SCORE.PLAYER+2+$04
	sta WRITE_SCORE.SC+2
	lda adr.SCORE.PLAYER+3+$04
	sta WRITE_SCORE.SC+3
	lda #$FD
	sta WRITE_SCORE.PX
	lda #$00
	sta WRITE_SCORE.PX+1
	lda #$3C
	sta WRITE_SCORE.PY
	lda #$00
	sta WRITE_SCORE.PY+1
	jsr WRITE_SCORE

; optimize OK (service.pas), line = 3933

	lda adr.SCORE.PLAYER+$08
	sta WRITE_SCORE.SC
	lda adr.SCORE.PLAYER+1+$08
	sta WRITE_SCORE.SC+1
	lda adr.SCORE.PLAYER+2+$08
	sta WRITE_SCORE.SC+2
	lda adr.SCORE.PLAYER+3+$08
	sta WRITE_SCORE.SC+3
	lda #$FD
	sta WRITE_SCORE.PX
	lda #$00
	sta WRITE_SCORE.PX+1
	lda #$5D
	sta WRITE_SCORE.PY
	lda #$00
	sta WRITE_SCORE.PY+1
	jsr WRITE_SCORE

; optimize OK (service.pas), line = 3934

	lda #$FD
	sta WRITE_SCORE.PX
	lda #$00
	sta WRITE_SCORE.PX+1
	lda #$80
	sta WRITE_SCORE.PY
	lda #$00
	sta WRITE_SCORE.PY+1
	lda SCORE.HISCORE
	sta WRITE_SCORE.SC
	lda SCORE.HISCORE+1
	sta WRITE_SCORE.SC+1
	lda SCORE.HISCORE+2
	sta WRITE_SCORE.SC+2
	lda SCORE.HISCORE+3
	sta WRITE_SCORE.SC+3
	jsr WRITE_SCORE

; --- RepeatUntilProlog
l_37B9

; --- RepeatUntilProlog
l_37BA

; optimize OK (service.pas), line = 3944

	ldy CUR_PLAYER
	lda adr.SCORE.ROUNDSEL,y
	jne l_37CC

; optimize FAIL (1, service.pas), line = 3946

	inx
	mva CUR_PLAYER :STACKORIGIN,x
	mva #$00 :STACKORIGIN+STACKWIDTH,x
	jsr CHOOSE_START_WALL
	inx
	mva CHOOSE_START_WALL.RESULT :STACKORIGIN,x
	mva CHOOSE_START_WALL.RESULT+1 :STACKORIGIN+STACKWIDTH,x
	ldy :STACKORIGIN-1,x
	lda :STACKORIGIN,x
	sta adr.SCORE.WALL_N,y
	dex
	dex

; optimize OK (service.pas), line = 3949

	lda #$00
	sta :STACKORIGIN+9
	lda CUR_PLAYER
	sta :STACKORIGIN+STACKWIDTH+9
	ldy CUR_PLAYER
	lda adr.SCORE.WALL_N,y
	sub #$01
	sta :eax
	lda #$00
	sbc #$00
	sta :eax+1
	lda #$00
	sta :ecx
	lda #$01
	sta :ecx+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda WALL_P
	add :STACKORIGIN+9
	sta @move.dst
	lda WALL_P+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta @move.dst+1
	lda :eax
	add ALL_WALLS
	sta @move.src
	lda :eax+1
	adc ALL_WALLS+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move

; optimize OK (service.pas), line = 3953

	ldy CUR_PLAYER
	lda #$01
	sta adr.SCORE.ROUNDSEL,y
l_37CC

; optimize OK (service.pas), line = 3957

	lda WALL
	sta @move.dst
	lda WALL+1
	sta @move.dst+1
	lda WALL_P
	sta @move.src
	lda CUR_PLAYER
	add WALL_P+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move

; optimize FAIL ('SET_WALL', service.pas), line = 3958

	jsr SET_WALL

; optimize FAIL ('BOUNCEBALL', service.pas), line = 3963

	jsr BOUNCEBALL
	lda BOUNCEBALL.RESULT
	sta NWALL

; optimize OK (service.pas), line = 3966

	jeq l_381A

; optimize OK (service.pas), line = 3969

	ldy CUR_PLAYER
	lda adr.SCORE.WALL_N,y
	add #$01
	sta adr.SCORE.WALL_N,y

; optimize OK (service.pas), line = 3972

	lda TOTALWALL
	cmp adr.SCORE.WALL_N,y
	jcs l_3836

; optimize OK (service.pas), line = 3973

	lda #$01
	sta adr.SCORE.WALL_N,y
l_3836

; optimize OK (service.pas), line = 3976

	lda #$00
	sta :STACKORIGIN+9
	lda CUR_PLAYER
	sta :STACKORIGIN+STACKWIDTH+9
	ldy CUR_PLAYER
	lda adr.SCORE.WALL_N,y
	sub #$01
	sta :eax
	lda #$00
	sbc #$00
	sta :eax+1
	lda #$00
	sta :ecx
	lda #$01
	sta :ecx+1
	.ifdef fmulinit
	fmulu_16
	els
	imulCX
	eif
	lda WALL_P
	add :STACKORIGIN+9
	sta @move.dst
	lda WALL_P+1
	adc :STACKORIGIN+STACKWIDTH+9
	sta @move.dst+1
	lda :eax
	add ALL_WALLS
	sta @move.src
	lda :eax+1
	adc ALL_WALLS+1
	sta @move.src+1
	lda <256
	sta @move.cnt
	lda >256
	sta @move.cnt+1
	jsr @move
	jmp l_3868
l_381A

; optimize OK (service.pas), line = 3982

	ldy CUR_PLAYER
	lda adr.SCORE.LIVES,y
	jne l_387D
	jsr GAME_OVER
l_3868
l_387D

; optimize OK (service.pas), line = 3987

	lda NWALL
	jne l_37BA

; optimize FAIL (0, service.pas), line = 3990

	inc CUR_PLAYER

; optimize OK (service.pas), line = 3991

	lda PLAYERS
	cmp CUR_PLAYER
	lda PLAYERS+1
	sbc #$00
	svc
	eor #$80
	jpl l_38A5
	lda #$01
	sta CUR_PLAYER
l_38A5

; optimize OK (service.pas), line = 3997

	ldy CUR_PLAYER
	lda adr.SCORE.LIVES,y
	jne l_38C1
	lda #$03
	sub CUR_PLAYER
	sta CUR_PLAYER
l_38C1

; optimize OK (service.pas), line = 4002

	ldy #1
	lda adr.SCORE.LIVES+$01
	beq @+
	dey
@
	sty :STACKORIGIN+9
	ldy #1
	lda adr.SCORE.LIVES+$02
	beq @+
	dey
@
	tya
	and :STACKORIGIN+9
	ora SCORE.ABORTPLAY
	jeq l_37B9

; ------------------------------------------------------------

PLAYERS	= DATAORIGIN+$048C
NWALL	= DATAORIGIN+$048E

@VarData	= PLAYERS
@VarDataSize	= 3

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	INIT_GAME					; PROCEDURE

; optimize FAIL ('SYSTEM.RANDOMIZE', arkanoid_vbxe.pas), line = 123

	jsr SYSTEM.RANDOMIZE

; optimize FAIL ('INITSVGA', arkanoid_vbxe.pas), line = 125

	jsr INITSVGA

; optimize FAIL ('INITROWARRAY', arkanoid_vbxe.pas), line = 126

	jsr INITROWARRAY

; optimize OK (btm.inc), line = 1

	lda #$00
	sta PLAYSCREEN.OFS
	lda #$5E
	sta PLAYSCREEN.OFS+1
	lda #$01
	sta PLAYSCREEN.OFS+2
	lda #$00
	sta PLAYSCREEN.OFS+3

; optimize OK (btm.inc), line = 2

	lda #$40
	sta PLAYSCREEN.WIDTH
	lda #$01
	sta PLAYSCREEN.WIDTH+1

; optimize OK (btm.inc), line = 3

	lda #$C8
	sta PLAYSCREEN.HEIGHT
	lda #$00
	sta PLAYSCREEN.HEIGHT+1

; optimize OK (btm.inc), line = 5

	sta PRESENTS.OFS
	lda #$58
	sta PRESENTS.OFS+1
	lda #$02
	sta PRESENTS.OFS+2
	lda #$00
	sta PRESENTS.OFS+3

; optimize OK (btm.inc), line = 6

	lda #$40
	sta PRESENTS.WIDTH
	lda #$01
	sta PRESENTS.WIDTH+1

; optimize OK (btm.inc), line = 7

	lda #$C8
	sta PRESENTS.HEIGHT
	lda #$00
	sta PRESENTS.HEIGHT+1

; optimize OK (btm.inc), line = 9

	sta EXPLOSION.OFS
	lda #$52
	sta EXPLOSION.OFS+1
	lda #$03
	sta EXPLOSION.OFS+2
	lda #$00
	sta EXPLOSION.OFS+3

; optimize OK (btm.inc), line = 10

	lda #$2A
	sta EXPLOSION.WIDTH
	lda #$00
	sta EXPLOSION.WIDTH+1

; optimize OK (btm.inc), line = 11

	lda #$72
	sta EXPLOSION.HEIGHT
	lda #$00
	sta EXPLOSION.HEIGHT+1

; optimize OK (btm.inc), line = 13

	lda #$B4
	sta NEWVAUS.OFS
	lda #$64
	sta NEWVAUS.OFS+1
	lda #$03
	sta NEWVAUS.OFS+2
	lda #$00
	sta NEWVAUS.OFS+3

; optimize OK (btm.inc), line = 14

	lda #$29
	sta NEWVAUS.WIDTH
	lda #$00
	sta NEWVAUS.WIDTH+1

; optimize OK (btm.inc), line = 15

	lda #$C1
	sta NEWVAUS.HEIGHT
	lda #$00
	sta NEWVAUS.HEIGHT+1

; optimize OK (btm.inc), line = 17

	lda #$9D
	sta SOUNDFX.OFS
	lda #$83
	sta SOUNDFX.OFS+1
	lda #$03
	sta SOUNDFX.OFS+2
	lda #$00
	sta SOUNDFX.OFS+3

; optimize OK (btm.inc), line = 18

	lda #$15
	sta SOUNDFX.WIDTH
	lda #$00
	sta SOUNDFX.WIDTH+1

; optimize OK (btm.inc), line = 19

	lda #$26
	sta SOUNDFX.HEIGHT
	lda #$00
	sta SOUNDFX.HEIGHT+1

; optimize OK (btm.inc), line = 21

	lda #$BB
	sta SHINEWALL.OFS
	lda #$86
	sta SHINEWALL.OFS+1
	lda #$03
	sta SHINEWALL.OFS+2
	lda #$00
	sta SHINEWALL.OFS+3

; optimize OK (btm.inc), line = 22

	lda #$10
	sta SHINEWALL.WIDTH
	lda #$00
	sta SHINEWALL.WIDTH+1

; optimize OK (btm.inc), line = 23

	lda #$50
	sta SHINEWALL.HEIGHT
	lda #$00
	sta SHINEWALL.HEIGHT+1

; optimize OK (btm.inc), line = 25

	lda #$BB
	sta MINIVAUS.OFS
	lda #$8B
	sta MINIVAUS.OFS+1
	lda #$03
	sta MINIVAUS.OFS+2
	lda #$00
	sta MINIVAUS.OFS+3

; optimize OK (btm.inc), line = 26

	lda #$14
	sta MINIVAUS.WIDTH
	lda #$00
	sta MINIVAUS.WIDTH+1

; optimize OK (btm.inc), line = 27

	lda #$05
	sta MINIVAUS.HEIGHT
	lda #$00
	sta MINIVAUS.HEIGHT+1

; optimize OK (btm.inc), line = 29

	lda #$1F
	sta LEVELSEL.OFS
	lda #$8C
	sta LEVELSEL.OFS+1
	lda #$03
	sta LEVELSEL.OFS+2
	lda #$00
	sta LEVELSEL.OFS+3

; optimize OK (btm.inc), line = 30

	lda #$15
	sta LEVELSEL.WIDTH
	lda #$00
	sta LEVELSEL.WIDTH+1

; optimize OK (btm.inc), line = 31

	lda #$5F
	sta LEVELSEL.HEIGHT
	lda #$00
	sta LEVELSEL.HEIGHT+1

; optimize OK (btm.inc), line = 33

	lda #$EA
	sta LETTERS.OFS
	lda #$93
	sta LETTERS.OFS+1
	lda #$03
	sta LETTERS.OFS+2
	lda #$00
	sta LETTERS.OFS+3

; optimize OK (btm.inc), line = 34

	lda #$80
	sta LETTERS.WIDTH
	lda #$00
	sta LETTERS.WIDTH+1

; optimize OK (btm.inc), line = 35

	lda #$38
	sta LETTERS.HEIGHT
	lda #$00
	sta LETTERS.HEIGHT+1

; optimize OK (btm.inc), line = 37

	lda #$EA
	sta NORMAL.OFS
	lda #$AF
	sta NORMAL.OFS+1
	lda #$03
	sta NORMAL.OFS+2
	lda #$00
	sta NORMAL.OFS+3

; optimize OK (btm.inc), line = 38

	lda #$20
	sta NORMAL.WIDTH
	lda #$00
	sta NORMAL.WIDTH+1

; optimize OK (btm.inc), line = 39

	lda #$07
	sta NORMAL.HEIGHT
	lda #$00
	sta NORMAL.HEIGHT+1

; optimize OK (btm.inc), line = 41

	lda #$CA
	sta LASERS.OFS
	lda #$B0
	sta LASERS.OFS+1
	lda #$03
	sta LASERS.OFS+2
	lda #$00
	sta LASERS.OFS+3

; optimize OK (btm.inc), line = 42

	lda #$20
	sta LASERS.WIDTH
	lda #$00
	sta LASERS.WIDTH+1

; optimize OK (btm.inc), line = 43

	lda #$07
	sta LASERS.HEIGHT
	lda #$00
	sta LASERS.HEIGHT+1

; optimize OK (btm.inc), line = 45

	lda #$AA
	sta ENLARGED.OFS
	lda #$B1
	sta ENLARGED.OFS+1
	lda #$03
	sta ENLARGED.OFS+2
	lda #$00
	sta ENLARGED.OFS+3

; optimize OK (btm.inc), line = 46

	lda #$40
	sta ENLARGED.WIDTH
	lda #$00
	sta ENLARGED.WIDTH+1

; optimize OK (btm.inc), line = 47

	lda #$07
	sta ENLARGED.HEIGHT
	lda #$00
	sta ENLARGED.HEIGHT+1

; optimize OK (btm.inc), line = 49

	lda #$6A
	sta SHOOTS.OFS
	lda #$B3
	sta SHOOTS.OFS+1
	lda #$03
	sta SHOOTS.OFS+2
	lda #$00
	sta SHOOTS.OFS+3

; optimize OK (btm.inc), line = 50

	lda #$0D
	sta SHOOTS.WIDTH
	lda #$00
	sta SHOOTS.WIDTH+1

; optimize OK (btm.inc), line = 51

	lda #$08
	sta SHOOTS.HEIGHT
	lda #$00
	sta SHOOTS.HEIGHT+1

; optimize OK (btm.inc), line = 53

	lda #$D2
	sta FLUX.OFS
	lda #$B3
	sta FLUX.OFS+1
	lda #$03
	sta FLUX.OFS+2
	lda #$00
	sta FLUX.OFS+3

; optimize OK (btm.inc), line = 54

	lda #$08
	sta FLUX.WIDTH
	lda #$00
	sta FLUX.WIDTH+1

; optimize OK (btm.inc), line = 55

	lda #$29
	sta FLUX.HEIGHT
	lda #$00
	sta FLUX.HEIGHT+1

; optimize OK (btm.inc), line = 57

	lda #$1A
	sta BALLDATA.OFS
	lda #$B5
	sta BALLDATA.OFS+1
	lda #$03
	sta BALLDATA.OFS+2
	lda #$00
	sta BALLDATA.OFS+3

; optimize OK (btm.inc), line = 58

	lda #$05
	sta BALLDATA.WIDTH
	lda #$00
	sta BALLDATA.WIDTH+1

; optimize OK (btm.inc), line = 59

	lda #$05
	sta BALLDATA.HEIGHT
	lda #$00
	sta BALLDATA.HEIGHT+1

; optimize OK (btm.inc), line = 61

	lda #$33
	sta PATTERN.OFS
	lda #$B5
	sta PATTERN.OFS+1
	lda #$03
	sta PATTERN.OFS+2
	lda #$00
	sta PATTERN.OFS+3

; optimize OK (btm.inc), line = 62

	lda #$1A
	sta PATTERN.WIDTH
	lda #$00
	sta PATTERN.WIDTH+1

; optimize OK (btm.inc), line = 63

	lda #$18
	sta PATTERN.HEIGHT
	lda #$00
	sta PATTERN.HEIGHT+1

; optimize OK (btm.inc), line = 65

	lda #$A3
	sta PATTERN0.OFS
	lda #$B7
	sta PATTERN0.OFS+1
	lda #$03
	sta PATTERN0.OFS+2
	lda #$00
	sta PATTERN0.OFS+3

; optimize OK (btm.inc), line = 66

	lda #$1A
	sta PATTERN0.WIDTH
	lda #$00
	sta PATTERN0.WIDTH+1

; optimize OK (btm.inc), line = 67

	lda #$18
	sta PATTERN0.HEIGHT
	lda #$00
	sta PATTERN0.HEIGHT+1

; optimize OK (btm.inc), line = 69

	lda #$13
	sta PATTERN1.OFS
	lda #$BA
	sta PATTERN1.OFS+1
	lda #$03
	sta PATTERN1.OFS+2
	lda #$00
	sta PATTERN1.OFS+3

; optimize OK (btm.inc), line = 70

	lda #$0E
	sta PATTERN1.WIDTH
	lda #$00
	sta PATTERN1.WIDTH+1

; optimize OK (btm.inc), line = 71

	lda #$0E
	sta PATTERN1.HEIGHT
	lda #$00
	sta PATTERN1.HEIGHT+1

; optimize OK (btm.inc), line = 73

	lda #$D7
	sta PATTERN2.OFS
	lda #$BA
	sta PATTERN2.OFS+1
	lda #$03
	sta PATTERN2.OFS+2
	lda #$00
	sta PATTERN2.OFS+3

; optimize OK (btm.inc), line = 74

	lda #$26
	sta PATTERN2.WIDTH
	lda #$00
	sta PATTERN2.WIDTH+1

; optimize OK (btm.inc), line = 75

	lda #$23
	sta PATTERN2.HEIGHT
	lda #$00
	sta PATTERN2.HEIGHT+1

; optimize OK (btm.inc), line = 77

	lda #$09
	sta PATTERN3.OFS
	lda #$C0
	sta PATTERN3.OFS+1
	lda #$03
	sta PATTERN3.OFS+2
	lda #$00
	sta PATTERN3.OFS+3

; optimize OK (btm.inc), line = 78

	lda #$1C
	sta PATTERN3.WIDTH
	lda #$00
	sta PATTERN3.WIDTH+1

; optimize OK (btm.inc), line = 79

	lda #$1D
	sta PATTERN3.HEIGHT
	lda #$00
	sta PATTERN3.HEIGHT+1

; optimize OK (btm.inc), line = 81

	lda #$35
	sta PATTERN4.OFS
	lda #$C3
	sta PATTERN4.OFS+1
	lda #$03
	sta PATTERN4.OFS+2
	lda #$00
	sta PATTERN4.OFS+3

; optimize OK (btm.inc), line = 82

	lda #$1E
	sta PATTERN4.WIDTH
	lda #$00
	sta PATTERN4.WIDTH+1

; optimize OK (btm.inc), line = 83

	lda #$1E
	sta PATTERN4.HEIGHT
	lda #$00
	sta PATTERN4.HEIGHT+1

; optimize OK (arkanoid_vbxe.pas), line = 133

	lda #$20
	sta TOTALWALL

; optimize OK (arkanoid_vbxe.pas), line = 135

	lda #$50
	sta SCORE.HISCORE
	lda #$C3
	sta SCORE.HISCORE+1
	lda #$00
	sta SCORE.HISCORE+2
	sta SCORE.HISCORE+3

; optimize OK (arkanoid_vbxe.pas), line = 138

	lda #$01
	sta SOUND_ON

; optimize OK (arkanoid_vbxe.pas), line = 139

	lda #$03
	sta LV
	lda #$00
	sta LV+1

; --- RepeatUntilProlog
l_3A03

; optimize FAIL ('MAINSCREEN', arkanoid_vbxe.pas), line = 146

	jsr MAINSCREEN
	lda MAINSCREEN.RESULT
	sta SCORE.PL_NUMB

; optimize OK (arkanoid_vbxe.pas), line = 148

	jeq l_3A19
	lda #$01
	sta START_GAME.PLAYERS
	lda #$00
	sta START_GAME.PLAYERS+1
	jsr START_GAME
l_3A19

; optimize OK (arkanoid_vbxe.pas), line = 151

	lda SCORE.PL_NUMB
	cmp #$01
	jcs l_3A03

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_0022

; optimize FAIL ('INIT_GAME', arkanoid_vbxe.pas), line = 159

	jsr INIT_GAME

; ------------------------------------------------------------

VBXE_DATA	= $15E00
adr.BLT	= $B100
.var BLT	= adr.BLT .word
adr.BLT.SRC_ADR	= $B100
.var BLT.SRC_ADR	= adr.BLT.SRC_ADR .word
BLT.SRC_ADR.BYTE0	= $B100
BLT.SRC_ADR.BYTE1	= $B101
BLT.SRC_ADR.BYTE2	= $B102
BLT.SRC_STEP_Y	= $B103
BLT.SRC_STEP_X	= $B105
adr.BLT.DST_ADR	= $B106
.var BLT.DST_ADR	= adr.BLT.DST_ADR .word
BLT.DST_ADR.BYTE0	= $B106
BLT.DST_ADR.BYTE1	= $B107
BLT.DST_ADR.BYTE2	= $B108
BLT.DST_STEP_Y	= $B109
BLT.DST_STEP_X	= $B10B
BLT.BLT_WIDTH	= $B10C
BLT.BLT_HEIGHT	= $B10E
BLT.BLT_AND_MASK	= $B10F
BLT.BLT_XOR_MASK	= $B110
BLT.BLT_COLLISION_MASK	= $B111
BLT.BLT_ZOOM	= $B112
BLT.PATTERN_FEATURE	= $B113
BLT.BLT_CONTROL	= $B114
adr.VBXE_RAM	= DATAORIGIN+$00DF	; [8] OBJECT
.var VBXE_RAM	= adr.VBXE_RAM .word
VBXE_RAM.POSITION	= DATAORIGIN+$00DF
VBXE_RAM.SIZE	= DATAORIGIN+$00E3
VRAM	= $5000
ERR1	= $01
ERR2	= $02
ERR3	= $03
ERR4	= $04
SCRMIN	= $0A
SCRMAX	= $D8
SCRTOP	= $0C
SCRBOT	= $C8
VAUS_W	= $22
VAUS_H	= $04
VAUS_LINE	= $B8
EMP	= $FF
BALLDIM	= $05
BALLSPOT	= $03
BALLDEV	= $1E
SPEEDFLASH	= $0A
adr.FLASH	= CODEORIGIN+$005E
.var FLASH	= adr.FLASH .word
adr.SCORE_WALL	= CODEORIGIN+$0069
.var SCORE_WALL	= adr.SCORE_WALL .word
adr.EMERG_DEV	= CODEORIGIN+$007F
.var EMERG_DEV	= adr.EMERG_DEV .word
adr.COLORBLOCK	= CODEORIGIN+$0088
.var COLORBLOCK	= adr.COLORBLOCK .word
GRAYDOWN	= $01
STARTWALL	= $01
BALLSPEED	= $01F4
MAXSPEED	= $07D0
MAXBRWHIT	= $64
PATNUMBER	= $04
adr.POS_DIGIT	= CODEORIGIN+$0092
.var POS_DIGIT	= adr.POS_DIGIT .word
adr.DIGITS	= CODEORIGIN+$0096
.var DIGITS	= adr.DIGITS .word
adr.LEVEL	= CODEORIGIN+$00A1
.var LEVEL	= adr.LEVEL .word
SBDIR	= $0258
DEFLEVEL	= $03
LETTER_PROB	= $012C
LETTER_DROP	= $03E8
LETTER_NUMB	= $08
LETTER_FRM	= $08
LETTER_SBF	= $05
adr.LETTER_DIS	= CODEORIGIN+$00AD
.var LETTER_DIS	= adr.LETTER_DIS .word
FLUXLEVEL	= $B0
adr.BALLDATA	= DATAORIGIN+$0103	; [8] RECORD
.var BALLDATA	= adr.BALLDATA .word
BALLDATA.WIDTH	= DATAORIGIN+$0103
BALLDATA.HEIGHT	= DATAORIGIN+$0105
BALLDATA.OFS	= DATAORIGIN+$0107
adr.PLAYSCREEN	= DATAORIGIN+$010B	; [8] RECORD
.var PLAYSCREEN	= adr.PLAYSCREEN .word
PLAYSCREEN.WIDTH	= DATAORIGIN+$010B
PLAYSCREEN.HEIGHT	= DATAORIGIN+$010D
PLAYSCREEN.OFS	= DATAORIGIN+$010F
adr.PLAYVAUS	= DATAORIGIN+$0113	; [8] RECORD
.var PLAYVAUS	= adr.PLAYVAUS .word
PLAYVAUS.WIDTH	= DATAORIGIN+$0113
PLAYVAUS.HEIGHT	= DATAORIGIN+$0115
PLAYVAUS.OFS	= DATAORIGIN+$0117
adr.NORMAL	= DATAORIGIN+$011B	; [8] RECORD
.var NORMAL	= adr.NORMAL .word
NORMAL.WIDTH	= DATAORIGIN+$011B
NORMAL.HEIGHT	= DATAORIGIN+$011D
NORMAL.OFS	= DATAORIGIN+$011F
adr.ENLARGED	= DATAORIGIN+$0123	; [8] RECORD
.var ENLARGED	= adr.ENLARGED .word
ENLARGED.WIDTH	= DATAORIGIN+$0123
ENLARGED.HEIGHT	= DATAORIGIN+$0125
ENLARGED.OFS	= DATAORIGIN+$0127
adr.LASERS	= DATAORIGIN+$012B	; [8] RECORD
.var LASERS	= adr.LASERS .word
LASERS.WIDTH	= DATAORIGIN+$012B
LASERS.HEIGHT	= DATAORIGIN+$012D
LASERS.OFS	= DATAORIGIN+$012F
adr.EXPLOSION	= DATAORIGIN+$0133	; [8] RECORD
.var EXPLOSION	= adr.EXPLOSION .word
EXPLOSION.WIDTH	= DATAORIGIN+$0133
EXPLOSION.HEIGHT	= DATAORIGIN+$0135
EXPLOSION.OFS	= DATAORIGIN+$0137
adr.NEWVAUS	= DATAORIGIN+$013B	; [8] RECORD
.var NEWVAUS	= adr.NEWVAUS .word
NEWVAUS.WIDTH	= DATAORIGIN+$013B
NEWVAUS.HEIGHT	= DATAORIGIN+$013D
NEWVAUS.OFS	= DATAORIGIN+$013F
adr.PRESENTS	= DATAORIGIN+$0143	; [8] RECORD
.var PRESENTS	= adr.PRESENTS .word
PRESENTS.WIDTH	= DATAORIGIN+$0143
PRESENTS.HEIGHT	= DATAORIGIN+$0145
PRESENTS.OFS	= DATAORIGIN+$0147
adr.SOUNDFX	= DATAORIGIN+$014B	; [8] RECORD
.var SOUNDFX	= adr.SOUNDFX .word
SOUNDFX.WIDTH	= DATAORIGIN+$014B
SOUNDFX.HEIGHT	= DATAORIGIN+$014D
SOUNDFX.OFS	= DATAORIGIN+$014F
adr.SHINEWALL	= DATAORIGIN+$0153	; [8] RECORD
.var SHINEWALL	= adr.SHINEWALL .word
SHINEWALL.WIDTH	= DATAORIGIN+$0153
SHINEWALL.HEIGHT	= DATAORIGIN+$0155
SHINEWALL.OFS	= DATAORIGIN+$0157
adr.MINIVAUS	= DATAORIGIN+$015B	; [8] RECORD
.var MINIVAUS	= adr.MINIVAUS .word
MINIVAUS.WIDTH	= DATAORIGIN+$015B
MINIVAUS.HEIGHT	= DATAORIGIN+$015D
MINIVAUS.OFS	= DATAORIGIN+$015F
adr.LEVELSEL	= DATAORIGIN+$0163	; [8] RECORD
.var LEVELSEL	= adr.LEVELSEL .word
LEVELSEL.WIDTH	= DATAORIGIN+$0163
LEVELSEL.HEIGHT	= DATAORIGIN+$0165
LEVELSEL.OFS	= DATAORIGIN+$0167
adr.LETTERS	= DATAORIGIN+$016B	; [8] RECORD
.var LETTERS	= adr.LETTERS .word
LETTERS.WIDTH	= DATAORIGIN+$016B
LETTERS.HEIGHT	= DATAORIGIN+$016D
LETTERS.OFS	= DATAORIGIN+$016F
adr.SHOOTS	= DATAORIGIN+$0173	; [8] RECORD
.var SHOOTS	= adr.SHOOTS .word
SHOOTS.WIDTH	= DATAORIGIN+$0173
SHOOTS.HEIGHT	= DATAORIGIN+$0175
SHOOTS.OFS	= DATAORIGIN+$0177
adr.FLUX	= DATAORIGIN+$017B	; [8] RECORD
.var FLUX	= adr.FLUX .word
FLUX.WIDTH	= DATAORIGIN+$017B
FLUX.HEIGHT	= DATAORIGIN+$017D
FLUX.OFS	= DATAORIGIN+$017F
adr.VAUS	= DATAORIGIN+$0183	; [13] RECORD
.var VAUS	= adr.VAUS .word
VAUS.X	= DATAORIGIN+$0183
VAUS.Y	= DATAORIGIN+$0184
VAUS.OLDX	= DATAORIGIN+$0185
VAUS.OLDY	= DATAORIGIN+$0187
VAUS.OLDLEN	= DATAORIGIN+$0189
VAUS.WIDTH	= DATAORIGIN+$018B
VAUS.HEIGHT	= DATAORIGIN+$018C
VAUS.FLASH	= DATAORIGIN+$018D
VAUS.IFLASH	= DATAORIGIN+$018E
VAUS.LETTER	= DATAORIGIN+$018F
adr.PATTERN	= DATAORIGIN+$0190	; [8] RECORD
.var PATTERN	= adr.PATTERN .word
PATTERN.WIDTH	= DATAORIGIN+$0190
PATTERN.HEIGHT	= DATAORIGIN+$0192
PATTERN.OFS	= DATAORIGIN+$0194
adr.PATTERN0	= DATAORIGIN+$0198	; [8] RECORD
.var PATTERN0	= adr.PATTERN0 .word
PATTERN0.WIDTH	= DATAORIGIN+$0198
PATTERN0.HEIGHT	= DATAORIGIN+$019A
PATTERN0.OFS	= DATAORIGIN+$019C
adr.PATTERN1	= DATAORIGIN+$01A0	; [8] RECORD
.var PATTERN1	= adr.PATTERN1 .word
PATTERN1.WIDTH	= DATAORIGIN+$01A0
PATTERN1.HEIGHT	= DATAORIGIN+$01A2
PATTERN1.OFS	= DATAORIGIN+$01A4
adr.PATTERN2	= DATAORIGIN+$01A8	; [8] RECORD
.var PATTERN2	= adr.PATTERN2 .word
PATTERN2.WIDTH	= DATAORIGIN+$01A8
PATTERN2.HEIGHT	= DATAORIGIN+$01AA
PATTERN2.OFS	= DATAORIGIN+$01AC
adr.PATTERN3	= DATAORIGIN+$01B0	; [8] RECORD
.var PATTERN3	= adr.PATTERN3 .word
PATTERN3.WIDTH	= DATAORIGIN+$01B0
PATTERN3.HEIGHT	= DATAORIGIN+$01B2
PATTERN3.OFS	= DATAORIGIN+$01B4
adr.PATTERN4	= DATAORIGIN+$01B8	; [8] RECORD
.var PATTERN4	= adr.PATTERN4 .word
PATTERN4.WIDTH	= DATAORIGIN+$01B8
PATTERN4.HEIGHT	= DATAORIGIN+$01BA
PATTERN4.OFS	= DATAORIGIN+$01BC
STATUS	= DATAORIGIN+$01C0
SUCCESS	= DATAORIGIN+$01C1
REMAIN_BLK	= DATAORIGIN+$01C2
TOTALWALL	= DATAORIGIN+$01C3
adr.SCORE	= DATAORIGIN+$01C4	; [27] RECORD
.var SCORE	= adr.SCORE .word
adr.SCORE.PLAYER	= [DATAORIGIN+$01C4] .array [3] .dword
.var SCORE.PLAYER	= adr.SCORE.PLAYER .word
adr.SCORE.WALL_N	= [DATAORIGIN+$01D0] .array [3]
.var SCORE.WALL_N	= adr.SCORE.WALL_N .word
adr.SCORE.LIVES	= [DATAORIGIN+$01D3] .array [3]
.var SCORE.LIVES	= adr.SCORE.LIVES .word
SCORE.HISCORE	= DATAORIGIN+$01D6
SCORE.PL_NUMB	= DATAORIGIN+$01DA
adr.SCORE.ROUNDSEL	= [DATAORIGIN+$01DB] .array [3]
.var SCORE.ROUNDSEL	= adr.SCORE.ROUNDSEL .word
SCORE.ABORTPLAY	= DATAORIGIN+$01DE
CUR_PLAYER	= DATAORIGIN+$01DF
adr.SHINEREC	= DATAORIGIN+$01E0	; [5] RECORD
.var SHINEREC	= adr.SHINEREC .word
SHINEREC.XB	= DATAORIGIN+$01E0
SHINEREC.YB	= DATAORIGIN+$01E1
SHINEREC.FRAME	= DATAORIGIN+$01E2
SHINEREC.BLOCK	= DATAORIGIN+$01E3
SHINEREC.ACTIVE	= DATAORIGIN+$01E4
LV	= DATAORIGIN+$01E5
TRAINER	= DATAORIGIN+$01E7
adr.LETT	= DATAORIGIN+$01E8	; [17] RECORD
.var LETT	= adr.LETT .word
LETT.X	= DATAORIGIN+$01E8
LETT.Y	= DATAORIGIN+$01E9
LETT.TYP	= DATAORIGIN+$01EA
LETT.FRAME	= DATAORIGIN+$01EC
LETT.SUBFRAME	= DATAORIGIN+$01ED
LETT.ACTIVE	= DATAORIGIN+$01EE
LETT.INCOMING	= DATAORIGIN+$01EF
LETT.NEXTX	= DATAORIGIN+$01F1
LETT.NEXTY	= DATAORIGIN+$01F3
LETT.NEXTTYPE	= DATAORIGIN+$01F5
LETT.LAST	= DATAORIGIN+$01F7
adr.FIRE	= DATAORIGIN+$01F9	; [5] RECORD
.var FIRE	= adr.FIRE .word
FIRE.X	= DATAORIGIN+$01F9
FIRE.Y	= DATAORIGIN+$01FA
FIRE.SHOT	= DATAORIGIN+$01FB
FIRE.AVL	= DATAORIGIN+$01FC
FIRE.NW	= DATAORIGIN+$01FD
BALLS_IN_PLAY	= DATAORIGIN+$01FE
SCRFLUX	= DATAORIGIN+$01FF
SCRFLUXCNT	= DATAORIGIN+$0200
SOUND_ON	= DATAORIGIN+$0201
HLP	= DATAORIGIN+$0202
F_HLP	= DATAORIGIN+$0204
adr.ROW	= $C000
.var ROW	= adr.ROW .word
adr.TMP	= $C200
.var TMP	= adr.TMP .word
adr.MODY	= $C300
.var MODY	= adr.MODY .word
adr.MODX	= $C400
.var MODX	= adr.MODX .word
adr.SCANLINE	= $C500
.var SCANLINE	= adr.SCANLINE .word
adr.WALL_P	= $D800
.var WALL_P	= adr.WALL_P .word
adr.WALL	= $DB00
.var WALL	= adr.WALL .word
adr.ALL_WALLS	= $DC00
.var ALL_WALLS	= adr.ALL_WALLS .word
@exit

@halt	ldx #$00
	txs

	.ifdef MAIN.@DEFINES.ROMOFF
	inc portb
	.fi

	ldy #$01

	rts

; ------------------------------------------------------------

.local	@DEFINES
ATARI
CPU_6502
ROMOFF
.endl

.local	@RESOURCE
.endl

.endl							; MAIN

; ------------------------------------------------------------
; ------------------------------------------------------------

.macro	UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.ATARI.@UnitInit
	jsr MAIN.ATARI.@UnitInit
	.fi

	.ifdef MAIN.CRT.@UnitInit
	jsr MAIN.CRT.@UnitInit
	.fi

	.ifdef MAIN.TYPES.@UnitInit
	jsr MAIN.TYPES.@UnitInit
	.fi

	.ifdef MAIN.GRAPH.@UnitInit
	jsr MAIN.GRAPH.@UnitInit
	.fi

	.ifdef MAIN.VBXE.@UnitInit
	jsr MAIN.VBXE.@UnitInit
	.fi

	.ifdef MAIN.JOYSTICK.@UnitInit
	jsr MAIN.JOYSTICK.@UnitInit
	.fi
.endm

; ------------------------------------------------------------

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.ATARI) > 0
	.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
	eif

	ift .SIZEOF(MAIN.CRT) > 0
	.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
	eif

	ift .SIZEOF(MAIN.TYPES) > 0
	.print 'TYPES: ',MAIN.TYPES,'..',MAIN.TYPES+.SIZEOF(MAIN.TYPES)-1
	eif

	ift .SIZEOF(MAIN.GRAPH) > 0
	.print 'GRAPH: ',MAIN.GRAPH,'..',MAIN.GRAPH+.SIZEOF(MAIN.GRAPH)-1
	eif

	ift .SIZEOF(MAIN.VBXE) > 0
	.print 'VBXE: ',MAIN.VBXE,'..',MAIN.VBXE+.SIZEOF(MAIN.VBXE)-1
	eif

	ift .SIZEOF(MAIN.JOYSTICK) > 0
	.print 'JOYSTICK: ',MAIN.JOYSTICK,'..',MAIN.JOYSTICK+.SIZEOF(MAIN.JOYSTICK)-1
	eif

.nowarn	.print 'CODE: ',CODEORIGIN,'..',MAIN.@RESOURCE-1

	ift .SIZEOF(MAIN.@RESOURCE)>0
.nowarn	.print 'RESOURCE: ',MAIN.@RESOURCE,'..',MAIN.@RESOURCE+.SIZEOF(MAIN.@RESOURCE)-1
	eif

@end

.nowarn	.print 'VARS: ',MAIN.@RESOURCE+.SIZEOF(MAIN.@RESOURCE),'..',@end-1

; ------------------------------------------------------------

	?adr = *
	ift (?adr < ?old_adr) && (?old_adr - ?adr < $120)
	?adr = ?old_adr
	eif

	org ?adr
	?old_adr = *

DATAORIGIN
.by  $2D $0C $00 $00 $00 $28 $00 $18  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $27  $00 $00 $00 $17

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 1167

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

	ert DATAORIGIN<@end,'DATA memory overlap'

	run START

; ------------------------------------------------------------

.macro	STATICDATA
.by  $11 $56 $42 $58 $45 $20 $6E $6F  $74 $20 $64 $65 $74 $65 $63 $74  $65 $64 $0B $47 $61 $6D $65 $20
.by  $50 $61 $75 $73 $65 $64 $00 $00  $00 $00 $00 $00 $AA $00 $00 $AA  $00 $00 $00 $55 $AA $00 $AA $00
.by  $00 $00 $AA $00 $AA $00 $AA $AA  $00 $00 $AA $AA $AA $00 $55 $55  $55 $00 $55 $55 $FF $00 $55 $FF
.by  $55 $00 $55 $FF $FF $00 $FF $55  $55 $00 $FF $55 $FF $00 $FF $FF  $55 $00 $FF $FF $FF $00 $FF $D4
.by  $D3 $D2 $D1 $D0 $CF $CE $CD $CC  $CB $00 $00 $0A $00 $14 $00 $1E  $00 $28 $00 $32 $00 $64 $00 $C8
.by  $00 $FA $00 $F4 $01 $E8 $03 $00  $02 $13 $24 $35 $12 $23 $34 $45  $D4 $D3 $D2 $D1 $D0 $CF $CE $CD
.by  $CC $CB $00 $3C $5D $80 $7D $60  $37 $67 $6A $4F $5F $61 $7F $6F  $00 $00 $00 $E8 $03 $2C $01 $64
.by  $00 $3C $00 $23 $00 $00 $10 $14  $03 $12 $14 $14 $03
.endm

	end
